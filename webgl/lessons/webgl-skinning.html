<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-skinning.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to skin a mesh in WebGL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg">

<meta property="og:title" content="WebGL2 Skinning">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg">
<meta property="og:description" content="How to skin a mesh in WebGL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Skinning">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html">
<meta name="twitter:description" content="How to skin a mesh in WebGL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html",
      "inLanguage":"en",
      "name":"WebGL2 Skinning",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Skinning</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-skinning.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-skinning.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-skinning.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-skinning.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-skinning.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-skinning.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Skinning</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Skinning in graphics is the name given to moving a set of vertices based
on the weighted influence of multiple matrices. That&#39;s pretty abstract.</p>
<p>It&#39;s called <em>skinning</em> because it&#39;s typically used to make 3D characters
have a &quot;skeleton&quot; made from &quot;bones&quot; where &quot;bone&quot; is another name for matrix
and then <strong>per vertex</strong> setting the influence of each bone to that vertex.</p>
<p>So for example the hand bone would have nearly 100% influence on the vertices
near the hand of a character where as the foot bone would have zero influence
on those same vertices. The vertices in around the wrist would have some influence form the hand bone and also some from the arm bone.</p>
<p>The basic part is that you need bones (which is just a fancy way of saying
a matrix hierarchy) and weights. Weights are per vertex values that go
from 0 to 1 to say how much a particular bone-matrix affects the position
of that vertex. Weights are kind of like vertex colors as far as data.
One set of weights per vertex. In other words the weights are put in a
buffer and provided through attributes.</p>
<p>Typically you limit the number of weights per vertex partly because
otherwise it would be way too much data.  A character can have anywhere
from 15 bones (Virtua Fighter 1) to 150-300 bones (some modern games).
If you had 300 bones you&#39;d need 300 weights PER vertex PER bone.  If your
character had 10000 vertices that would be 3 million weights needed.</p>
<p>So, instead most realtime skinning systems limit it ~4 weights per vertex.
Usually this is accomplished in an exporter/converter that takes data from
a 3D packages like blender/maya/3dsmax and for each vertex finds the 4
bones with the highest weights and then normalizes those weights</p>
<p>To give an pseudo example a non-skinned vertex is typically computed like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl_Position = projection * view * model * position;
</code></pre><p>A skinned vertex is effectively computed like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl_Position = projection * view *
              (bone1Matrix * position * weight1 +
               bone2Matrix * position * weight2 +
               bone3Matrix * position * weight3 +
               bone4Matrix * position * weight4);
</code></pre><p>As you can see it&#39;s like were computing 4 different positions for each vertex and then blending them back into one by applying the weights.</p>
<p>Assuming you stored the bones matrices in a uniform array, and you
passed in the weights and which bone each weight applies to as
attributes you might do something like</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_position;
in vec4 a_weights;         // 4 weights per vertex
in uvec4 a_boneNdx;        // 4 bone indices per vertex
uniform mat4 bones[MAX_BONES];  // 1 matrix per bone

gl_Position = projection * view *
              (a_bones[a_boneNdx[0]] * a_position * a_weight[0] +
               a_bones[a_boneNdx[1]] * a_position * a_weight[1] +
               a_bones[a_boneNdx[2]] * a_position * a_weight[2] +
               a_boneS[a_boneNdx[3]] * a_position * a_weight[3]);
</code></pre><p>There&#39;s one more issue. Let&#39;s say you have a model of a person with
the origin (0,0,0) on the floor just between their feet.</p>
<div class="webgl_center"><img src="resources/bone-head.svg" style="width: 500px;"></div>

<p>Now imagine you put a matrix/bone/joint at their head and you want to use
that for bone for skinning.  To keep it simple imagine you just set the
weights so the vertices of the head have a weight of 1.0 for the head
bone and no other joints influence those vertices.</p>
<div class="webgl_center"><img src="resources/bone-head-setup.svg" style="width: 500px;"></div>

<p>There&#39;s a problem.
The head vertices are 2 units above the origin.  The head bone is also 2
units above the origin.  If you actually multiplied those head vertices by
the head bone matrix you&#39;d get vertices 4 units above the origin.  The
original 2 units of the vertices + the 2 units of the head bone matrix.</p>
<div class="webgl_center"><img src="resources/bone-head-problem.svg" style="width: 500px;"></div>

<p>A solution is to store a &quot;bind pose&quot; which is an extra matrix per joint of
where each matrix was before you used it to influence the vertices.  In that
case the bind pose of the head matrix would be 2 units above the origin.
So now you can use the inverse of that matrix to subtract out the extra 2
units.</p>
<p>In other words the bone matrices passed to the shader have each been
multiplied by their inverse bind pose so as to make their influence only
how much they changed from their original positions relative to the origin
of the mesh.</p>
<p>Let&#39;s make a small example. We&#39;ll animate in 2d a grid like this</p>
<div class="webgl_center"><img src="resources/skinned-mesh.svg" style="width: 400px;"></div>

<ul>
<li>Where <code class="notranslate" translate="no">b0</code>, <code class="notranslate" translate="no">b1</code>, and <code class="notranslate" translate="no">b2</code> are the bone matrices.</li>
<li><code class="notranslate" translate="no">b1</code> is a child of <code class="notranslate" translate="no">b0</code> and <code class="notranslate" translate="no">b2</code> is a child of <code class="notranslate" translate="no">b1</code></li>
<li>Verts <code class="notranslate" translate="no">0,1</code> will get a weight of 1.0 from bone b0</li>
<li>Verts <code class="notranslate" translate="no">2,3</code> will get a weight of 0.5 from bones b0 and b1</li>
<li>Verts <code class="notranslate" translate="no">4,5</code> will get a weight of 1.0 from bone b1</li>
<li>Verts <code class="notranslate" translate="no">6,7</code> will get a weight of 0.5 from bones b1 and b2</li>
<li>Verts <code class="notranslate" translate="no">8,9</code> will get a weight of 1.0 from bone b2</li>
</ul>
<p>We&#39;ll use the utils described in <a href="webgl-less-code-more-fun.html">less code more fun</a>.</p>
<p>First we need the vertices and for each vertex the index
of each bone that influences it and a number from 0 to 1
of how much influence that bone has.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const arrays = {
  position: {
    numComponents: 2,
    data: [
    0,  1,  // 0
    0, -1,  // 1
    2,  1,  // 2
    2, -1,  // 3
    4,  1,  // 4
    4, -1,  // 5
    6,  1,  // 6
    6, -1,  // 7
    8,  1,  // 8
    8, -1,  // 9
    ],
  },
  boneNdx: {
    numComponents: 4,
    data: new Uint8Array([
      0, 0, 0, 0,  // 0
      0, 0, 0, 0,  // 1
      0, 1, 0, 0,  // 2
      0, 1, 0, 0,  // 3
      1, 0, 0, 0,  // 4
      1, 0, 0, 0,  // 5
      1, 2, 0, 0,  // 6
      1, 2, 0, 0,  // 7
      2, 0, 0, 0,  // 8
      2, 0, 0, 0,  // 9
    ]),
  },
  weight: {
    numComponents: 4,
    data: [
    1, 0, 0, 0,  // 0
    1, 0, 0, 0,  // 1
    .5,.5, 0, 0,  // 2
    .5,.5, 0, 0,  // 3
    1, 0, 0, 0,  // 4
    1, 0, 0, 0,  // 5
    .5,.5, 0, 0,  // 6
    .5,.5, 0, 0,  // 7
    1, 0, 0, 0,  // 8
    1, 0, 0, 0,  // 9
    ],
  },

  indices: {
    numComponents: 2,
    data: [
      0, 1,
      0, 2,
      1, 3,
      2, 3, //
      2, 4,
      3, 5,
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  },
};
// calls gl.createBuffer, gl.bindBuffer, gl.bufferData
const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
const skinVAO = twgl.createVAOFromBufferInfo(gl, programInfo, bufferInfo);
</code></pre><p>We can define our uniform values including a matrix for each bone</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 4 matrices, one for each bone
const numBones = 4;
const boneArray = new Float32Array(numBones * 16);

var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
  bones: boneArray,
  color: [1, 0, 0, 1],
};
</code></pre><p>We can make views into the boneArray, one for each matrix</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// make views for each bone. This lets all the bones
// exist in 1 array for uploading but as separate
// arrays for using with the math functions
const boneMatrices = [];  // the uniform data
const bones = [];         // the value before multiplying by inverse bind matrix
const bindPose = [];      // the bind matrix
for (let i = 0; i &lt; numBones; ++i) {
  boneMatrices.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
  bindPose.push(m4.identity());  // just allocate storage
  bones.push(m4.identity());     // just allocate storage
}
</code></pre><p>And then some code to manipulate the bone matrixes. We&#39;ll just rotate
them in a heirarchy like the bones of a finger.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// rotate each bone by angle and simulate a hierarchy
function computeBoneMatrices(bones, angle) {
  const m = m4.identity();
  m4.zRotate(m, angle, bones[0]);
  m4.translate(bones[0], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[1]);
  m4.translate(bones[1], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[2]);
  // bones[3] is not used
}
</code></pre><p>Now call it once to generate their initial positions and use the result
to compute the inverse bind pose matrices.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// compute the initial positions of each matrix
computeBoneMatrices(bindPose, 0);

// compute their inverses
const bindPoseInv = bindPose.map(function(m) {
  return m4.inverse(m);
});
</code></pre><p>Now we&#39;re ready to render</p>
<p>First we animate the bones, conmputing a new world matrix for each</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const t = time * 0.001;
const angle = Math.sin(t) * 0.8;
computeBoneMatrices(bones, angle);
</code></pre><p>Then we multiple the result of each by the inverse bind pose to deal with
the issue mentioned above</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// multiply each by its bindPoseInverse
bones.forEach((bone, ndx) =&gt; {
  m4.multiply(bone, bindPoseInv[ndx], boneMatrices[ndx]);
});
</code></pre><p>Then all the normal stuff, setting up the attributes, setting the uniforms, and drawing.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(programInfo.program);

gl.bindVertexArray(skinVAO);

// calls gl.uniformXXX, gl.activeTexture, gl.bindTexture
twgl.setUniforms(programInfo, uniforms);

// calls gl.drawArrays or gl.drawIndices
twgl.drawBufferInfo(gl, bufferInfo, gl.LINES);
</code></pre><p>And here&#39;s the result</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>The red lines are the <em>skinned</em> mesh.  The green and blue lines represent
the x-axis and y-axis of each bone or &quot;joint&quot;. You can see how the vertices
that are influenced by multiple bones move between the bones that influence
them. We didn&#39;t cover how the bones are drawn as it&#39;s not important to
explaining how skinning works. See the code if you&#39;re curious.</p>
<p>NOTE: bones vs joints is confusing. There&#39;s only 1 thing, <em>matrices</em>.
But, in a 3d modelling package they usually draw a gizmo (a ui widget)
between each matrix. That looks ends up looking like a bone. The joints
are where matrices are and they draw a line or cone from each joint
to the next to make it kind of look like a skeleton.</p>
<div class="webgl_center">
  <img src="resources/bone-display.png" style="width: 351px;">
  <div class="caption"><a href="https://www.blendswap.com/blends/view/66412">LowPoly Man</a> by <a href="https://www.blendswap.com/user/TiZeta">TiZeta</a></div>
</div>

<p>One thing to note that we might not have done before, we made a <code class="notranslate" translate="no">uvec4</code> attribute which is an attribute that receives unsigned integers. If we were not using twgl
we&#39;d have to call <code class="notranslate" translate="no">gl.vertexAttribIPointer</code> to set it up instead of the more
common <code class="notranslate" translate="no">gl.vertexAttibPointer</code>.</p>
<p>Unfortunately there&#39;s a limit to the number of uniforms you can use in a shader.
The lower limit on WebGL is 64 vec4s which is only 8 mat4s and you probably
need some of those uniforms for other things like for example we have <code class="notranslate" translate="no">color</code>
in the fragment shader and we have <code class="notranslate" translate="no">projection</code> and <code class="notranslate" translate="no">view</code> which means if
we were on a device with a limit of 64 vec4s we could only have 5 bones! Checking
<a href="https://web3dsurvey.com/webgl/parameters/MAX_VERTEX_UNIFORM_VECTORS">WebGLStats</a>
most devices support 128 vec4s and 70% of them support 256 vec4s but with
are sample above that&#39;s still only 13 bones and 29 bones respectively. 13 is
not even enough for a early 90s Virtua Fighter 1 style character and 29 is not
close to the number used in most modern games.</p>
<p>A couple ways around that. One is to pre-process the models offline and break them
into multiple parts each one using no more than N bones. That&#39;s pretty complicated
and brings it&#39;s own set of issues.</p>
<p>Another is to store the bone matrices in a texture. This is an important reminder
that textures are not just images, they are effectively 2D arrays of random access
data that you can pass to a shader and you can use them for all kinds of things
that are not just reading images for texturing.</p>
<p>Let&#39;s pass our matrices in a texture to bypass the uniform limit. To make this
easy we&#39;re going to use floating point textures.</p>
<p>Let&#39;s update the shader to get the matrices out of a texture.
We&#39;ll make the texture have one matrix per row. Each texel of the texture
has R, G, B, and A, that&#39;s 4 values so we only need 4 pixels per matrix,
one pixel for each row of the matrix.
Textures can usually be at least 2048 pixels in certain dimension so
this will give us room for at least 2048 bone matrices which is plenty.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_position;
in vec4 a_weight;
in uvec4 a_boneNdx;

uniform mat4 projection;
uniform mat4 view;
*uniform sampler2D boneMatrixTexture;

+mat4 getBoneMatrix(uint boneNdx) {
+  return mat4(
+    texelFetch(boneMatrixTexture, ivec2(0, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(1, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(2, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(3, boneNdx), 0));
+}

void main() {

  gl_Position = projection * view *
*                (getBoneMatrix(a_boneNdx[0]) * a_position * a_weight[0] +
*                 getBoneMatrix(a_boneNdx[1]) * a_position * a_weight[1] +
*                 getBoneMatrix(a_boneNdx[2]) * a_position * a_weight[2] +
*                 getBoneMatrix(a_boneNdx[3]) * a_position * a_weight[3]);

}
</code></pre><p>Notice we&#39;re using <code class="notranslate" translate="no">texelFetch</code> instead of <code class="notranslate" translate="no">texture</code> to get data from
the texture. <code class="notranslate" translate="no">texelFetch</code> retrieves a single texel from the texture.
It takes as input a, sampler, an ivec2 with the x,y coordinate of the texture
in texels, and the mip level as in</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 data = texelFetch(sampler2D, ivec2(x, y), lod);
</code></pre><p>Now we&#39;ll setup a texture we can put the bone matrices in</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// prepare the texture for bone matrices
const boneMatrixTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
// since we want to use the texture for pure data we turn
// off filtering
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre><p>And we&#39;ll pass that texture as a uniform.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
*  boneMatrixTexture,
  color: [1, 0, 0, 1],
};
</code></pre><p>Then the only thing we need to change is to update the texture with the
latest bone matrices when rendering</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// update the texture with the current matrices
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,          // level
    gl.RGBA32F, // internal format
    4,          // width 4 pixels, each pixel has RGBA so 4 pixels is 16 values
    numBones,   // one row per bone
    0,          // border
    gl.RGBA,    // format
    gl.FLOAT,   // type
    boneArray);
</code></pre><p>The result it the same but we&#39;ve solved the issue that there aren&#39;t
enough uniforms to pass in the matrices via uniforms.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-bone-matrices-in-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-bone-matrices-in-texture.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>So that&#39;s the basics of skinning. It&#39;s not so hard to write the code to display
a skinned mesh. The harder part is actually getting data. You generally need
some 3D software like blender/maya/3d studio max, and then to either write
your own exporter or find a an exporter and format that will provide all the data needed. You&#39;ll see as we go over it that there is 10x more code in loading a skin than there is in displaying it and that doesn&#39;t include the probably 20-30x more code in the exporter to get the data out of the 3D modeling program. As an aside this is one of the things people writing their own 3D engine often miss. The engine is the easy part 😜</p>
<p>There&#39;s going to be a lot of code so let&#39;s first try to just get the un-skinned model to display.</p>
<p>Let&#39;s try loading a glTF file. <a href="https://www.khronos.org/gltf/">glTF</a> as it&#39;s kind of designed for WebGL. Searching the net I found <a href="https://www.blendswap.com/blends/view/65255">this killer whale blender file</a> by <a href="https://www.blendswap.com/user/pasilan">Junskie Pastilan</a></p>
<div class="webgl_center"><img src="../resources/models/killer_whale/thumbnail.jpg"></div>

<p>There are 2 top level formats for glTF. The <code class="notranslate" translate="no">.gltf</code> format is a JSON file that generally references a <code class="notranslate" translate="no">.bin</code> file which is a binary file that contains usually just the geometry and possibly animation data. The other format is <code class="notranslate" translate="no">.glb</code> which is a binary format. It&#39;s basically just the JSON and any other files concatinated into one binary file with a short header and a size/type section between each
concatinated piece. For JavaScript I think the <code class="notranslate" translate="no">.gltf</code> format is slightly easier to get started with so let&#39;s try to load that.</p>
<p>First <a href="https://www.blendswap.com/blends/view/65255">I downloaded the .blend file</a>, installed <a href="https://blender.org">blender</a>, installed <a href="https://github.com/KhronosGroup/glTF-Blender-IO">the gltf exporter</a>, loaded the file into blender and exported.</p>
<div class="webgl_center"><img src="resources/blender-killer-whale.png" style="width: 700px;" class="nobg"></div>

<blockquote>
<p>A quick note: 3D software like Blender, Maya, 3DSMax is extremely complex software with 1000s of options. When I first learned 3DSMax in 1996 I spent 2-3 hrs a day reading through the 1000+ page manual and working though the tutorials for about 3 weeks. I did something similar when I learned Maya a few years later. Blender is just as complicated and further it has a very different interface from pretty much all other software. This is just a short way of saying that you should expect to spend some significant time learning whatever 3D package you decide to use.</p>
</blockquote>
<p>After exporting it I loaded the .gltf file into my text editor and took a look around. I used <a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">this cheat sheet</a> to figure out the format.</p>
<p>I want to make it clear the code below is not a perfect glTF loader. It&#39;s just enough code to get the whale to display. I suspect that if we tried different files we&#39;d run into areas that need to be changed.</p>
<p>The first thing we need to do is load the file. To make it simpler let&#39;s use JavaScript&#39;s <a href="https://javascript.info/async-await">async/await</a>. First let&#39;s write some code to load the <code class="notranslate" translate="no">.gltf</code> file and any files it references.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">async function loadGLTF(url) {
  const gltf = await loadJSON(url);

  // load all the referenced files relative to the gltf file
  const baseURL = new URL(url, location.href);
  gltf.buffers = await Promise.all(gltf.buffers.map((buffer) =&gt; {
    const url = new URL(buffer.uri, baseURL.href);
    return loadBinary(url.href);
  }));

  ...

async function loadFile(url, typeFunc) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`could not load: ${url}`);
  }
  return await response[typeFunc]();
}

async function loadBinary(url) {
  return loadFile(url, &#39;arrayBuffer&#39;);
}

async function loadJSON(url) {
  return loadFile(url, &#39;json&#39;);
}
</code></pre><p>Now we need to walk through the data and connect things up.</p>
<p>First let&#39;s handle what glTF considers a mesh. A mesh is collection of primitives. A primitive is effectively the buffers and attributes needed to render something. Let&#39;s use the <a href="https://twgljs.org">twgl library</a> we covered in <a href="webgl-less-code-more-fun.html">less code more fun</a>. We&#39;ll walk the meshes and for each one build a <code class="notranslate" translate="no">BufferInfo</code> we can pass to <code class="notranslate" translate="no">twgl.createVAOFromBufferInfo</code>. Recall a <code class="notranslate" translate="no">BufferInfo</code> is effectively just the attribute information, the indicies if there are any, and the number of elements to pass to <code class="notranslate" translate="no">gl.drawXXX</code>. For example a cube with just positions and normals might have a BufferInfo with this structure</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const cubeBufferInfo = {
  attribs: {
    &#39;a_POSITION&#39;: { buffer: WebGLBuffer, type: gl.FLOAT, numComponents: 3, },
    &#39;a_NORMAL&#39;: { buffer: WebGLBuffer, type: gl.FLOAT, numComponents: 3, },
  },
  numElements: 24,
  indices: WebGLBuffer,
  elementType: gl.UNSIGNED_SHORT,
}
</code></pre><p>So we will walk each primitive and generate a BufferInfo like that.</p>
<p>Primitives have an array of attributes, each attribute references an accessor. An accessor says what kind of data is there, for example <code class="notranslate" translate="no">VEC3</code>/<code class="notranslate" translate="no">gl.FLOAT</code> and references a bufferView. A bufferView specifies some view into a buffer. Given an accessor index we can write some code that returns a WebGLBuffer with the data loaded, the accessor, and the stride specified for the bufferView.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Given an accessor index return an accessor, WebGLBuffer and a stride
function getAccessorAndWebGLBuffer(gl, gltf, accessorIndex) {
  const accessor = gltf.accessors[accessorIndex];
  const bufferView = gltf.bufferViews[accessor.bufferView];
  if (!bufferView.webglBuffer) {
    const buffer = gl.createBuffer();
    const target = bufferView.target || gl.ARRAY_BUFFER;
    const arrayBuffer = gltf.buffers[bufferView.buffer];
    const data = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, data, gl.STATIC_DRAW);
    bufferView.webglBuffer = buffer;
  }
  return {
    accessor,
    buffer: bufferView.webglBuffer,
    stride: bufferView.stride || 0,
  };
}
</code></pre><p>We also need a way to convert from an glTF accessor type to a number of components</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function throwNoKey(key) {
  throw new Error(`no key: ${key}`);
}

const accessorTypeToNumComponentsMap = {
  &#39;SCALAR&#39;: 1,
  &#39;VEC2&#39;: 2,
  &#39;VEC3&#39;: 3,
  &#39;VEC4&#39;: 4,
  &#39;MAT2&#39;: 4,
  &#39;MAT3&#39;: 9,
  &#39;MAT4&#39;: 16,
};

function accessorTypeToNumComponents(type) {
  return accessorTypeToNumComponentsMap[type] || throwNoKey(type);
}
</code></pre><p>Now that we&#39;ve made these functions we can use them to setup our meshes</p>
<p>Note: glTF files can supposedly define materials but the exporter didn&#39;t put any materials in the file even though export materials was checked. I can only guess the exporter doesn&#39;t handle every kind of material in blender which is unfortunate. We&#39;ll use a default material if there is no material in the file. Since there are no materials in this file there&#39;s no code here to use glTF materials.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const defaultMaterial = {
  uniforms: {
    u_diffuse: [.5, .8, 1, 1],
  },
};

// setup meshes
gltf.meshes.forEach((mesh) =&gt; {
  mesh.primitives.forEach((primitive) =&gt; {
    const attribs = {};
    let numElements;
    for (const [attribName, index] of Object.entries(primitive.attributes)) {
      const {accessor, buffer, stride} = getAccessorAndWebGLBuffer(gl, gltf, index);
      numElements = accessor.count;
      attribs[`a_${attribName}`] = {
        buffer,
        type: accessor.componentType,
        numComponents: accessorTypeToNumComponents(accessor.type),
        stride,
        offset: accessor.byteOffset | 0,
      };
    }

    const bufferInfo = {
      attribs,
      numElements,
    };

    if (primitive.indices !== undefined) {
      const {accessor, buffer} = getAccessorAndWebGLBuffer(gl, gltf, primitive.indices);
      bufferInfo.numElements = accessor.count;
      bufferInfo.indices = buffer;
      bufferInfo.elementType = accessor.componentType;
    }

    primitive.bufferInfo = bufferInfo;

    // make a VAO for this primitive
    primitive.vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, primitive.bufferInfo);

    // save the material info for this primitive
    primitive.material = gltf.materials &amp;&amp; gltf.materials[primitive.material] || defaultMaterial;
  });
});
</code></pre><p>Now each primitive will have a <code class="notranslate" translate="no">bufferInfo</code> and a <code class="notranslate" translate="no">material</code> property.</p>
<p>For skinning we almost always need some kind of scene graph. We created a scene graph in <a href="webgl-scene-graph.html">the article about scene graphs</a> so let&#39;s use that one.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class TRS {
  constructor(position = [0, 0, 0], rotation = [0, 0, 0, 1], scale = [1, 1, 1]) {
    this.position = position;
    this.rotation = rotation;
    this.scale = scale;
  }
  getMatrix(dst) {
    dst = dst || new Float32Array(16);
    m4.compose(this.position, this.rotation, this.scale, dst);
    return dst;
  }
}

class Node {
  constructor(source, name) {
    this.name = name;
    this.source = source;
    this.parent = null;
    this.children = [];
    this.localMatrix = m4.identity();
    this.worldMatrix = m4.identity();
    this.drawables = [];
  }
  setParent(parent) {
    if (this.parent) {
      this.parent._removeChild(this);
      this.parent = null;
    }
    if (parent) {
      parent._addChild(this);
      this.parent = parent;
    }
  }
  updateWorldMatrix(parentWorldMatrix) {
    const source = this.source;
    if (source) {
      source.getMatrix(this.localMatrix);
    }

    if (parentWorldMatrix) {
      // a matrix was passed in so do the math
      m4.multiply(parentWorldMatrix, this.localMatrix, this.worldMatrix);
    } else {
      // no matrix was passed in so just copy local to world
      m4.copy(this.localMatrix, this.worldMatrix);
    }

    // now process all the children
    const worldMatrix = this.worldMatrix;
    for (const child of this.children) {
      child.updateWorldMatrix(worldMatrix);
    }
  }
  traverse(fn) {
    fn(this);
    for (const child of this.children) {
      child.traverse(fn);
    }
  }
  _addChild(child) {
    this.children.push(child);
  }
  _removeChild(child) {
    const ndx = this.children.indexOf(child);
    this.children.splice(ndx, 1);
  }
}
</code></pre><p>There are a couple of notable changes from the code in <a href="webgl-scene-graph.html">the scene graph article</a>.</p>
<ul>
<li><p>This code is using the <code class="notranslate" translate="no">class</code> feature of ES6.</p>
<p>It&#39;s much nicer to use the <code class="notranslate" translate="no">class</code> syntax than the old style of defining a class.</p>
</li>
<li><p>We added an array of drawables to <code class="notranslate" translate="no">Node</code></p>
<p>This will list the things to draw from this Node. We&#39;ll put
instances of a class on this list that are responsible for doing
the actual drawing. This way we can generically draw different things
by using different classes.</p>
<p>Note: It&#39;s not clear to me that putting an array of drawables on Node
is the best decision. I feel like the scene graph itself should
maybe not contain drawables at all. Things that need to be drawn could instead
just reference the node in the graph where to get their data.
This way with drawables in the graph is common though so lets start with that.</p>
</li>
<li><p>We added a <code class="notranslate" translate="no">traverse</code> method.</p>
<p>It calls a function passing it the current node and then recursively doing the
same for all child nodes.</p>
</li>
<li><p>The <code class="notranslate" translate="no">TRS</code> class is using a quaternion for rotation</p>
<p>We have not covered quaternions and to be honest I don&#39;t think I understand
them well enough to explain them. Fortunately we don&#39;t need to know how they
work to use them. We just take the data out of the gltf file and call
a function that builds a matrix from that data and use the matrix.</p>
</li>
</ul>
<p>The nodes in the glTF file are stored as a flat array.
We&#39;ll convert node data in the glTF to <code class="notranslate" translate="no">Node</code> instances. We save off the old array
of node data as <code class="notranslate" translate="no">origNodes</code> as we&#39;ll need it later.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const origNodes = gltf.nodes;
gltf.nodes = gltf.nodes.map((n) =&gt; {
  const {name, skin, mesh, translation, rotation, scale} = n;
  const trs = new TRS(translation, rotation, scale);
  const node = new Node(trs, name);
  const realMesh =　gltf.meshes[mesh];
  if (realMesh) {
    node.drawables.push(new MeshRenderer(realMesh));
  }
  return node;
});
</code></pre><p>Above we created a <code class="notranslate" translate="no">TRS</code> instance for each node, a <code class="notranslate" translate="no">Node</code> instance for each node, and, if there was a <code class="notranslate" translate="no">mesh</code> property we looked up the mesh data we setup before and created a <code class="notranslate" translate="no">MeshRenderer</code> to draw it.</p>
<p>Let&#39;s make the <code class="notranslate" translate="no">MeshRenderer</code>. It&#39;s just an encapsulation of the code we used in <a href="webgl-less-code-more-fun.html">less code more fun</a> to rendener a single model. All it does is hold a reference to a mesh and then for each primitive sets up the program, attributes, and uniforms and finally calls <code class="notranslate" translate="no">gl.drawArrays</code> or <code class="notranslate" translate="no">gl.drawElements</code> via <code class="notranslate" translate="no">twgl.drawBufferInfo</code>;</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class MeshRenderer {
  constructor(mesh) {
    this.mesh = mesh;
  }
  render(node, projection, view, sharedUniforms) {
    const {mesh} = this;
    gl.useProgram(meshProgramInfo.program);
    for (const primitive of mesh.primitives) {
      gl.bindVertexArray(primitive.vao);
      twgl.setUniforms(meshProgramInfo, {
        u_projection: projection,
        u_view: view,
        u_world: node.worldMatrix,
      }, primitive.material.uniforms, sharedUniforms);
      twgl.drawBufferInfo(gl, primitive.bufferInfo);
    }
  }
}
</code></pre><p>We&#39;ve created the nodes, now we need to actually arrange them into a scene graph. This is done at 2 levels in glTF.
First, each node has an optional array of children that are also indicies into the array of nodes so we can walk all
the nodes and parent their children</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function addChildren(nodes, node, childIndices) {
  childIndices.forEach((childNdx) =&gt; {
    const child = nodes[childNdx];
    child.setParent(node);
  });
}

// arrange nodes into graph
gltf.nodes.forEach((node, ndx) =&gt; {
  const children = origNodes[ndx].children;
  if (children) {
    addChildren(gltf.nodes, node, children);
  }
});
</code></pre><p>Then there is an array of scenes. A scene references an
array of nodes by index into the nodes array that are at the bottom of the scene. It&#39;s not clear to me why they didn&#39;t just start with a single root node but whatever, it&#39;s what&#39;s in the glTF file so we create a root node and parent all the scene&#39;s children to that node</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // setup scenes
  for (const scene of gltf.scenes) {
    scene.root = new Node(new TRS(), scene.name);
    addChildren(gltf.nodes, scene.root, scene.nodes);
  }

  return gltf;
}
</code></pre><p>and we&#39;re done with loading, at least just the meshes. Let&#39;s
mark the main function as <code class="notranslate" translate="no">async</code> so we can use the <code class="notranslate" translate="no">await</code>
keyword.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">async function main() {
</code></pre><p>and we can load the gltf file like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const gltf = await loadGLTF(&#39;resources/models/killer_whale/whale.CYCLES.gltf&#39;);
</code></pre><p>To render we need a shader that matches the data in the gltf file. Let&#39;s look at the data in the gltf file for the primitive that&#39;s in it</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">{
    &quot;name&quot; : &quot;orca&quot;,
    &quot;primitives&quot; : [
        {
            &quot;attributes&quot; : {
                &quot;JOINTS_0&quot; : 5,
                &quot;NORMAL&quot; : 2,
                &quot;POSITION&quot; : 1,
                &quot;TANGENT&quot; : 3,
                &quot;TEXCOORD_0&quot; : 4,
                &quot;WEIGHTS_0&quot; : 6
            },
            &quot;indices&quot; : 0
        }
    ]
}
</code></pre><p>Looking at that, to render let&#39;s just use <code class="notranslate" translate="no">NORMAL</code> and <code class="notranslate" translate="no">POSITION</code>. We prepended <code class="notranslate" translate="no">a_</code> to the front of each attribute so a vertex shader like this should work</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_POSITION;
in vec3 a_NORMAL;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

out vec3 v_normal;

void main() {
  gl_Position = u_projection * u_view * u_world * a_POSITION;
  v_normal = mat3(u_world) * a_NORMAL;
}
</code></pre><p>and for the fragment shader let&#39;s use a simple directional light</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
precision highp float;

int vec3 v_normal;

uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;

out vec4 outColor;

void main () {
  vec3 normal = normalize(v_normal);
  float light = dot(u_lightDirection, normal) * .5 + .5;
  outColor = vec4(u_diffuse.rgb * light, u_diffuse.a);
}
</code></pre><p>Notice we take the dot product like we covered in <a href="webgl-3d-lighting-directional.html">the article on direcitonal lights</a> but unlike that one, here the dot product is multipled by .5 and we add .5. With normal directional lighting the surface is lit 100% when directly facing the light and trails off to 0% when the surface is perpendicular to the light. That means the entire 1/2 of the model facing away from the light is black. By multiplying by .5 and adding .5 we take the dot product from -1 &lt;-&gt; 1 to 0 &lt;-&gt; 1 which means it will only be black when facing the complete opposite direciton. This gives a cheap but pleasing lighting for simple tests.</p>
<p>So, we need to compile and link the shaders.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// compiles and links the shaders, looks up attribute and uniform locations
const meshProgramInfo = twgl.createProgramInfo(gl, [meshVS, fs]);
</code></pre><p>and then to render all that&#39;s different from before is this</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const sharedUniforms = {
  u_lightDirection: m4.normalize([-1, 3, 5]),
};

function renderDrawables(node) {
  for(const drawable of node.drawables) {
      drawable.render(node, projection, view, sharedUniforms);
  }
}

for (const scene of gltf.scenes) {
  // updatte all world matices in the scene.
  scene.root.updateWorldMatrix();
  // walk the scene and render all renderables
  scene.root.traverse(renderDrawables);
}
</code></pre><p>Left over from before (not shown above) is our code for computing a projection matrix, camera matrix, and view matrix. We then just walk each scene, call <code class="notranslate" translate="no">scene.root.updateWorldMatrix</code> which will update the world
matrix of all the nodes in that graph. Then we call <code class="notranslate" translate="no">scene.root.traverse</code> with <code class="notranslate" translate="no">renderDrawables</code>.</p>
<p><code class="notranslate" translate="no">renderDrawables</code> calls the render method of all the drawables on that node passing in the projection, view, and lighting info via <code class="notranslate" translate="no">sharedUniforms</code>.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-3d-gltf.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-3d-gltf.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Now that that&#39;s working let&#39;s handle the skins.</p>
<p>First let&#39;s make a class to represent a skin. It will manage the list of joints, which is another word for nodes in the scene graph that apply to the skin. It will also have the inverse bind matrices and it will manage the texture we put the joint matrices in.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class Skin {
  constructor(joints, inverseBindMatrixData) {
    this.joints = joints;
    this.inverseBindMatrices = [];
    this.jointMatrices = [];
    // allocate enough space for one matrix per joint
    this.jointData = new Float32Array(joints.length * 16);
    // create views for each joint and inverseBindMatrix
    for (let i = 0; i &lt; joints.length; ++i) {
      this.inverseBindMatrices.push(new Float32Array(
          inverseBindMatrixData.buffer,
          inverseBindMatrixData.byteOffset + Float32Array.BYTES_PER_ELEMENT * 16 * i,
          16));
      this.jointMatrices.push(new Float32Array(
          this.jointData.buffer,
          Float32Array.BYTES_PER_ELEMENT * 16 * i,
          16));
    }
    // create a texture to hold the joint matrices
    this.jointTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.jointTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }
  update(node) {
    const globalWorldInverse = m4.inverse(node.worldMatrix);
    // go through each joint and get its current worldMatrix
    // apply the inverse bind matrices and store the
    // entire result in the texture
    for (let j = 0; j &lt; this.joints.length; ++j) {
      const joint = this.joints[j];
      const dst = this.jointMatrices[j];
      m4.multiply(globalWorldInverse, joint.worldMatrix, dst);
      m4.multiply(dst, this.inverseBindMatrices[j], dst);
    }
    gl.bindTexture(gl.TEXTURE_2D, this.jointTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, 4, this.joints.length, 0,
                  gl.RGBA, gl.FLOAT, this.jointData);
  }
}
</code></pre><p>And like we had a <code class="notranslate" translate="no">MeshRenderer</code> let&#39;s make a <code class="notranslate" translate="no">SkinRenderer</code> that uses the <code class="notranslate" translate="no">Skin</code> to render a skinned mesh.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class SkinRenderer {
  constructor(mesh, skin) {
    this.mesh = mesh;
    this.skin = skin;
  }
  render(node, projection, view, sharedUniforms) {
    const {skin, mesh} = this;
    skin.update(node);
    gl.useProgram(skinProgramInfo.program);
    for (const primitive of mesh.primitives) {
      gl.bindVertexArray(primitive.vao);
      twgl.setUniforms(skinProgramInfo, {
        u_projection: projection,
        u_view: view,
        u_world: node.worldMatrix,
        u_jointTexture: skin.jointTexture,
        u_numJoints: skin.joints.length,
      }, primitive.material.uniforms, sharedUniforms);
      twgl.drawBufferInfo(gl, primitive.bufferInfo);
    }
  }
}
</code></pre><p>You can see it&#39;s very similar to the <code class="notranslate" translate="no">MeshRenderer</code>. It has a reference to a <code class="notranslate" translate="no">Skin</code> which it uses to update all the matrices needed to render. Then it follows the standard pattern for rendering, using the program, setting up the attributes, setting all the uniforms using <code class="notranslate" translate="no">twgl.setUniforms</code> which also binds textures, and then rendering.</p>
<p>We also need a vertex shader that supports skinning</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const skinVS = `#version 300 es
in vec4 a_POSITION;
in vec3 a_NORMAL;
in vec4 a_WEIGHTS_0;
in uvec4 a_JOINTS_0;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform sampler2D u_jointTexture;
uniform float u_numJoints;

out vec3 v_normal;

mat4 getBoneMatrix(uint jointNdx) {
  return mat4(
    texelFetch(u_jointTexture, ivec2(0, jointNdx), 0),
    texelFetch(u_jointTexture, ivec2(1, jointNdx), 0),
    texelFetch(u_jointTexture, ivec2(2, jointNdx), 0),
    texelFetch(u_jointTexture, ivec2(3, jointNdx), 0));
}

void main() {
  mat4 skinMatrix = getBoneMatrix(a_JOINTS_0[0]) * a_WEIGHTS_0[0] +
                    getBoneMatrix(a_JOINTS_0[1]) * a_WEIGHTS_0[1] +
                    getBoneMatrix(a_JOINTS_0[2]) * a_WEIGHTS_0[2] +
                    getBoneMatrix(a_JOINTS_0[3]) * a_WEIGHTS_0[3];
  mat4 world = u_world * skinMatrix;
  gl_Position = u_projection * u_view * world * a_POSITION;
  v_normal = mat3(world) * a_NORMAL;
}
`;
</code></pre><p>This is pretty much the same as our skinning shader above. We renamed the attributes to match what&#39;s in the gltf file.
The biggest change it making a <code class="notranslate" translate="no">skinMatrix</code>. In our previous skinning shader we multiplied the position by each individual joint/bone matrix and multplied those by the weight of influcence for each joint. In this case we instead add up the matrices multiplied by the weights and just multiply by position once. This produces same result but we can use the <code class="notranslate" translate="no">skinMatrix</code> to multiply the normal as well which we need to do otherwise the normals won&#39;t match the skin.</p>
<p>Also notice we multiply in the <code class="notranslate" translate="no">u_world</code> matrix here. We subtracted it out in <code class="notranslate" translate="no">Skin.update</code> with these lines</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*const globalWorldInverse = m4.inverse(node.worldMatrix);
// go through each joint and get its current worldMatrix
// apply the inverse bind matrices and store the
// entire result in the texture
for (let j = 0; j &lt; this.joints.length; ++j) {
  const joint = this.joints[j];
  const dst = this.jointMatrices[j];
*  m4.multiply(globalWorldInverse, joint.worldMatrix, dst);
</code></pre><p>Whether you do that or not is up to you. The reason to do it is it lets you instance the skin. In other words you can render the skinned mesh in the exact same pose at more than
one place in the same frame. The idea being that if there are lots of joints then doing all the matrix math for a skinned mesh is slow so
you do that math once and then you can display that skinned
mesh in different places just by re-rendering with a different world matrix.</p>
<p>That&#39;s maybe useful for displaying a crowd of characters. Unfortunately all the characters will be in the exact same pose so it&#39;s unclear to me if it&#39;s really that useful or not. How often does that situation actually come up? You can remove multiplying by the inverse world matrix of the node in <code class="notranslate" translate="no">Skin</code> and remove mutlplying by <code class="notranslate" translate="no">u_world</code> in the shader and the result will look the same, you just can&#39;t <em>instance</em> that skinned mesh. Of course you can render the same skinned mesh as many times as you want in different poses. You&#39;ll need a different <code class="notranslate" translate="no">Skin</code> object pointing to different nodes that are in some other orientation.</p>
<p>Back in our loading code, when we&#39;re making <code class="notranslate" translate="no">Node</code> instances, if there&#39;s a <code class="notranslate" translate="no">skin</code> property we&#39;ll remember it so we can make a <code class="notranslate" translate="no">Skin</code> for it.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+const skinNodes = [];
const origNodes = gltf.nodes;
gltf.nodes = gltf.nodes.map((n) =&gt; {
  const {name, skin, mesh, translation, rotation, scale} = n;
  const trs = new TRS(translation, rotation, scale);
  const node = new Node(trs, name);
  const realMesh =　gltf.meshes[mesh];
+  if (skin !== undefined) {
+    skinNodes.push({node, mesh: realMesh, skinNdx: skin});
+  } else if (realMesh) {
    node.drawables.push(new MeshRenderer(realMesh));
  }
  return node;
});
</code></pre><p>After making <code class="notranslate" translate="no">Node</code>s we need to make <code class="notranslate" translate="no">Skin</code>s. Skins reference nodes via a <code class="notranslate" translate="no">joints</code> array which is a list of indices of nodes that supply the matrices for the joints.
A skin also references an accessor that references the inverse bind pose matrices saved in the file.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// setup skins
gltf.skins = gltf.skins.map((skin) =&gt; {
  const joints = skin.joints.map(ndx =&gt; gltf.nodes[ndx]);
  const {stride, array} = getAccessorTypedArrayAndStride(gl, gltf, skin.inverseBindMatrices);
  return new Skin(joints, array);
});
</code></pre><p>The code above called <code class="notranslate" translate="no">getAccessorTypedArrayAndStride</code> given an accessor index. We need supply that code. For a given accessor we&#39;ll return a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a> view of the correct type to get access to the data in the buffer.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const glTypeToTypedArrayMap = {
  &#39;5120&#39;: Int8Array,    // gl.BYTE
  &#39;5121&#39;: Uint8Array,   // gl.UNSIGNED_BYTE
  &#39;5122&#39;: Int16Array,   // gl.SHORT
  &#39;5123&#39;: Uint16Array,  // gl.UNSIGNED_SHORT
  &#39;5124&#39;: Int32Array,   // gl.INT
  &#39;5125&#39;: Uint32Array,  // gl.UNSIGNED_INT
  &#39;5126&#39;: Float32Array, // gl.FLOAT
}

// Given a GL type return the TypedArray needed
function glTypeToTypedArray(type) {
  return glTypeToTypedArrayMap[type] || throwNoKey(type);
}

// given an accessor index return both the accessor and
// a TypedArray for the correct portion of the buffer
function getAccessorTypedArrayAndStride(gl, gltf, accessorIndex) {
  const accessor = gltf.accessors[accessorIndex];
  const bufferView = gltf.bufferViews[accessor.bufferView];
  const TypedArray = glTypeToTypedArray(accessor.componentType);
  const buffer = gltf.buffers[bufferView.buffer];
  return {
    accessor,
    array: new TypedArray(
        buffer,
        bufferView.byteOffset + (accessor.byteOffset || 0),
        accessor.count * accessorTypeToNumComponents(accessor.type)),
    stride: bufferView.byteStride || 0,
  };
}
</code></pre><p>Something to note about the code above is we&#39;ve made a table with hardcoded WebGL constants. This is the first time we&#39;ve done this. The constants won&#39;t change so this is safe to do.</p>
<p>Now what we have the skins we can go back and add them to the nodes that referenced them.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Add SkinRenderers to nodes with skins
for (const {node, mesh, skinNdx} of skinNodes) {
  node.drawables.push(new SkinRenderer(mesh, gltf.skins[skinNdx]));
}
</code></pre><p>If we rendered like this we might not see any difference. We need to animate some of the nodes. Let&#39;s just go through each node in the <code class="notranslate" translate="no">Skin</code>, in other words each joint, and rotate it plus a minus a little on the local X access.</p>
<p>To do this we&#39;ll save off the original local matrix for each joint. We&#39;ll then rotate that original matrix some amount each frame, and using a special function, <code class="notranslate" translate="no">m4.decompose</code>, will will convert the matrix back into position, rotation, scale into the joint.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const origMatrix = new Map();
function animSkin(skin, a) {
  for(let i = 0; i &lt; skin.joints.length; ++i) {
    const joint = skin.joints[i];
    // if there is no matrix saved for this joint
    if (!origMatrix.has(joint)) {
      // save a matrix for joint
      origMatrix.set(joint, joint.source.getMatrix());
    }
    // get the original matrix
    const origMatrix = origRotations.get(joint);
    // rotate it
    const m = m4.xRotate(origMatrix, a);
    // decompose it back into position, rotation, scale
    // into the joint
    m4.decompose(m, joint.source.position, joint.source.rotation, joint.source.scale);
  }
}
</code></pre><p>and then just before rendering we&#39;ll call that</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">animSkin(gltf.skins[0], Math.sin(time) * .5);
</code></pre><p>Note <code class="notranslate" translate="no">animSkin</code> is mostly a hack. Ideally we&#39;d load an animation some artist created OR we&#39;d know the names of specific joints we want to manipulate in code in some way. In this case we just to see if our skinning is working and this seemed like the easist way to do it.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-3d-gltf-skinned.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-3d-gltf-skinned.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>A few more notes before we move on</p>
<p>When I first tried to get this working, as with most programs things didn&#39;t appear on the screen.</p>
<p>So, the first thing did was go to the end of the skinning shader and add this line</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  gl_Position = u_projection * u_view *  a_POSITION;
</code></pre><p>In the fragment shader I changed it to just draw a solid color by adding this at the end</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">outColor = vec4(1, 0, 0, 1);
</code></pre><p>This removes all the skinning and just draws the mesh at the origin. I adjusted the camera position until I had a good view.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const cameraPosition = [5, 0, 5];
const target = [0, 0, 0];
</code></pre><p>This showed a silhouette of the killer whale so I knew at least some of the data was working.</p>
<div class="webgl_center"><img src="resources/skinning-debug-01.png"></div>

<p>Next I made the fragment shader show the normals</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">outColor = vec4(normalize(v_normal) * .5 + .5, 1);
</code></pre><p>Normals go from -1 to 1 so the <code class="notranslate" translate="no">* .5 + .5</code> adjusts them to 0 to 1 for viewing as colors.</p>
<p>Back in the vertex shader I just passed the normal through</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v_normal = a_NORMAL;
</code></pre><p>Which gave me a view like this</p>
<div class="webgl_center"><img src="resources/skinning-debug-02.png"></div>

<p>I didn&#39;t expect the normals to be bad but it was good to start with something I expected to work and confirm that it does indeed work.</p>
<p>Next I thought I&#39;d check the weights. All I needed to do was
pass the weights as normals from the vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v_normal = a_WEIGHTS_0.xyz * 2. - 1.;
</code></pre><p>Weights go from 0 to 1 but since the fragment shader is expecting normals I just made the weights go from -1 to 1</p>
<p>This originally produced a kind of mess of colors. Once I figured out the bug, I got an image like this</p>
<div class="webgl_center"><img src="resources/skinning-debug-03.png"></div>

<p>It&#39;s not entirely obvious it&#39;s correct but does make some sense. You&#39;d expect the vertices nearest each bone to have a strong color and you&#39;d expect to see rings of that color in the vertices around the bone since the weights in that area are likely 1.0 or at least all similar.</p>
<p>Since the original image was so messy I also tried displaying the joint indices with</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v_normal = vec3(a_JOINTS_0.xyz) / float(textureSize(u_jointTexture, 0).y - 1) * 2. - 1.;
</code></pre><p>The indices go from 0 to numJoints - 1 so the code above would give values from -1 to 1.</p>
<p>Once things were working I got an image like this</p>
<div class="webgl_center"><img src="resources/skinning-debug-04.png"></div>

<p>Again it was originally a mess of colors. The image above is what it looked like after it was fixed. That&#39;s pretty much what you&#39;d expect to see for weights for the killer whale. Rings of color around each bone.</p>
<p>The bug had to do with how <code class="notranslate" translate="no">twgl.createBufferInfoFromArrays</code>, which I used instead of twgl when I started making this sample, was figuring out the number of components. There were cases where it ignored the one specified, tried to guess, and guessed wrong. Once the bug was fixed then I removed those changes to the shaders. Note that I left them in the code above commented out if you want to play with them.</p>
<p>I want to make it clear the code above is meant to help explain skinning. It is not meant to be a production ready skinning engine. I think if we were to try to make a production quality engine we&#39;d run into many things we&#39;d probably want to change but I hope going through this example helps slight demystify skinning.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-skinning.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Skinning';
            var disqus_title = 'WebGL2 Skinning';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




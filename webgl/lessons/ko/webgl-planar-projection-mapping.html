<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-planar-projection-mapping.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="텍스처를 평면으로 투영">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg">

<meta property="og:title" content="WebGL2 평면 및 원근 투영 매핑">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg">
<meta property="og:description" content="텍스처를 평면으로 투영">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 평면 및 원근 투영 매핑">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">
<meta name="twitter:description" content="텍스처를 평면으로 투영">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html",
      "inLanguage":"ko",
      "name":"WebGL2 평면 및 원근 투영 매핑",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 평면 및 원근 투영 매핑</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-planar-projection-mapping.html" >English</a>
    <option value="/webgl/lessons/de/webgl-planar-projection-mapping.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-planar-projection-mapping.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-planar-projection-mapping.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-planar-projection-mapping.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 평면 및 원근 투영 매핑</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글에서는 예제를 간결하게 하기 위해 <a href="webgl-less-code-more-fun.html">더 적은 코드로 즐겁게</a>에서 언급된 라이브러리를 사용하므로 여러분들이 해당 글을 읽었다고 가정합니다.
버퍼, 정점 배열, attribute가 무엇인지, <code class="notranslate" translate="no">twgl.setUniforms</code>이라는 함수가 뭐고 uniform을 설정한다는 것이 어떤 의미인지 등을 모르시겠다면 뒤로 돌아가서 [WebGL2 기초를 먼저 읽어 보셔야 할겁니다]](webgl-fundamentals.html).</p>
<p>또한 <a href="webgl-3d-perspective.html">원근 투영</a>, <a href="webgl-3d-camera.html">카메라</a>, <a href="webgl-3d-textures.html">텍스처</a>, <a href="webgl-visualizing-the-camera.html">카메라 시각화</a>에 대한 글을 읽었다고 가정하기 때문에 해당 글들을 먼저 읽어 보십시오.</p>
<p>투영 매핑은 프로젝터가 스크린을 향하게 하고 영화를 투사하는 것과 같이 이미지를 “투영하는(projecting)” 방법입니다.
프로젝터는 투시면을 투사합니다.
스크린이 프로젝터에서 멀어질수록 이미지는 더 커집니다.
스크린의 각도가 바뀌어서 프로젝터가 스크린에 수직이 아니게 된다면  사다리꼴이나 임의의 사변형으로 나타날겁니다.</p>
<div class="webgl_center"><img src="../resources/perspective-projection.svg" style="width: 400px"></div>
<p>물론 투영 매핑이 꼭 평면에 이루어져야 할 필요는 없습니다.
원통형 투영 매핑, 구형 투영 매핑 등등도 있습니다.</p>
<p>먼저 평면 투영 매핑을 살펴봅시다.
이 경우 프로젝터가 스크린의 크기만큼 커서,
스크린이 프로젝터에서 멀어진다고 영상이 커지지 않고 동일한 크기를 유지한다고 생각해봅시다.</p>
<div class="webgl_center"><img src="../resources/orthographic-projection.svg" style="width: 400px"></div>
<p>먼저 평면과 구체를 그리는 간단한 장면을 만들어 보겠습니다.
두 물체 모두 간단한 8x8 체커 보드 텍스처를 사용할 겁니다.</p>
<p>셰이더는 다양한 행렬이 분리되어 있어서 자바스크립트 쪽에서 미리 곱할 필요가 없다는 걸 제외하면 <a href="webgl-3d-textures.html">텍스처에 관한 글</a>의 셰이더와 유사합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 a_position;
in vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

out vec2 v_texcoord;

void main() {
  gl_Position = u_projection * u_view * u_world * a_position;

  // 프래그먼트 셰이더로 텍스처 좌표 전달
  v_texcoord = a_texcoord;
}
`;
</code></pre>
<p>또한 텍스처 색상에 곱할 <code class="notranslate" translate="no">u_colorMult</code> uniform을 추가하였습니다.
단색 텍스처를 만들면 이 값으로 색상을 변경할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
precision highp float;

// 정점 셰이더에서 전달된 값
in vec2 v_texcoord;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;

out vec4 outColor;

void main() {
  outColor = texture(u_texture, v_texcoord) * u_colorMult;
}
`;
</code></pre>
<p>다음은 프로그램, 구에 대한 버퍼, 평면에 대한 버퍼를 설정하는 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL 프로그램 설정
// 셰이더 컴파일, 링킹, location 탐색
const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);

const sphereBufferInfo = primitives.createSphereBufferInfo(
    gl,
    1,  // 반지름
    12, // 좌우방향 분할
    6,  // 상하방향 분할
);
const sphereVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, sphereBufferInfo);
const planeBufferInfo = primitives.createPlaneBufferInfo(
    gl,
    20,  // 너비
    20,  // 높이
    1,   // 가로지르는 방향 분할
    1,   // 상하방향 분할
);
const planeVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, planeBufferInfo);
</code></pre>
<p>그리고 아래는 <a href="webgl-data-textures.html">데이터 텍스처에 관한 글</a>에서 다룬 기술을 사용하여 8x8 픽셀 크기의 체커 보드 텍스처를 만드는 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 8x8 체커 보드 텍스처 만들기
const checkerboardTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,                // 밉맵 수준
    gl.LUMINANCE,     // 내부 포맷
    8,                // 너비
    8,                // 높이
    0,                // 테두리
    gl.LUMINANCE,     // 포맷
    gl.UNSIGNED_BYTE, // 타입
    new Uint8Array([  // 데이터
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
    ]));
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>화면에 그리기 위해 투영 행렬과 카메라 행렬을 가져오고, 카메라 행렬로 뷰 행렬을 계산한 다음, 구체와 육면체를 그리는 함수를 만들겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 각 물체에 대한 uniform
const planeUniforms = {
  u_colorMult: [0.5, 0.5, 1, 1],  // 하늘색
  u_texture: checkerboardTexture,
  u_world: m4.translation(0, 0, 0),
};
const sphereUniforms = {
  u_colorMult: [1, 0.5, 0.5, 1],  // 분홍색
  u_texture: checkerboardTexture,
  u_world: m4.translation(2, 3, 4),
};

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(textureProgramInfo.program);

  // 구체와 평면이 공유하는 uniform 설정
  twgl.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
  });

  // ------ 구체 그리기 --------

  // 필요한 모든 attribute 설정
  gl.bindVertexArray(sphereVAO);

  // 구체에 고유한 uniform 설정
  twgl.setUniforms(textureProgramInfo, sphereUniforms);

  // gl.drawArrays 혹은 gl.drawElements 호출
  twgl.drawBufferInfo(gl, sphereBufferInfo);

  // ------ 평면 그리기 --------

  // 필요한 모든 attribute 설정
  gl.bindVertexArray(planeVAO);

  // 평면에 고유한 uniform 설정
  twgl.setUniforms(textureProgramInfo, planeUniforms);

  // gl.drawArrays 혹은 gl.drawElements 호출
  twgl.drawBufferInfo(gl, planeBufferInfo);
}
</code></pre>
<p>우리는 위 코드를 <code class="notranslate" translate="no">render</code> 함수에서 아래와 같이 사용할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
};
const fieldOfViewRadians = degToRad(60);

function render() {
  twgl.resizeCanvasToDisplaySize(gl.canvas);

  // 클립 공간에서 픽셀로 변환하는 방법을 WebGL에 알려줌
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  // 캔버스와 깊이 버퍼 지우기
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // 투영 행렬 계산
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

  // lookAt을 사용하여 카메라 행렬 계산
  const cameraPosition = [settings.cameraX, settings.cameraY, 7];
  const target = [0, 0, 0];
  const up = [0, 1, 0];
  const cameraMatrix = m4.lookAt(cameraPosition, target, up);

  drawScene(projectionMatrix, cameraMatrix);
}
render();
</code></pre>
<p>이제 평면과 구체가 있는 간단한 장면이 생겼습니다.
이해를 돕기 위해 카메라 위치를 변경하는 슬라이더를 추가했습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-setup.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-setup.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>이제 구체와 평면에 텍스처를 평면 투영해봅시다.</p>
<p>먼저 <a href="webgl-3d-textures.html">텍스처를 로드</a>합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function loadImageTexture(url) {
  // 텍스처 생성
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // 1x1 파란 픽셀로 텍스처 채우기
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 255, 255]));
  // 비동기적으로 이미지 로드
  const image = new Image();
  image.src = url;
  image.addEventListener('load', function() {
    // 이미지 로드가 완료되었기 때문에 텍스처로 복사
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    // 텍스처가 2의 거듭 제곱이라 가정
    gl.generateMipmap(gl.TEXTURE_2D);
    render();
  });
  return texture;
}

const imageTexture = loadImageTexture('resources/f-texture.png');
</code></pre>
<p><a href="webgl-visualizing-the-camera.html">카메라 시각화에 대한 글</a>을 떠올려보면, -1에서 +1사이의 육면체를 만들고 카메라의 절두체를 나타내도록 그렸습니다.
절두체 내부의 공간이 월드 공간에서 -1에서 +1사이의 클립 공간으로 변환되는 월드 공간 내부에 있는 절두체 모양의 영역을 나타내도록 행렬을 만들었는데요.
여기서도 비슷하게 할 수 있습니다.</p>
<p>한 번 해봅시다.
먼저 프래그먼트 셰이더에서 텍스처 좌표가 0.0에서 1.0사이인 곳에 투영된 텍스처를 그립니다.
해당 범위 밖에서는 체커 보드 텍스처를 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
precision highp float;

// 정점 셰이더에서 전달된 값
in vec2 v_texcoord;
+in vec4 v_projectedTexcoord;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
+uniform sampler2D u_projectedTexture;

out vec4 outColor;

void main() {
-  outColor = texture(u_texture, v_texcoord) * u_colorMult;
+  // 올바른 값을 얻기 위해 w로 나누기 (원근 투영에 대한 글 참고)
+  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
+
+  bool inRange = 
+      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
+      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
+      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
+      projectedTexcoord.y &lt;= 1.0;
+
+  vec4 projectedTexColor = texture(u_projectedTexture, projectedTexcoord.xy);
+  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;
+
+  float projectedAmount = inRange ? 1.0 : 0.0;
+  outColor = mix(texColor, projectedTexColor, projectedAmount);
}
`;
</code></pre>
<p>투영된 텍스처 좌표를 계산하기 위해 <a href="webgl-visualizing-the-camera.html">카메라 시각화</a>에 관한 글에서의 카메라처럼, 특정 방향을 향하도록 위치와 자세가 설정된 3D 공간을 나타내는 행렬을 만듭니다.
그런 다음 구체와 평면의 정점들의 월드 공간 좌표를 해당 공간으로 투영합니다.
그 값이 0과 1사이에 있다면 위에 작성한 코드를 통해 텍스처가 나타날겁니다.</p>
<p>정점 셰이더에 코드를 추가해서 구체와 평면이 이 <em>공간</em>에 투영되도록 합시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 a_position;
in vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
+uniform mat4 u_textureMatrix;

out vec2 v_texcoord;
+out vec4 v_projectedTexcoord;

void main() {
+  vec4 worldPosition = u_world * a_position;

-  gl_Position = u_projection * u_view * u_world * a_position;
+  gl_Position = u_projection * u_view * worldPosition;

  // 프래그먼트 셰이더로 텍스처 좌표 전달
  v_texcoord = a_texcoord;

+  v_projectedTexcoord = u_textureMatrix * worldPosition;
}
</code></pre>
<p>이제 남은 것은 이 공간을 정의하는 행렬을 실제로 계산하는 겁니다.
다른 물체들과 마찬가지로 월드 행렬을 계산한 다음 역행렬을 취하면 됩니다.
이 행렬을 사용하면 월드 공간 좌표가 이 공간에 대한 상대 좌표로 변환됩니다.
이건 <a href="webgl-3d-camera.html">카메라에 대한 글</a>에서 사용한 뷰 행렬과 동일합니다.</p>
<p>마찬가지로 <a href="webgl-3d-camera.html">같은 글</a>에서 만들었던 <code class="notranslate" translate="no">lookAt</code> 함수를 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
+  posX: 3.5,
+  posY: 4.4,
+  posZ: 4.7,
+  targetX: 0.8,
+  targetY: 0,
+  targetZ: 4.7,
};

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로부터 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // position
      [settings.targetX, settings.targetY, settings.targetZ], // target
      [0, 1, 0],                                              // up
  );

  // 이 월드 행렬의 역행렬을
  // 어떠한 position을 이 월드 공간에 대한
  // 상대 위치로 변환하는데 사용할 수 있습니다.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  // 구체와 평면 모두에 동일한 uniform 설정
  twgl.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
+    u_textureMatrix: textureMatrix,
+    u_projectedTexture: imageTexture,
  });

  ...
}
</code></pre>
<p>물론 꼭 <code class="notranslate" translate="no">lookAt</code>을 사용하지 않아도 됩니다.
예를 들어 <a href="webgl-scene-graph.html">장면 그래프</a>나 <a href="webgl-2d-matrix-stack.html">행렬 스택</a>을 사용하여 월드 행렬을 만들 수도 있습니다.</p>
<p>실행 전에 scale을 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 3.5,
  posY: 4.4,
  posZ: 4.7,
  targetX: 0.8,
  targetY: 0,
  targetZ: 4.7,
+  projWidth: 2,
+  projHeight: 2,
};

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로부터 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // position
      [settings.targetX, settings.targetY, settings.targetZ], // target
      [0, 1, 0],                                              // up
  );
+  textureWorldMatrix = m4.scale(
+      textureWorldMatrix,
+      settings.projWidth, settings.projHeight, 1,
+  );

  // 이 월드 행렬의 역행렬을
  // 어떠한 position을 이 월드 공간에 대한
  // 상대 위치로 변환하는데 사용할 수 있습니다.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  ...
}
</code></pre>
<p>이를 통해 투영된 텍스처가 나타납니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>텍스처가 들어있는 공간을 보기 힘들 수도 있을 것 같습니다.
시각화를 돕기 위해 와이어프레임으로 표시되는 육면체를 추가해봅시다.</p>
<p>먼저 별도의 셰이더들이 필요합니다.
이 셰이더는 텍스처 없이, 단색만 그립니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const colorVS = `#version 300 es
in vec4 a_position;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

void main() {
  // position과 행렬을 곱하기
  gl_Position = u_projection * u_view * u_world * a_position;
}
`;
</code></pre>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const colorFS = `#version 300 es
precision highp float;

uniform vec4 u_color;

out vec4 outColor;

void main() {
  outColor = u_color;
}
`;
</code></pre>
<p>그런 다음 이 셰이더들도 컴파일하고 링크해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL program 설정
const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);
+const colorProgramInfo = twgl.createProgramInfo(gl, [colorVS, colorFS]);
</code></pre>
<p>그리고 선으로 이루어진 육면체를 그리기 위한 데이터가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sphereBufferInfo = primitives.createSphereBufferInfo(
    gl,
    1,  // 반지름
    12, // 좌우방향 분할
    6,  // 상하방향 분할
);
const sphereVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, sphereBufferInfo);
const planeBufferInfo = primitives.createPlaneBufferInfo(
    gl,
    20,  // 너비
    20,  // 높이
    1,   // 가로지르는 방향 분할
    1,   // 상하방향 분할
);
const planeVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, planeBufferInfo);
+const cubeLinesBufferInfo = twgl.createBufferInfoFromArrays(gl, {
+  position: [
+     0,  0, -1,
+     1,  0, -1,
+     0,  1, -1,
+     1,  1, -1,
+     0,  0,  1,
+     1,  0,  1,
+     0,  1,  1,
+     1,  1,  1,
+  ],
+  indices: [
+    0, 1,
+    1, 3,
+    3, 2,
+    2, 0,
+
+    4, 5,
+    5, 7,
+    7, 6,
+    6, 4,
+
+    0, 4,
+    1, 5,
+    3, 7,
+    2, 6,
+  ],
+});
+const cubeLinesVAO = twgl.createVAOFromBufferInfo(
+    gl, colorProgramInfo, cubeLinesBufferInfo);
</code></pre>
<p>이 큐브는 텍스처 좌표에 맞추기 위해 X와 Y에 대해 0에서 1사이가 됩니다.
Z의 경우 -1에서 1사이입니다.
이건 양쪽 방향으로 늘려 크기를 조정하기 위한 겁니다.</p>
<p>이 코드의 목적은 공간의 표현을 위해 육면체를 그리는 것이기 때문에 이전의 <code class="notranslate" translate="no">textureWorldMatrix</code>를 사용하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(projectionMatrix, cameraMatrix) {

  ...
+  // ------ 육면체 그리기 ------
+
+  gl.useProgram(colorProgramInfo.program);
+
+  // 필요한 모든 attribute 설정
+  gl.bindVertexArray(cubeLinesVAO);
+
+  // 텍스처가 무한히 먼 곳에서 투영되는 것을 표현하기 위해
+  // 육면체의 Z를 스케일링해서 아주 길게 만듭니다.
+  const mat = m4.scale(textureWorldMatrix, 1, 1, 1000);
+
+  // 계산된 값으로 uniform을 설정
+  twgl.setUniforms(colorProgramInfo, {
+    u_color: [0, 0, 0, 1],
+    u_view: viewMatrix,
+    u_projection: projectionMatrix,
+    u_world: mat,
+  });
+
+  // gl.drawArrays 혹은 gl.drawElements 호출
+  twgl.drawBufferInfo(gl, cubeLinesBufferInfo, gl.LINES);
}
</code></pre>
<p>이제 투영이 어떻게 이루어지는지 더 쉽게 알 수 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-lines.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-lines.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>실제로는 텍스처를 <em>투영</em>하는 것이 아니라는 점을 이해하는 것이 중요합니다. 오히려 정 반대죠.
렌더링되는 물체의 각 픽셀에 대해 텍스처의 어느 부분이 거기에 투영되는지 확인한 다음 텍스처의 해당 부분에서 색상을 찾는 겁니다.</p>
<p>위에서 프로젝터를 언급했는데 어떻게 프로젝터를 시뮬레이션할 수 있을까요?
기본적으로는 그냥 투영 행렬을 곱하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 2.5,
  posY: 4.8,
  posZ: 4.3,
  targetX: 2.5,
  targetY: 0,
  targetZ: 3.5,
  projWidth: 1,
  projHeight: 1,
+  perspective: true,
+  fieldOfView: 45,
};

...

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  const textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // position
      [settings.targetX, settings.targetY, settings.targetZ], // target
      [0, 1, 0],                                              // up
  );
-  textureWorldMatrix = m4.scale(
-      textureWorldMatrix,
-      settings.projWidth, settings.projHeight, 1,
-  );
  
+  const textureProjectionMatrix = settings.perspective
+      ? m4.perspective(
+          degToRad(settings.fieldOfView),
+          settings.projWidth / settings.projHeight,
+          0.1,  // near
+          200)  // far
+      : m4.orthographic(
+          -settings.projWidth / 2,   // left
+           settings.projWidth / 2,   // right
+          -settings.projHeight / 2,  // bottom
+           settings.projHeight / 2,  // top
+           0.1,                      // near
+           200);                     // far

  // 이 월드 행렬의 역행렬을
  // 어떠한 position을 이 월드 공간에 대한
  // 상대 위치로 변환하는데 사용할 수 있습니다.
-  const textureMatrix = m4.inverse(textureWorldMatrix);
+  const textureMatrix = m4.multiply(
+      textureProjectionMatrix,
+      m4.inverse(textureWorldMatrix));
</code></pre>
<p>원근 투영 행렬이나 직교 투영 행렬을 선택적으로 사용할 수 있다는 점에 주목하십시오.</p>
<p>또한 선을 그릴 때 이 투영 행렬을 사용해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// ------ 큐브 그리기 ------

...

-// 텍스처가 무한히 먼 곳에서 투영되는 것을 표현하기 위해
-// 육면체의 Z를 스케일링해서 아주 길게 만듭니다.
-const mat = m4.scale(textureWorldMatrix, 1, 1, 1000);

+// 평면 투영과 일치하도록 육면체 변환
+const mat = m4.multiply(
+    textureWorldMatrix, m4.inverse(textureProjectionMatrix));
</code></pre>
<p>이러면 다음과 같은 결과를 얻습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-projection-matrix-0-to-1.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-projection-matrix-0-to-1.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>작동은 하지만 평면 투영과 육면체를 나타내는 선이 모두 0에서 1사이의 공간만을 사용하므로 투영 절두체의 1/4만 사용하고 있습니다.</p>
<p>이를 해결하기 위해 먼저 육면체를 모든 방향으로 -1에서 +1사이인 육면체로 만들어봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const cubeLinesBufferInfo = twgl.createBufferInfoFromArrays(gl, {
  position: [
-     0,  0, -1,
-     1,  0, -1,
-     0,  1, -1,
-     1,  1, -1,
-     0,  0,  1,
-     1,  0,  1,
-     0,  1,  1,
-     1,  1,  1,
+    -1, -1, -1,
+     1, -1, -1,
+    -1,  1, -1,
+     1,  1, -1,
+    -1, -1,  1,
+     1, -1,  1,
+    -1,  1,  1,
+     1,  1,  1,
  ],
  indices: [
    0, 1,
    1, 3,
    3, 2,
    2, 0,

    4, 5,
    5, 7,
    7, 6,
    6, 4,

    0, 4,
    1, 5,
    3, 7,
    2, 6,
  ],
});
</code></pre>
<p>그런 다음 텍스처 행렬로 사용할 때는 절두체 내부 공간을 0에서 1사이로 만들어야 하는데, 공간을 0.5만큼 오프셋을 주고하고 0.5로만큼 스케일링하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const textureWorldMatrix = m4.lookAt(
    [settings.posX, settings.posY, settings.posZ],          // position
    [settings.targetX, settings.targetY, settings.targetZ], // target
    [0, 1, 0],                                              // up
);
const textureProjectionMatrix = settings.perspective
    ? m4.perspective(
        degToRad(settings.fieldOfView),
        settings.projWidth / settings.projHeight,
        0.1,  // near
        200)  // far
    : m4.orthographic(
        -settings.projWidth / 2,   // left
         settings.projWidth / 2,   // right
        -settings.projHeight / 2,  // bottom
         settings.projHeight / 2,  // top
         0.1,                      // near
         200);                     // far

-// 이 월드 행렬의 역행렬을
-// 어떠한 position을 이 월드 공간에 대한
-// 상대 위치로 변환하는데 사용할 수 있습니다.
-const textureMatrix = m4.multiply(
-    textureProjectionMatrix,
-    m4.inverse(textureWorldMatrix));

+let textureMatrix = m4.identity();
+textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
+textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);
+textureMatrix = m4.multiply(textureMatrix, textureProjectionMatrix);
+// 이 월드 행렬의 역행렬을
+// 어떠한 position을 이 월드 공간에 대한
+// 상대 위치로 변환하는데 사용할 수 있습니다.
+textureMatrix = m4.multiply(
+    textureMatrix,
+    m4.inverse(textureWorldMatrix));
</code></pre>
<p>이제 잘 동작합니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-projection-matrix.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-projection-matrix.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>그래서 텍스처를 평면으로 투영해서 좋은 점은 뭘까요?</p>
<p>하나는 그냥 만들어 보고 싶기 때문입니다, 하하.
대부분의 3D 모델링 패키지는 텍스처를 평면으로 투영하는 기능을 제공합니다.</p>
<p>또 하나는 데칼(decal)입니다.
데칼은 표면에 페인트 얼룩이나 폭발 흔적을 붙이는 방법입니다.
일반적으로 데칼은 위 예제처럼 셰이더를 통해 작동하지 않습니다.
대신에 데칼을 적용하려는 모델의 geometry를 검토하는 함수를 작성합니다.
자바스크립트의 셰이더 예제에 있는 <code class="notranslate" translate="no">inRange</code> 체크와 동일하게, 각 삼각형에 대해 그 삼각형이 데칼이 적용될 영역의 내부에 있는지 확인합니다.
영역의 내부에 있는 각 삼각형에 대해 투영된 텍스처 좌표를 사용해서 새로운 geometry로 추가합니다.
그런 다음 해당 데칼을 그려야 하는 목록에 추가합니다.</p>
<p>Geometry를 생성하는 것이 올바른 방법인데, 그렇지 않으면 2개, 3개, 4개의 데칼을 사용할 때마다 서로 다른 셰이더가 필요해져서 셰이더가 매우 복잡해지고 GPU의 텍스처 사용 한계에 도달하게 됩니다.</p>
<p>또 다른 사용 예시는 현실 세계의 <a href="https://en.wikipedia.org/wiki/Projection_mapping">투영 매핑</a>을 모사하는 겁니다.
비디오가 투사될 3D 모델을 만든 뒤 위와 같은 코드를 사용하여 비디오를 텍스처로 사용해 투사합니다.
그러면 실제 프로젝터를 들고 현장에 가 보지 않고도 영상이 모델에 딱 맞추어 투사될 수 있도록 비디오를 편집할 수 있습니다.</p>
<p>이런 종류의 투영이 유용한 다른 예제는 <a href="webgl-shadows.html">쉐도우 매핑을 이용한 그림자 계산</a>입니다.</p>
<div class="webgl_bottombar">
<h3>조건부 텍스처 참조</h3>
<p>위의 프래그먼트 셰이더에서는 항상 두 개의 텍스처를 모두 읽게 됩니다.</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  vec4 projectedTexColor &#x3D; texture(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor &#x3D; texture(u_texture, v_texcoord) * u_colorMult;

  float projectedAmount &#x3D; inRange ? 1.0 : 0.0;
  gl_FragColor &#x3D; mix(texColor, projectedTexColor, projectedAmount);
</code></pre>
<p>왜 아래와 같이 하지 않았을까요?</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  if (inRange) {
    gl_FragColor &#x3D; texture(u_projectedTexture, projectedTexcoord.xy);
  } else {
    gl_FragColor &#x3D; texture(u_texture, v_texcoord) * u_colorMult;
  }
</code></pre>
<p><a href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf">GLSL ES 3.0 명세의 Section 8.8</a>에 따르면</p>
<blockquote>
<h4>Texture Lookup Functions</h4>
<p>
Some texture functions (non-“Lod” and non-“Grad” versions) may require implicit derivatives. Implicit
derivatives are undefined within non-uniform control flow and for vertex texture fetches
</p>
</blockquote>
<p>
다시 말해 텍스처를 사용하는 경우 항상 텍스처에 접근할 수 있어야 한다는 것입니다. 
결과를 조건부로 사용할 수는 있습니다.
예를 들어 아래와 같이 작성하거나</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  vec4 projectedTexColor &#x3D; texture(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor &#x3D; texture(u_texture, v_texcoord) * u_colorMult;

  if (inRange) {
    gl_FragColor &#x3D; projectedTexColor;
  } else {
    gl_FragColor &#x3D; texColor;
  }
</code></pre>
<p>아래와 같이 작성할 수 있습니다.</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  vec4 projectedTexColor &#x3D; texture(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor &#x3D; texture(u_texture, v_texcoord) * u_colorMult;

  gl_FragColor &#x3D; inRange ? projectedTexColor : texColor;
</code></pre>
<p>
하지만 텍스처 접근 자체를 조건부로 만들 수는 없습니다.
어떤 GPU에서는 작동될 수 있지만 모든 GPU에서 작동이 보장되지는 않습니다.
</p>
<p>어쨌든 이러한 사실을 알고 있는 것은 중요합니다.</p>
<p>
<code class="notranslate" translate="no">inRange</code>를 기반으로 분기문을 만드는 대신 <code class="notranslate" translate="no">mix</code>를 사용하는 이유는 개인적인 취향 때문입니다.
<code class="notranslate" translate="no">mix</code>가 더 유연하기 때문에 저는 보통 이런 식으로 작성합니다.
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-planar-projection-mapping.html" >English</a>
    <option value="/webgl/lessons/de/webgl-planar-projection-mapping.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-planar-projection-mapping.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-planar-projection-mapping.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-planar-projection-mapping.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-getting-webgl2.html">WebGL2 사용법</a></li>
<li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">WebGL2 작동 원리</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">WebGL2 셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl2-whats-new.html">WebGL2 새로운 기능</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2.html">WebGL1에서 WebGL2로의 변경</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org과 WebGL2Fundamentals.org의 차이점</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">WebGL2 이미지 처리 심화</a></li>
        </ul>
  <li>2D 이동, 회전, 크기 변환 행렬 계산</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">WebGL2 2D 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">WebGL2 2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">WebGL2 2D 크기 변환</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">WebGL2 2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D - 카메라</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-naming.html">3D - 행렬의 이름</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명 효과(Directional Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명 효과(Point Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스팟 조명 효과(Spot Lighting)</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">더 적은 코드로 즐겁게 코딩하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체를 그리는 법</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면(Scene) 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">두개 이상의 텍스처 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지(Cross Origin Image)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처에 렌더링하기</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skybox</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">정점 인덱스 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">인스턴스 드로잉(Instanced Drawing)</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">보일러플레이트(Boilerplate)</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">Canvas 리사이징</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL2 알파(Alpha)</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL2 행렬 vs 수학에서의 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 이슈</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Canvas Clear 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스에서 키보드 입력 받기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">HTML에서 WebGL2를 배경으로 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffer</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈나 버그가 있나요? <a href="https://github.com/greggman/webgl2-fundamentals/issues">깃헙에서 이슈 만들기</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 평면 및 원근 투영 매핑';
            var disqus_title = 'WebGL2 평면 및 원근 투영 매핑';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님, <br>당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여</a>에 감사드립니다.",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-3d-lighting-directional.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGL에서 방향성 조명 효과를 구현하는 방법">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-lighting-directional_ko.jpg">

<meta property="og:title" content="WebGL2 3D - 방향성 조명 효과(Directional Lighting)">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-lighting-directional_ko.jpg">
<meta property="og:description" content="WebGL에서 방향성 조명 효과를 구현하는 방법">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 3D - 방향성 조명 효과(Directional Lighting)">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html">
<meta name="twitter:description" content="WebGL에서 방향성 조명 효과를 구현하는 방법">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-lighting-directional_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-lighting-directional_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html",
      "inLanguage":"ko",
      "name":"WebGL2 3D - 방향성 조명 효과(Directional Lighting)",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 3D - 방향성 조명 효과(Directional Lighting)</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-3d-lighting-directional.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-3d-lighting-directional.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-lighting-directional.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-lighting-directional.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-3d-lighting-directional.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-lighting-directional.html" >English</a>
    <option value="/webgl/lessons/de/webgl-3d-lighting-directional.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-3d-lighting-directional.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-lighting-directional.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-lighting-directional.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 3D - 방향성 조명 효과(Directional Lighting)</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 <a href="webgl-3d-camera.html">WebGL 3D 카메라</a>에서 이어지는 글입니다.
이전 글을 아직 읽지 않았다면 <a href="webgl-3d-camera.html">먼저 읽어 보시길 권장합니다.</a></p>
<p>조명 효과를 구현하는 방법은 매우 많습니다. 아마 가장 간단한 것은 <em>방향성 조명 효과(directional lighting)</em>일겁니다.</p>
<p>방향성 조명 효과에서는 빛이 한 방향으로부터 일정하게 들어온다고 가정합니다.
맑은 날의 태양광은 대개 방향성 조명으로 간주됩니다.
태양은 매우 멀리 있기 때문에 그 광선들이 물체의 표면에 모두 평행하게 도달한다고 생각할 수 있습니다.</p>
<p>방향성 조명 효과를 계산하는 방법은 사실 꽤 간단합니다.
빛이 진행하는 방향과 물체의 표면이 바라보는 방향을 안다면 두 방향 벡터의 <em>내적</em>을 취하면 두 방향간의 코사인 각도를 계산할 수 있습니다.</p>
<p>아래는 그 예시입니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/dot-product.html"></iframe>
  <div class="webgl_center">drag the points</div>
</div>

</p>
<p>점들을 드래그해서 두 점을 정반대 방향으로 가져다 놓으면 내적값이 -1이 되는 것을 보실 수 있을겁니다.
두 점이 동일한 위치에 있으면 내적값은 1이 됩니다.</p>
<p>그게 어쨋다는걸까요? 만일 우리가 3D 물체의 표면이 향하고 있는 방향을 알고 빛의 방향을 안다면 내적을 취해서
숫자 1이 나오게 되면 빛이 물체의 표면을 정면에서 비추고 있다는 것을 알 수 있고, -1이면 반대방향에서 비추고 있다는 것을 알 수 있습니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 500px; height: 400px;" src="/webgl/lessons/resources/directional-lighting.html"></iframe>
  <div class="webgl_center">rotate the direction</div>
</div>

</p>
<p>그리고 색상을 저 내적값에 곱하게 되면 짜잔! 조명 효과가 나타납니다.</p>
<p>문제는, 3D 물체의 표면이 어디를 바라보고 있는지를 어떻게 알 수 있는가입니다.</p>
<h2 id="-normal-">법선(Normal)에 대한 소개</h2>
<p>왜 <em>법선(normal)</em>이라고 불리는지는 모르겠지만, 적어도 3D 그래픽스 분야에서 법선이란 표면이 바라보는 방향을 나타내는 단위 벡터(unit vector)입니다.</p>
<p>아래는 정육면체와 구의 법선입니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/normals.html"></iframe>
</div>

</p>
<p>물체에서 튀어나와있는 선들이 각 정점의 법선을 표현하고 있습니다.</p>
<p>정육면체는 각 모서리에 3개의 법선들이 있다는 것에 주목하십시오.
이는 정육면체의 각 면이 바라보는 방향을 표현하기 위해서는 서로다른 3개의 법선이 필요하기 때문입니다.</p>
<p>위의 그림에서 법선은 방향에 따라 양의 x방향이면 <span style="color: red;">빨간색</span>으로,
위를 바라보고 있으면 <span style="color: green;">초록색</span> 으로, 양의 z방향이면 
<span style="color: blue;">파란색</span>으로 색상이 표현되어 있습니다. </p>
<p>그럼, <a href="webgl-3d-camera.html">이전 예제</a>에서 사용했던 우리의 <code class="notranslate" translate="no">F</code>에 법선을 추가해서 조명 효과를 줄 수 있도록 해봅시다.
<code class="notranslate" translate="no">F</code>가 각이 져있고, 각 면이 x,y,z 방향과 정렬되어 있으므로 어렵지 않습니다.
앞을 바라보고 있는 경우에는 법선이 <code class="notranslate" translate="no">0, 0, 1</code>입니다. 반대 방향을 바라보고 있으면 <code class="notranslate" translate="no">0, 0, -1</code>입니다.
왼쪽을 바라보고 있으면 법선이 <code class="notranslate" translate="no">-1, 0, 0</code>이고, 오른쪽을 바라보면 <code class="notranslate" translate="no">1, 0, 0</code>입니다.
위쪽은 <code class="notranslate" translate="no">0, 1, 0</code>, 아래쪽은 <code class="notranslate" translate="no">0, -1, 0</code>입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function setNormals(gl) {
  var normals = new Float32Array([
          // 왼쪽 기둥의 앞면
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,

          // 위쪽 가로줄의 앞면
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,

          // 중간 가로줄의 앞면
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,

          // 왼쪽 기둥의 뒷면
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,

          // 위쪽 가로줄의 뒷면
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,

          // 중간 가로줄의 뒷면
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,
          0, 0, -1,

          // 윗면
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,

          // 위쪽 가로줄의 오른쪽면
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,

          // 위쪽 가로줄의 아랫면
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,

          // 위쪽과 중간 가로줄의 사이면
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,

          // 중간 가로줄의 윗면
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,

          // 중간 가로줄의 오른쪽면
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,

          // 중간 가로줄의 아랫면.
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,

          // 아래쪽의 오른쪽면
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,

          // 아래쪽면
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,

          // 왼쪽면
          -1, 0, 0,
          -1, 0, 0,
          -1, 0, 0,
          -1, 0, 0,
          -1, 0, 0,
          -1, 0, 0,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
}
</code></pre><p>그리고 설정을 해줍시다. 하는김에 정점 색생을 없애서 조명 효과를 좀 더 잘 보이도록 해줍시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 정점 데이터들이 전달되어야 할 위치 찾기
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
-var colorLocation = gl.getAttribLocation(program, &quot;a_color&quot;);
+var normalLocation = gl.getAttribLocation(program, &quot;a_normal&quot;);

...

-// Create a buffer for colors.
-var buffer = gl.createBuffer();
-gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
-gl.enableVertexAttribArray(colorLocation);
-
-// We&#39;ll supply RGB as bytes.
-gl.vertexAttribPointer(colorLocation, 3, gl.UNSIGNED_BYTE, true, 0, 0);
-
-// Set Colors.
-setColors(gl);

// 법선을 위한 버퍼 생성
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.enableVertexAttribArray(normalLocation);
gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);

// 버퍼 설정
setNormals(gl);
</code></pre><p>이제 셰이더에서 이 값들을 사용하도록 해야 합니다.</p>
<p>먼저 정점 셰이더에서는 법선을 프래그먼트 셰이더로 단지 전달만 해 줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// attribute는 정점 셰이더의 입력 (in) 입니다.
// 버퍼로부터 데이터를 받습니다.
in vec4 a_position;
-in vec4 a_color;
+in vec3 a_normal;

// 위치를 변환할 행렬
uniform mat4 u_matrix;

-// a varying to pass the color to the fragment shader
-out vec4 v_color;

+// 프래그먼트 셰이더로 전달할 법선 varying
+out vec3 v_normal;

// 셰이더는 항상 main함수를 가집니다.
void main() {
  // position에 행렬을 곱해줍니다.
  gl_Position = u_matrix * a_position;

-  // Pass the color to the fragment shader.
-  v_color = a_color;

+  // 법선을 프래그먼트 셰이더로 넘겨줍니다.
+  v_normal = a_normal;
}
</code></pre><p>프래그먼트 셰이더에서는 빛의 방향과 법선을 내적하는 수학 계산을 할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

precision highp float;

-// the varied color passed from the vertex shader
-in vec4 v_color;

+// 정점 셰이더에서 전달된 varying.
+in vec3 v_normal;
+
+uniform vec3 u_reverseLightDirection;
+uniform vec4 u_color;

// 프래그먼트 셰이더의 출력을 선언해 주어야 합니다.
out vec4 outColor;

void main() {
-  outColor = v_color;
+  // v_normal은 varying이기 때문에 보간되고,
+  // 그로인해 단위 벡터가 아닐 수 있습니다.
+  // 정규화를 통해 다시 단위 벡터로 만들어 줍니다.
+  vec3 normal = normalize(v_normal);
+
+  // normal과 뒤집어진 빛의 방향을 내적해서 light값을 계산합니다.
+  float light = dot(normal, u_reverseLightDirection);
+
+  outColor = u_color;
+
+  // 알파를 제회한 색상값 부분을 light값과 곱해줍니다.
+  outColor.rgb *= light;
}
</code></pre><p>이제 <code class="notranslate" translate="no">u_color</code>와 <code class="notranslate" translate="no">u_reverseLightDirection</code>의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // uniform 찾기
  var matrixLocation = gl.getUniformLocation(program, &quot;u_matrix&quot;);
+  var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
+  var reverseLightDirectionLocation =
+      gl.getUniformLocation(program, &quot;u_reverseLightDirection&quot;);
</code></pre><p>그리고 값들을 설정해 주어야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // 행렬값 설정
  gl.uniformMatrix4fv(matrixLocation, false, matrix);

+  // 사용할 색상값 설정
+  gl.uniform4fv(colorLocation, [0.2, 1, 0.2, 1]); // 초록색
+
+  // 조명 방향 설정
+  gl.uniform3fv(reverseLightDirectionLocation, normalize([0.5, 0.7, 1]));
</code></pre><p><code class="notranslate" translate="no">normalize</code>는 전에도 봤듯이 입력한 값을 단위 벡터로 변환합니다.
여기서 예제로 사용한 값은 <code class="notranslate" translate="no">x = 0.5</code>인데 <code class="notranslate" translate="no">x</code>가 양의 값이라는 것은 빛이 오른쪽에서 왼쪽을 향한다는 뜻입니다.
<code class="notranslate" translate="no">y = 0.7</code>인데 <code class="notranslate" translate="no">y</code>가 양의 값이라는 것은 빛이 위쪽에서 아래쪽을 향한다는 뜻입니다.
<code class="notranslate" translate="no">z = 1</code>인데 <code class="notranslate" translate="no">z</code>가 양의 값이라는 것은 빛이 정면에서 장면(scene)쪽을 향한다는 뜻입니다.
상대적인 값을 비교해 보면 빛이 장면쪽을 향하는 경향이 크고, 오른쪽보다는 아래쪽을 더 향한다는 것을 알 수 있습니다.</p>
<p>아래는 그 결과입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-directional.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-directional.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>F를 돌려 보시면 무언가 알아차리실 수 있을겁니다. F는 돌아가는데 조명 효과는 변하지 않습니다.
F가 돌아가면 빛을 향하는 방향이 밝아지는 것이 우리가 원하는 효과입니다.</p>
<p>이를 수정하기 위해서는 물체의 방향이 변하면 법선의 방향도 변하도록 해야 합니다.
위치값에 대해 그렇게 했던 것처럼 법선에도 어떤 행렬을 곱해줄 수 있습니다.
<code class="notranslate" translate="no">월드</code> 행렬을 곱해주는 것이 가장 당연해 보입니다. 
우리는 현재 <code class="notranslate" translate="no">u_matrix</code>라 이름지은 곳에 하나의 행렬만 전달하고 있습니다.
이제 2개의 행렬을 전달하도록 수정해 봅시다.
하나는 <code class="notranslate" translate="no">u_world</code>라고 이름지은 월드 행렬이고 다른 하나는 <code class="notranslate" translate="no">u_worldViewProjection</code>로, 
지금 우리가 <code class="notranslate" translate="no">u_matrix</code>에 전달하고 있는 행렬입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// attribute는 정점 셰이더의 입력 (in) 입니다.
// 버퍼로부터 데이터를 받습니다.
in vec4 a_position;
in vec3 a_normal;

*uniform mat4 u_worldViewProjection;
+uniform mat4 u_world;

out vec3 v_normal;

void main() {
  // 위치값을 행렬과 곱해줍니다.
*  gl_Position = u_worldViewProjection * a_position;

*  // 법선의 방향을 바꾸어 프래그먼트 셰이더로 전달합니다.
*  v_normal = mat3(u_world) * a_normal;
}
</code></pre><p><code class="notranslate" translate="no">a_normal</code>에 <code class="notranslate" translate="no">mat3(u_world)</code>를 곱하는 것에 주의하십시오.
법선은 방향 벡터이기 때문에 이동(translation)은 필요 없습니다.
자세와 관련된 부분은 행렬의 위쪽 3x3 부분 뿐입니다.</p>
<p>이제 해당 uniform들을 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // uniform 찾기
-  var matrixLocation = gl.getUniformLocation(program, &quot;u_matrix&quot;);
*  var worldViewProjectionLocation =
*      gl.getUniformLocation(program, &quot;u_worldViewProjection&quot;);
+  var worldLocation = gl.getUniformLocation(program, &quot;u_world&quot;);
</code></pre><p>그리고 해당 값들을 바꾸는 부분의 코드를 수정해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*var worldMatrix = m4.yRotation(fRotationRadians);
*var worldViewProjectionMatrix = m4.multiply(viewProjectionMatrix,
                                             worldMatrix);

*// 행렬값을 전달
*gl.uniformMatrix4fv(
*    worldViewProjectionLocation, false,
*    worldViewProjectionMatrix);
*gl.uniformMatrix4fv(worldLocation, false, worldMatrix);
</code></pre><p>아래는 그 결과입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-directional-world.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-directional-world.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>F를 돌려보면 빛의 방향을 향하는 면이 밝아지는 것을 볼 수 있습니다.</p>
<p>문제가 하나 있는데, 여러분들에게 바로 보여주기는 어려워서 다이어그램을 통해 보여드리겠습니다.
현재 우리는 normal 방향을 바꾸기 위해 <code class="notranslate" translate="no">normal</code>에 <code class="notranslate" translate="no">u_world</code>를 곱하고 있습니다.
만일 월드 행렬에 크기(scale) 변환이 포함되어 있다면 어떻게 될까요?
결과 법선값이 잘못된 값이 도출됩니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 600px; height: 300px;" src="/webgl/lessons/resources/normals-scaled.html"></iframe>
  <div class="webgl_center">click to toggle normals</div>
</div>

</p>
<p>저는 원리는 이해하려고 노력하지 않았지만, 어쨋든 해결 방법은 월드 행렬의 역행렬을 구한 뒤 
전치(행과 열을 바꾸기)한 행렬을 대신 사용하는 것입니다.
그러면 올바른 결과가 도출됩니다.</p>
<p>위 다이어그램에서 <span style="color: #F0F;">보라색</span> 구는 크기가 변하지 않습니다.
왼쪽의 <span style="color: #F00;">빨간색</span> 구는 크기가 변하고, 법선에 월드 행렬이 곱해진 것입니다.
보시면 무언가 잘못된 결과를 보실 수 있습니다.
오른쪽의 <span style="color: #00F;">파란색</span> 구는 월드 행렬의 역행렬을 전치한 것을 사용하고 있습니다.</p>
<p>다이어그램을 클릭해서 다른 표현 모드의 결과를 살펴 보세요.
크기가 많이 변했을때 왼쪽(world)의 법선이 구의 표면과 직교하지 <strong>않는</strong>다는 것을 아실 수 있을겁니다.
반면 오른쪽(worldInverseTranspose)의 경우 구에 직교하는 값을 유지하고 있습니다.
마지막 표현 모드에서는 전체를 빨간색으로 그리고 있습니다.
두개의 양쪽 구의 조명 효과 결과가 어떤 행렬을 사용하냐에 따라 매우 다른 것을 보실 수 있습니다.
어떤 결과가 더 좋고 왜 더 좋냐 이야기하는 것은 까다롭지만, 다른 모드의 표현 결과를 보면 worldInverseTranspose를 사용하는 것이 맞다는 사실이 명확해 보입니다.</p>
<p>우리 예제 코드에서 이를 구현하기 위해 코드를 이렇게 수정해 봅시다.
먼저 셰이더를 수정하겠습니다. 그냥 <code class="notranslate" translate="no">u_world</code>의 값만 바꿔도 되지만,
이름을 다시 지어서 지금 무엇을 하고 있는 것인지를 헷갈리지 않게 하는 것이 좋습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// attribute는 정점 셰이더의 입력 (in) 입니다.
// 버퍼로부터 데이터를 받습니다.
in vec4 a_position;
in vec3 a_normal;

uniform mat4 u_worldViewProjection;
-uniform mat4 u_world
+uniform mat4 u_worldInverseTranspose;

// 프래그먼크에 전달한 법선과 색상 varying
out vec4 v_color;
out vec3 v_normal;

// 모든 셰이더는 main 함수를 가집니다.
void main() {
  // 위치에 행렬을 곱합니다.
  gl_Position = u_worldViewProjection * a_position;

  // 법선의 방향을 바꾸어 프래그먼트 셰이더로 전달합니다.
*  v_normal = mat3(u_worldInverseTranspose) * a_normal;
}
</code></pre><p>그리고 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">-  var worldLocation = gl.getUniformLocation(program, &quot;u_world&quot;);
+  var worldInverseTransposeLocation =
+      gl.getUniformLocation(program, &quot;u_worldInverseTranspose&quot;);
</code></pre><p>또, 값을 계산하고 전달해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var worldMatrix = m4.yRotation(fRotationRadians);
var worldViewProjectionMatrix = m4.multiply(viewProjectionMatrix, worldMatrix);
+var worldInverseMatrix = m4.inverse(worldMatrix);
+var worldInverseTransposeMatrix = m4.transpose(worldInverseMatrix);

// 행렬값을 설정
gl.uniformMatrix4fv(
    worldViewProjectionLocation, false,
    worldViewProjectionMatrix);
-gl.uniformMatrix4fv(worldLocation, false, worldMatrix);
+gl.uniformMatrix4fv(
+    worldInverseTransposeLocation, false,
+    worldInverseTransposeMatrix);
</code></pre><p>아래는 행렬의 전치를 위한 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var m4 = {
  transpose: function(m) {
    return [
      m[0], m[4], m[8], m[12],
      m[1], m[5], m[9], m[13],
      m[2], m[6], m[10], m[14],
      m[3], m[7], m[11], m[15],
    ];
  },
  ...
</code></pre><p>우리는 크기를 변환하고 있지 않으므로 효과가 미미하여 변화를 알아차리기는 어렵지만,
어쨋든 이제 준비가 되었습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-directional-worldinversetranspose.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-directional-worldinversetranspose.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>조명 효과에 관한 첫 단계가 명확히 이해되셨긴 바랍니다. 다음은 <a href="webgl-3d-lighting-point.html">점 조명 효과(point lighting)</a> 입니다.</p>
<div class="webgl_bottombar">
<h3>mat3(u_worldInverseTranspose) * a_normal의 대안</h3>
<p>위 셰이더 코드에 보면 아래와 같은 라인이 있습니다.</p>
<pre class="prettyprint">
v_normal = mat3(u_worldInverseTranspose) * a_normal;
</pre>
<p>아래와 같이 할 수도 있습니다.</p>
<pre class="prettyprint">
v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
</pre>
<p>우리가 행렬곱을 하기 전에 <code class="notranslate" translate="no">w</code>를 0으로 설정하였으므로 행렬의 이동 관련 텀과 0을 곱하여 제거한 것과 마찬가지입니다.
제 생각에는 이러한 방법이 더 일반적으로 사용되는 것 같습니다.
mat3를 사용한 방법이 더 명확해 보이기 때문에 저는 이렇게도 자주 합니다.</p>
<p>또 다른 방법은 <code class="notranslate" translate="no">u_worldInverseTranspose</code>를 <code class="notranslate" translate="no">mat3</code>로 만드는 것입니다.
하지만 이렇게 하지 않는데는 두 가지 이유가 있습니다. 첫째로는 <code class="notranslate" translate="no">u_worldInverseTranspose</code> 전체 행렬을 다른 용도로도 사용할 수 있기 때문에
<code class="notranslate" translate="no">u_worldInverseTranspose</code>를 <code class="notranslate" translate="no">mat4</code>로 넘기게 되면 그러한 다른 용도로도 활용할 수 있습니다.
또다른 이유로는 우리의 자바스크립트 행렬 함수들이 모두 4x4 행렬을 만든다는 것입니다.
3x3행렬을 위한 기능들을 새로 만들거나 4x4행렬을 3x3행렬로 변환하는 기능을 구현하는 것은 특별한 이유가 있지 않다면 할 필요가 없습니다.</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-lighting-directional.html" >English</a>
    <option value="/webgl/lessons/de/webgl-3d-lighting-directional.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-3d-lighting-directional.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-lighting-directional.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-lighting-directional.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-getting-webgl2.html">WebGL2 사용법</a></li>
<li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">WebGL2 작동 원리</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">WebGL2 셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl2-whats-new.html">WebGL2 새로운 기능</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2.html">WebGL1에서 WebGL2로의 변경</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org과 WebGL2Fundamentals.org의 차이점</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">WebGL2 이미지 처리 심화</a></li>
        </ul>
  <li>2D 이동, 회전, 크기 변환 행렬 계산</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">WebGL2 2D 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">WebGL2 2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">WebGL2 2D 크기 변환</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">WebGL2 2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D - 카메라</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-naming.html">3D - 행렬의 이름</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명 효과(Directional Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명 효과(Point Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스팟 조명 효과(Spot Lighting)</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">더 적은 코드로 즐겁게 코딩하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체를 그리는 법</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면(Scene) 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">두개 이상의 텍스처 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지(Cross Origin Image)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처에 렌더링하기</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skybox</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">정점 인덱스 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">인스턴스 드로잉(Instanced Drawing)</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">보일러플레이트(Boilerplate)</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">Canvas 리사이징</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL2 알파(Alpha)</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL2 행렬 vs 수학에서의 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 이슈</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Canvas Clear 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스에서 키보드 입력 받기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">HTML에서 WebGL2를 배경으로 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffer</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈나 버그가 있나요? <a href="https://github.com/greggman/webgl2-fundamentals/issues">깃헙에서 이슈 만들기</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 3D - 방향성 조명 효과(Directional Lighting)';
            var disqus_title = 'WebGL2 3D - 방향성 조명 효과(Directional Lighting)';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님, <br>당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여</a>에 감사드립니다.",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




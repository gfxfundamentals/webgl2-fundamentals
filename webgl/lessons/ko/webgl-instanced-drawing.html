<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-instanced-drawing.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="동일한 물체의 여러 인스턴스를 그리는 방법">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg">

<meta property="og:title" content="WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg">
<meta property="og:description" content="동일한 물체의 여러 인스턴스를 그리는 방법">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">
<meta name="twitter:description" content="동일한 물체의 여러 인스턴스를 그리는 방법">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html",
      "inLanguage":"ko",
      "name":"WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/de/webgl-instanced-drawing.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL에는 <em>인스턴스 드로잉(instanced drawing)</em> 기능이 있습니다.
이는 동일한 물체를 여러 개 그릴 때, 각 물체를 개별적으로 그리는 것보다 더 빠르게 그리는 방법입니다.</p>
<p>먼저 동일한 물체의 여러 인스턴스를 그리는 예제를 만들어 봅시다.</p>
<p><a href="webgl-3d-orthographic.html">직교 투영에 관한 글</a>의 끝 부분에 작성한 예제와 <em>비슷한</em>코드에서 시작할 겁니다.
먼저 아래와 같은 두 개의 셰이더가 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
uniform mat4 matrix;

out vec4 v_color;

void main() {
  // position과 행렬을 곱합니다.
  gl_Position = matrix * a_position;
}
`;

const fragmentShaderSource = `#version 300 es
precision highp float;

uniform vec4 color;

out vec4 outColor;

void main() {
  outColor = color;
}
`;
</code></pre>
<p>정점 셰이더에서는 <a href="webgl-3d-orthographic.html">이 글</a>에서 언급한 것처럼 각 정점에 하나의 행렬을 곱하는 꽤 유연한 코드립니다.
프래그먼트 셰이더는 우리가 uniform을 통해 입력한 색상값을 그대로 사용합니다.</p>
<p>그리기 위해서 우리는 셰이더를 컴파일하고, 링크를 통해 프로그램을 만들고 attribute와 uniform의 location을 찾습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl,
    [vertexShaderSource, fragmentShaderSource]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
</code></pre>
<p>그리고 attribute의 상태를 저장하는 vertex array object를 만듭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// vertex array object (attribute 상태)를 생성하고,
const vao = gl.createVertexArray();

// 현재 사용 상태로 설정합니다.
gl.bindVertexArray(vao);
</code></pre>
<p>그리고 position 데이터를 버퍼를 통해 전달합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -0.1,  0.4,
    -0.1, -0.4,
     0.1, -0.4,
    -0.1,  0.4,
     0.1, -0.4,
     0.1,  0.4,
    -0.4, -0.1,
     0.4, -0.1,
    -0.4,  0.1,
    -0.4,  0.1,
     0.4, -0.1,
     0.4,  0.1,
  ]), gl.STATIC_DRAW);
const numVertices = 12;

// position attribute 설정
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(
    positionLoc,  // location
    2,            // 크기 (iteration마다 버퍼에서 가져올 값들의 개수)
    gl.FLOAT,     // 버퍼 내 데이터의 타입
    false,        // 정규화 여부
    0,            // stride (0인경우 위에서 명시한 크기와 타입으로 계산)
    0,            // offset
);
</code></pre>
<p>5개의 인스턴스를 그려봅시다. 각 인스턴스를 그리기 위해 5개의 행렬과 5개의 색상을 정의합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const numInstances = 5;
const matrices = [
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
];

const colors = [
  [ 1, 0, 0, 1, ],  // red
  [ 0, 1, 0, 1, ],  // green
  [ 0, 0, 1, 1, ],  // blue
  [ 1, 0, 1, 1, ],  // magenta
  [ 0, 1, 1, 1, ],  // cyan
];
</code></pre>
<p>그리기 위해 먼저 셰이더 프로그램을 사용 상태로 설정하고 attribute를 설정합니다.
그리고 5개 인스턴스에 대해 반복문을 돌면서 각각에 대해 행렬을 계산하고
그 행렬과 색상 uniform을 설정한 뒤 그리기를 수행합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001; // seconds

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // Tell WebGL how to convert from clip space to pixels
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(program);

  // setup all attributes
  gl.bindVertexArray(vao);

  matrices.forEach((mat, ndx) =&gt; {
    m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
    m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

    const color = colors[ndx];

    gl.uniform4fv(colorLoc, color);
    gl.uniformMatrix4fv(matrixLoc, false, mat);

    gl.drawArrays(
        gl.TRIANGLES,
        0,             // offset
        numVertices,   // num vertices per instance
    );
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>행렬 수학 라이브러리에서 추가적인 대상(destination) 행렬을 함수의 마지막 인자로 받는 부분에 주의하십시오.
대부분의 글에서는 이 기능을 사용하지 않고 라이브러리가 새 행렬을 할당하도록 했었습니다.
하지만 이번에는 생성한 행렬에 계속 결과가 저장되도록 하고 있습니다.</p>
<p>위 코드는 잘 동작해서 서로 다른 색상을 갖는 다섯 개의 더하기 기호가 돌아가는 장면을 볼 수 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-not-instanced.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-not-instanced.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>이렇게 그리기 위해 <code class="notranslate" translate="no">gl.uniform4v</code>, <code class="notranslate" translate="no">gl.uniformMatrix4fv</code>, <code class="notranslate" translate="no">gl.drawArrays</code>가 각각 5번씩 호출되어야 했으니 총 15번의 WebGL 호출이 필요했습니다.
만일 <a href="webgl-3d-lighting-spot.html">스팟 조명 효과 글</a>에서처럼 복잡한 셰이더였다면 각 물체에 대해 최소 7번의 호출이 필요했을 겁니다.
6번의 <code class="notranslate" translate="no">gl.uniformXXX</code> 호출과 한 번의 <code class="notranslate" translate="no">gl.drawArrays</code> 호출이 필요합니다.
만일 물체가 400개였다면 2800번의 WebGL 호출이 필요할겁니다.</p>
<p>인스턴싱은 이러한 호출을 줄이는 방법입니다.
이 기능은 WebGL에 같은 물체가 몇 번(인스턴스의 개수) 그려질 것인지 알려줌으로써 동작합니다.
정점 셰이더가 호출되어 대상으로 하는 attribute마다 지정된 버퍼로부터 <em>다음 값</em>을 얻어오는 것이 기본값이지만,
N개의 인스턴스마다(일반적으로 N=1) 값을 가져오도록 할 수 있습니다.</p>
<p>예를 들어 <code class="notranslate" translate="no">matrix</code>와 <code class="notranslate" translate="no">color</code>를 uniform을 통해 제공하는 대신 이들을 <code class="notranslate" translate="no">attribute</code>를 사용해 제공합니다.
각 인스턴스의 행렬과 색상을 버퍼에 입력하고 해당 버퍼로부터 값을 가져오도록 attribute를 설정한 뒤에 
WebGL에게 각 인스턴스마다 한번씩만 다음 값을 얻어오도록 알려주는 방식입니다.</p>
<p>한번 해보죠!</p>
<p>먼저 <code class="notranslate" translate="no">matrix</code>와 <code class="notranslate" translate="no">color</code>를 uniform 대신 attribute를 사용하도록 셰이더를 수정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
-uniform mat4 matrix;
+in vec4 color;
+in mat4 matrix;
+
+out vec4 v_color;

void main() {
  // position과 행렬을 곱합니다.
  gl_Position = matrix * a_position;

+  // 프래그먼트 셰이더로 정점 색상을 전달합니다.
+  v_color = color;
}
`;
</code></pre>
<p>그리고</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fragmentShaderSource = `#version 300 es
precision highp float;

-uniform vec4 color;
+// 정점 셰이더에서 전달된 값.
+in vec4 v_color;

void main() {
-  gl_FragColor = color;
+  gl_FragColor = v_color;
}
`;
</code></pre>
<p>attribute는 정점 셰이더에서만 사용이 가능하므로 attribute에서 얻어오는 색상은
정점 셰이더에서 프래그먼트 셰이더로 varying을 사용해 전달됩니다.</p>
<p>다음으로 attribute들의 location을 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl,
    [vertexShaderSource, fragmentShaderSource]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
-const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
-const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
+const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
+const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
</code></pre>
<p>이제 attribute에 전달될 행렬을 저장할 버퍼가 필요합니다.
버퍼는 한 <em>덩어리(chunk)</em>로 업로드하는 것이 좋으므로 모든 행렬을 하나의 <code class="notranslate" translate="no">Float32Array</code>에 집어넣습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 각 인스턴스마다 하나의 행렬을 설정
const numInstances = 5;
+// 각 행렬마다 하나의 뷰(view)를 갖는 타입이 명시된 배열 생성
+const matrixData = new Float32Array(numInstances * 16);
</code></pre>
<p>이제 각 행렬마다 하나의 뷰를 차지하는 <code class="notranslate" translate="no">Float32Array</code>를 만듭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const matrices = [
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-];
const matrices = [];
for (let i = 0; i &lt; numInstances; ++i) {
  const byteOffsetToMatrix = i * 16 * 4;
  const numFloatsForView = 16;
  matrices.push(new Float32Array(
      matrixData.buffer,
      byteOffsetToMatrix,
      numFloatsForView));
}
</code></pre>
<p>이렇게 하면 전체 행렬에 대한 데이터를 참조할 때는 <code class="notranslate" translate="no">matrixData</code>를 사용하고 
개별 행렬 데이터를 참조할 때는 <code class="notranslate" translate="no">matrices[ndx]</code>를 사용합니다.</p>
<p>이 데이터에 대한 버퍼를 GPU에 만들어야 합니다.
지금은 버퍼를 할당만 할 것이기 때문에 데이터를 집어넣지는 않습니다.
따라서 <code class="notranslate" translate="no">gl.bufferData</code>의 두 번째 매개변수는 버퍼의 할당에 필요한 크기만 입력해줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const matrixBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
// 버퍼의 할당만을 수행
gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);
</code></pre>
<p>마지막 매개변수로 <code class="notranslate" translate="no">gl.DYNAMIC_DRAW</code>를 사용한 것에 주의하십시오.
이는 WebGL에게 이 데이터를 자주 변경할 것임을 알려주는 <em>힌트</em>입니다.</p>
<p>이제 행렬을 위한 attribute를 설정해야 합니다.
행렬 attribute는 <code class="notranslate" translate="no">mat4</code>입니다. <code class="notranslate" translate="no">mat4</code>는 4개의 연속된 attribute 슬롯을 사용합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const bytesPerMatrix = 4 * 16;
for (let i = 0; i &lt; 4; ++i) {
  const loc = matrixLoc + i;
  gl.enableVertexAttribArray(loc);
  // stride와 offset값에 주목하세요.
  const offset = i * 16;  // 각 열마다 네 개의 float, float마다 4바이트
  gl.vertexAttribPointer(
      loc,              // location
      4,                // 크기 (각 iteration마다 버퍼에서 가져올 값의 개수)
      gl.FLOAT,         // 버퍼의 데이터 타입
      false,            // 정규화 여부
      bytesPerMatrix,   // stride, 다음 값들을 얻어오기 위해 건너뛸 바이트 개수
      offset,           // offset
  );
  // 아래 라인은 각 인스턴스마다 attribute가 바뀐다는 것을 명시합니다.
  gl.vertexAttribDivisor(loc, 1);
}
</code></pre>
<p>인스턴스 드로잉과 관련해서 가장 중요한 포인트는 <code class="notranslate" translate="no">gl.vertexAttribDivisor</code> 호출입니다.
이는 현재 attribute가 각 인스턴스마다(역주: 인스턴스가 바뀔 때 마다) 다음 값을 얻어오도록 설정합니다.
그 말은 <code class="notranslate" translate="no">matrix</code> attribute가 첫 번째 인스턴스의 정점에 대해서는 첫 번째 행렬만을 사용한다는 뜻입니다.
두 번째 행렬은 두 번째 인스턴스에 대해서 사용되고 이후 마찬가지입니다.</p>
<p>다음으로 색상도 버퍼에 입력해야 합니다.
이 데이터는 적어도 이 예제에서는 변하지 않으므로 바로 데이터를 업로드합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const colors = [
-  [ 1, 0, 0, 1, ],  // red
-  [ 0, 1, 0, 1, ],  // green
-  [ 0, 0, 1, 1, ],  // blue
-  [ 1, 0, 1, 1, ],  // magenta
-  [ 0, 1, 1, 1, ],  // cyan
-];
+// setup colors, one per instance
+const colorBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+gl.bufferData(gl.ARRAY_BUFFER,
+    new Float32Array([
+        1, 0, 0, 1,  // red
+        0, 1, 0, 1,  // green
+        0, 0, 1, 1,  // blue
+        1, 0, 1, 1,  // magenta
+        0, 1, 1, 1,  // cyan
+      ]),
+    gl.STATIC_DRAW);
</code></pre>
<p>색상 attribute도 마찬가지로 설정해 줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 색상에 대한 attribute 설정
gl.enableVertexAttribArray(colorLoc);
gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
// 아래 라인은 각 인스턴스마다 attribute가 바뀐다는 것을 명시합니다.
gl.vertexAttribDivisor(colorLoc, 1);
</code></pre>
<p>그리는 시점에서는 각 인스턴스마다 반복문을 돌면서 행렬과 색상 uniform을 설정하고 드로우콜을 하는 대신,
먼저 각 인스턴스에 대한 행렬 계산을 수행합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 모든 행렬을 업데이트
matrices.forEach((mat, ndx) =&gt; {
  m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
  m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

-  const color = colors[ndx];
-
-  gl.uniform4fv(colorLoc, color);
-  gl.uniformMatrix4fv(matrixLoc, false, mat);
-
-  gl.drawArrays(
-      gl.TRIANGLES,
-      0,             // offset
-      numVertices,   // num vertices per instance
-  );
});
</code></pre>
<p>우리의 행렬 라이브러리가 추가적으로 대상 행렬을 인자로 받고 
행렬들이 하나의 큰 <code class="notranslate" translate="no">Float32Array</code>의 일부 뷰이므로 계산이 끝나면 모든 행렬 데이터는 바로 GPU로 업로드하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 새로운 행렬 데이터를 업로드
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);
</code></pre>
<p>이제 한 번의 드로우콜로 모든 인스턴스를 그릴 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.drawArraysInstanced(
  gl.TRIANGLES,
  0,             // offset
  numVertices,   // 각 인스턴스의 정점 개수
  numInstances,  // 인스턴스의 개수
);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>위 예제에서 각 형상마다 세 번의 WebGL 호출 * 5개의 형상이므로 총 15번의 호출이 필요했습니다.
지금은 5개 형상에 대해 행렬의 업로드를 위해 한번, 그리기를 위해 한번으로 두 번의 호출이면 충분합니다.</p>
<p>따로 언급할 필요가 없을지도 모르겠지만 저는 너무 많이 겪은 것이라 저에게만 당연한 것일수도 있겠네요.
위 코드는 캔버스의 종횡비를 고려하고 있지 않습니다.
위 코드는 <a href="webgl-3d-orthographic.html">투영 행렬</a>이나 <a href="webgl-3d-camera.html">뷰 행렬</a>이 없습니다.
단순히 인스턴스 드로잉을 보여드리기 위해 만든 예제입니다.
투영 행렬과 뷰 행렬이 필요하다면 자바스크립트에서 추가적인 계산을 하면 됩니다.
그 말은 자바스크립트쪽에서 작업이 더 필요하다는 것입니다.
좀더 명확하게 설명하기위해 정점 셰이더에 uniform을 추가해 보겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec4 color;
in mat4 matrix;
+uniform mat4 projection;
+uniform mat4 view;

out vec4 v_color;

void main() {
  // position과 행렬을 곱합니다.
-  gl_Position = matrix * a_position;
+  gl_Position = projection * view * matrix * a_position;

  // 정점 색상을 프래그먼트 셰이더에 전달합니다.
  v_color = color;
}
`;
</code></pre>
<p>location을 초기화 시점에 찾습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
+const projectionLoc = gl.getUniformLocation(program, &#39;projection&#39;);
+const viewLoc = gl.getUniformLocation(program, &#39;view&#39;);
</code></pre>
<p>그리고 렌더링 시점에 적절하게 설정해 줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

+// set the view and projection matrices since
+// they are shared by all instances
+const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+gl.uniformMatrix4fv(projectionLoc, false,
+    m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
+gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-projection-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-projection-view.html" target="_blank">새 창으로 열기</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/de/webgl-instanced-drawing.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-getting-webgl2.html">WebGL2 사용법</a></li>
<li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">WebGL2 작동 원리</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">WebGL2 셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl2-whats-new.html">WebGL2 새로운 기능</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2.html">WebGL1에서 WebGL2로의 변경</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org과 WebGL2Fundamentals.org의 차이점</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">WebGL2 이미지 처리 심화</a></li>
        </ul>
  <li>2D 이동, 회전, 크기 변환 행렬 계산</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">WebGL2 2D 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">WebGL2 2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">WebGL2 2D 크기 변환</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">WebGL2 2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D - 카메라</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-naming.html">3D - 행렬의 이름</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명 효과(Directional Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명 효과(Point Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스팟 조명 효과(Spot Lighting)</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">더 적은 코드로 즐겁게 코딩하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체를 그리는 법</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면(Scene) 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">두개 이상의 텍스처 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지(Cross Origin Image)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처에 렌더링하기</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skybox</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">정점 인덱스 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">인스턴스 드로잉(Instanced Drawing)</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">보일러플레이트(Boilerplate)</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">Canvas 리사이징</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL2 알파(Alpha)</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL2 행렬 vs 수학에서의 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 이슈</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Canvas Clear 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스에서 키보드 입력 받기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">HTML에서 WebGL2를 배경으로 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffer</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈나 버그가 있나요? <a href="https://github.com/greggman/webgl2-fundamentals/issues">깃헙에서 이슈 만들기</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)';
            var disqus_title = 'WebGL2 최적화 - 인스턴스 드로잉(Instanced Drawing)';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님, <br>당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여</a>에 감사드립니다.",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




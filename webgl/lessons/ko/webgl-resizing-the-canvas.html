<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-resizing-the-canvas.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGL canvas를 리사이징 하는 방법, 그리고 관련된 이슈들">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_ko.jpg">

<meta property="og:title" content="WebGL2 Canvas 리사이징.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_ko.jpg">
<meta property="og:description" content="WebGL canvas를 리사이징 하는 방법, 그리고 관련된 이슈들">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Canvas 리사이징.">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html">
<meta name="twitter:description" content="WebGL canvas를 리사이징 하는 방법, 그리고 관련된 이슈들">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html",
      "inLanguage":"ko",
      "name":"WebGL2 Canvas 리사이징.",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Canvas 리사이징.</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-resizing-the-canvas.html" >English</a>
    <option value="/webgl/lessons/de/webgl-resizing-the-canvas.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-resizing-the-canvas.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-resizing-the-canvas.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-resizing-the-canvas.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Canvas 리사이징.</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>캔버스(canvas)의 사이즈를 바꿀때 알아야 할 것들이 있습니다.</p>
<p>모든 캔버스는 2개의 크기를 가집니다. drawingbuffer의 크기는 캔버스 안에 얼마나 많은 픽셀이 있는지를 의미합니다.
두 번째 크기는 캔버스의 디스플레이(화면에 표시)되는 크기입니다. CSS가 화면에 표시되는 크기를 결정합니다.</p>
<p>캔버스의 drawingbuffer 크기를 정하는 방법이 두 가지 있습니다. 하나는 HTML을 사용하는 것이고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>다른 하나는 자바스크립트를 사용하는 것입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>자바스크립트에서는,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const canvas = document.querySelector(&quot;#c&quot;);
canvas.width = 400;
canvas.height = 300;
</code></pre>
<p>캔버스의 화면에 표시되는 크기를 설정할 때는, 영향을 미치는 CSS가 없다면 화면에 표시되는 크기가 drawingbuffer와 동일한 크기가 됩니다.
따라서 위 두 가지 예시의 경우에는 drawingbuffer의 크기가 400x300이므로 화면에 표시되는 크기도 400x300이 됩니다.
아래는 drawingbuffer가 10x15 픽셀이고 디스플레이 크기는 400x300인 경우의 캔버스 예시입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot; width=&quot;10&quot; height=&quot;15&quot; style=&quot;width: 400px; height: 300px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>또는 아래와 같은 예시도 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;style&gt;
#c {
  width: 400px;
  height: 300px;
}
&lt;/style&gt;
&lt;canvas id=&quot;c&quot; width=&quot;10&quot; height=&quot;15&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>1픽셀 너비의 회전하는 선을 캔버스에 그리게 되면 아래와 같은 화면이 보일겁니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-10x15-canvas-400x300-css.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-10x15-canvas-400x300-css.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>왜 이렇게 흐린걸까요? 이는 브라우저가 10x15 픽셀 크기 캔버스를 400x300 크기로 늘렸기 때문입니다.
그리고 보통은 그렇게 크기를 늘릴 때 필터를 적용하게 됩니다.</p>
<p>그러면 예를 들어, 캔버스가 윈도우 전체를 커버하길 윈하면 어떻게 해야 할까요?
첫 번째로 할 수 있는것은 CSS를 사용해 캔버스가 윈도우 전체 영역이 되도록 늘리는 것입니다. 예를 들어,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
      /*  */
      html, body {
        height: 100%;
        margin: 0;
      }
      /* make the canvas fill its container */
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>이제는 drawingbuffer의 크기를 브라우저가 늘려놓은 캔버스의 크기와 일치시키기만 하면 됩니다.
불행하게도 이는 다루기 복잡한 문제입니다. 다른 방법으로 넘어가서 알아보도록 하겠습니다.</p>
<h2 id="-clientwidth-clientheight-"><code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">clientHeight</code> 사용하기</h2>
<p>이것이 가장 쉬운 방법입니다.
<code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">clientHeight</code>는 HTML의 모든 요소(element)가 가진 속성으로, CSS 픽셀 단위로 요소의 크기를 알려줍니다.</p>
<blockquote>
<p>주의: client 사각형은 CSS 패딩을 포함하므로 <code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">clientHeight</code>를 사용할 때는
캔버스 요소에 패딩을 사용하지 않는 것이 좋습니다.</p>
</blockquote>
<p>자바스크립트를 사용하여 요소가 얼만한 크기로 화면에 보여지고 있는지를 확인할 수 있고,
drawingbuffer의 크기를 그 값에 맞춰주면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
  // 브라우저가 캔버스를 표시하고 있는 크기를 CSS 픽셀 단위로 얻어옵니다.
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;

  // 캔버스와 크기가 다른지 확인합니다.
  const needResize = canvas.width  !== displayWidth ||
                     canvas.height !== displayHeight;

  if (needResize) {
    // 캔버스를 동일한 크기가 되도록 합니다.
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>위 함수를 렌더링을 수행하기 직전에 호출해서 화면에 그려기지 이전에 캔버스의 크기가 항상 우리가 원하는 크기가 되도록 합시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene() {
   resizeCanvasToDisplaySize(gl.canvas);

   ...
</code></pre>
<p>결과는 이렇게 됩니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-canvas.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-canvas.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>어, 뭔가 이상하죠? 선이 왜 화면 전체에 걸쳐있지 않은걸까요?</p>
<p>이유는 캔버스의 사이즈를 수정하기 전에 <code class="notranslate" translate="no">gl.viewport</code>를 호출하여 뷰포트를 설정해야 하기 때문입니다.
<code class="notranslate" translate="no">gl.viewport</code>는 WebGL에게 클립 공간(-1에서 +1)에서 픽셀로 변환하는 법과 그러한 변환히 캔버스의 어떤 부분에서 이루어져야 하는지 알려줍니다.
처음 WebGL 컨텍스트를 생성할 때, WebGL은 뷰포트를 캔버스의 크기와 동일하도록 설정합니다.
하지만 그 이후에는 여러분이 설정해 주어야 합니다. 만일 캔버스의 크기를 바꾸었다면 WebGL에게 새로운 뷰포트 설정을 알려주어야 합니다.</p>
<p>이를 처리할 수 있도록 코드를 수정해 봅시다. WebGL 컨텍스트가 캔버스에 대한 참조를 가지고 있으므로 리사이즈시에 그것을 넘겨줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function drawScene() {
   resizeCanvasToDisplaySize(gl.canvas);

+   gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
   ...
</code></pre><p>이제는 잘 동작합니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-canvas-viewport.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-canvas-viewport.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>별도의 윈도우에서 예제를 열고, 윈도우의 크기를 바꾸어 보시면 항상 윈도우 전체를 채우는 것을 보실 수 있을겁니다.</p>
<p><em>왜 WebGL에서 캔버스의 크기를 바꿀때 자동으로 뷰포트를 설정해 주지 않는거죠?</em>라고 물어보시는 소리가 들리네요.
그 이유는 WebGL은 어떻게 또는 어떠한 이유로 당신이 뷰포트를 사용하는지 모르기 때문입니다.
당신이 <a href="webgl-render-to-texture.html">프레임 버퍼에 렌더링</a>하는 중일수도 있고, 무언가 다른 뷰포트 크기를 필요로 하는 작업을 하고 있을수도 있습니다.
WebGL에 당신의 의도를 파악하는 능력은 없으므로 자동으로 뷰포트를 설정해 줄 수 없는 것입니다.</p>
<hr>
<h2 id="-devicepixelratio-zoom-"><code class="notranslate" translate="no">devicePixelRatio</code>와 Zoom 다루기</h2>
<p>왜 이걸로 끝이 아닐까요? 이제는 문제가 복잡해 지는 상황을 알아봅시다.</p>
<p>먼저 아셔야 할것은 브라우저에서 말하는 대부분의 크기는 CSS 픽셀 단위라는 것입니다.
이렇게 하는 이유는 크기를 장치에 독립적으로 표현하기 위해서 입니다.
이 글의 위쪽 예제에서 우리는 캔버스의 디스플레이 크기를 400x300 CSS 픽셀로 만드려고 했습니다.
사용자가 HD-DPI 디스플레이를 사용하는지, 아니면 확대(zoom in) 또는 축소(zoom out)했는지, 
아니면 OS의 확대 수준을 설정했는지에 따라 실제로 모니터에 표시되는 픽셀의 숫자는 달라질 수 있습니다.</p>
<p><code class="notranslate" translate="no">window.devicePixelRatio</code>가 보통 모니터의 실제 픽셀 대비 CSS 픽셀의 비율을 알려줍니다.
예를 들어 여러분 브라우저의 현재 세팅은 아래와 같습니다.</p>
<blockquote>
<div>devicePixelRatio = <span data-diagram="dpr"></span></div>

</blockquote>
<p>데스크탑이나 노트북을 사용 중이시라면 <kbd>ctrl</kbd>+<kbd>+</kbd> 와 <kbd>ctrl</kbd>+<kbd>-</kbd> 
을 눌러 확대 또는 축소를 해 보세요.(<kbd>⌘</kbd>+<kbd>+</kbd> and <kbd>⌘</kbd>+<kbd>-</kbd> on Mac).
숫자가 바뀌는 것을 보실 수 있을겁니다.</p>
<p>따라서 캔버스의 픽셀 숫자가 실제 디스플레이 숫자와 동일하기를 원한다면 아래처럼 <code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">clientHeight</code>에
 <code class="notranslate" translate="no">devicePixelRatio</code>를 곱하는 것이 당연한 해결책으로 보입니다:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
  // 브라우저가 캔버스를 표시하고 있는 크기를 CSS 픽셀 단위로 얻어옵니다.
-  const displayWidth  = canvas.clientWidth;
-  const displayHeight = canvas.clientHeight;
+  const dpr = window.devicePixelRatio;
+  const displayWidth  = Math.round(canvas.clientWidth * dpr);
+  const displayHeight = Math.round(canvas.clientHeight * dpr);

  // 캔버스와 크기가 다른지 확인합니다.
  const needResize = canvas.width  != displayWidth || 
                     canvas.height != displayHeight;

  if (needResize) {
    // 캔버스를 동일한 크기가 되도록 합니다.
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>정수값을 얻기 위해 <code class="notranslate" translate="no">Math.round</code> (또는 <code class="notranslate" translate="no">Math.ceil</code>, 또는 <code class="notranslate" translate="no">Math.floor</code> 또는 <code class="notranslate" translate="no">| 0</code>)를 호출해야 합니다.
왜냐하면 <code class="notranslate" translate="no">canvas.width</code>와 <code class="notranslate" translate="no">canvas.height</code>는 항상 정수값이기 때문입니다.
그래서 <code class="notranslate" translate="no">devicePixelRatio</code>가 정수가 아니라면 대개는 비교가 실패합니다. 특히 확대/축소의 경우 대개 그렇습니다.</p>
<blockquote>
<p>주의: <code class="notranslate" translate="no">Math.floor</code> 또는 <code class="notranslate" translate="no">Math.ceil</code> 또는 <code class="notranslate" translate="no">Math.round</code> 중 어떤 것을 사용할지는 HTML 표준에 정의되어 있지 않습니다.
브라우저 구현에 의존적입니다(=브라우저마다 다를 수 있습니다). 🙄</p>
</blockquote>
<p>어떤 경우에든, 위 코드는 제대로 동작하지 <strong>않습니다</strong>. 
또 다른 문제는 <code class="notranslate" translate="no">devicePixelRatio</code>가 1.0이 아닐 때, 캔버스가 채워야 하는 CSS 영역은 정수값이 아니지만 
<code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">clientHeight</code>는 정수로 정의된다는 것입니다.
예를 들어 윈도우가 실제로는 장치에서 999 픽셀 너비이고 devicePixelRatio = 2.0인 상태에서 100% 크기의 캔버스를 사용하려고 한다고 해 봅시다. 
CSS 크기 * 2.0이 999가 되는 정수는 없습니다.</p>
<p>다른 해결 방법은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect()</code></a>를 사용하는 것입니다.
이 함수는 <code class="notranslate" translate="no">width</code>와 <code class="notranslate" translate="no">height</code>를 가진 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMRect"><code class="notranslate" translate="no">DOMRect</code></a> 를 반환합니다.
<code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">clientHeight</code>로 표현되는 클라이언트 사각형이지만 정수형을 요구하지는 않습니다.</p>
<p>아래는 컨테이너로부터 <code class="notranslate" translate="no">width: 100%</code>로 설정된 보라색 <code class="notranslate" translate="no">&lt;canvas&gt;</code>입니다.
축소를 몇 번 해서 75%나 60% 정도 되면 <code class="notranslate" translate="no">clientWidth</code>와 <code class="notranslate" translate="no">getBoundingClientRect().width</code>가 달라지는 것을 보실 수 있을겁니다.</p>
<blockquote>
<div data-diagram="getBoundingClientRect"></div>

</blockquote>
<p>제 장치에서는 아래와 같은 결과가 나왔습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">Windows 10, zoom level 75%, Chrome
clientWidth: 700
getBoundingClientRect().width = 700.0000610351562

MacOS, zoom level 90%, Chrome
clientWidth: 700
getBoundingClientRect().width = 700.0000610351562

MacOS, zoom level -1, Safari (safari does not show the zoom level)
clientWidth: 700
getBoundingClientRect().width = 699.9999389648438

Firefox, both Windows and MacOS all zoom levels
clientWidth: 700
getBoundingClientRect().width = 700
</code></pre><p>주의: 위와 같은 특정한 경우에 파이어폭스는 700이라는 결과가 나왔지만 여러 다른 경우를 테스트 해 본 결과 
<code class="notranslate" translate="no">getBoundingClientRect</code>가 정수가 아닌 값이 나왔습니다. 
예를 들어 윈도우를 좁게 만들어 100% 캔버스가 700보다 작게 만들면 파이어폭스에서도 정수가 아닌 값이 나오게 됩니다.</p>
<p>그러니, <code class="notranslate" translate="no">getBoundingClientRect</code>를 사용해 봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
  // 브라우저가 캔버스를 표시하고 있는 크기를 CSS 픽셀 단위로 얻어옵니다.
  const dpr = window.devicePixelRatio;
-  const displayWidth  = Math.round(canvas.clientWidth * dpr);
-  const displayHeight = Math.round(canvas.clientHeight * dpr);
+  const {width, height} = canvas.getBoundingClientRect();
+  const displayWidth  = Math.round(width * dpr);
+  const displayHeight = Math.round(height * dpr);

  // 캔버스와 크기가 다른지 확인합니다.
  const needResize = canvas.width  != displayWidth || 
                     canvas.height != displayHeight;

  if (needResize) {
    // 캔버스를 동일한 크기가 되도록 합니다.
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>이제 다된걸까요? 안타깝게도 아닙니다. 알고보니 <code class="notranslate" translate="no">canvas.getBoundingClientRect()</code>가 언제나 올바른 값을 반환하지는 않습니다.
원인은 복잡하지만 이는 브라우저가 요소들을 그리는 방식과 관련되어 있습니다.
어떤 부분은 HTML 수준에서 결정되고 어떤 부분은 나중에 &quot;컴포지터(compositor)&quot; 수준(실제로 그려지는 부분)에서 결정됩니다.
<code class="notranslate" translate="no">getBoundingClientRect()</code>는 HTML 수준이고 몇가지 다른 일들이 그 뒤에 발생해서 실제로 캔버스가 그려지는 크기에 영향을 줄 수 있습니다.</p>
<p>제 생각에는 예를들어 HTML부분은 추상적으로, 컴포지터는 구체적으로 동작하는 것 같습니다.
예를 들어 장치에서 999픽셀 너비인 윈도우가 있고 devicePixelRatio가 2.0인 상황이라고 합시다.
여러분이 두 개의 <code class="notranslate" translate="no">width: 50%</code>인 요소를 나란히 만들었다고 하면, HTML은 각각이 장치에서 499.5 픽셀이라고 계산합니다.
하지만 컴포지터에서 실제로 그릴 때에는 499.5 픽셀을 그릴 수 없으므로 하나는 499, 다른 하나는 500 픽셀이 됩니다.
어떤 것이 더 크고 어떤 것이 더 작은지는 어떠한 스펙에서도 정의되어 있지 않습니다.</p>
<p>브라우저의 벤더들이 찾은 해결책은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code> API</a>를 사용해서,
실제 사용되는 크기를 <code class="notranslate" translate="no">devicePixelContextBoxSize</code> 속성을 통해 제공하는 것이었습니다.
이것은 실제 사용된 장치 픽셀을 반환합니다. <code class="notranslate" translate="no">ClientBox</code>가 아닌 <code class="notranslate" translate="no">ContentBox</code>라 이름붙여진 것에 주의하십시오.
이는 캔버스 요소에서 <em>컨텐츠</em>를 보여주는 부분을 의미한다는 뜻이고, 따라서 <code class="notranslate" translate="no">clientWidth</code>, <code class="notranslate" translate="no">clientHeight</code>와 <code class="notranslate" translate="no">getBoundingClientRect</code>처럼 
패딩을 포함하지 않는다는 뜻입니다. 장점입니다.</p>
<p>이런 식으로 반환하는 이유는 결과가 비동기적이기 때문입니다.
위에서 언급한 &quot;컴포지터&quot;는 페이지와 비동기적으로 실행됩니다.
실제로 사용하게 될 크기를 알아내고 여러분에게 그 크기를 <em>대역 밖</em>에서 전달해 줍니다.</p>
<p>안타깝게도 <code class="notranslate" translate="no">ResizeObserver</code>는 모든 모던 브라우저에서 제공하지만 <code class="notranslate" translate="no">devicePixelContentBoxSize</code>는 크롬/엣지 브라우저에서만 사용 가능합니다.
아래는 사용 방법입니다.</p>
<p><code class="notranslate" translate="no">ResizeObserver</code>를 만들고 어떤 요소든 크기가 변하면 호출하게 될 함수를 인자로 넘겨줍니다.
우리의 경우 이는 캔버스입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const resizeObserver = new ResizeObserver(onResize);
resizeObserver.observe(canvas, {box: &#39;content-box&#39;});
</code></pre>
<p>위 코드는 우리가 관찰할 요소의 크기가 변할 때 <code class="notranslate" translate="no">onResize</code> 함수(아래 코드)를 호출하는 <code class="notranslate" translate="no">ResizeObserver</code>를 만듭니다.
우리는 이 객체에게 캔버스를 <code class="notranslate" translate="no">관찰하라(observe)</code>고 했습니다.
<code class="notranslate" translate="no">content-box</code>의 크기가 변화하는지를 관찰하라고 한 것입니다.
이것은 중요하지만 약간은 헷갈리는 사실입니다. 
<code class="notranslate" translate="no">device-pixel-content-box</code>의 크기가 변하는지를 관찰하라고 할수도 있지만 위 예제에서처럼 캔버스의 크기가 윈도우 크기의 100%인 퍼센트 크기를 사용할 수 있고, 이는 일반적인 상황입니다.
이 경우엔 캔버스가 확대/축소 수준에 상관없이 항상 같은 디바이스 픽셀 숫자를 가집니다.
확대/축소에 따라 윈도우의 크기는 변하지 않기 때문에 항상 같은 디바이스 픽셀 숫자를 가집니다.
한편 <code class="notranslate" translate="no">content-box</code>는 우리가 확대/축소를 하면 변하게 되는데 이는 CSS 픽셀 단위로 측정되기 때문입니다.
따라서 우리가 확대/축소를 한다면 디바이스 픽셀 내의 CSS 픽셀 숫자가 변하게 됩니다.</p>
<p>확대/축소 수준에 신경쓰지 않는다면 <code class="notranslate" translate="no">device-pixel-content-box</code>만 관찰할 수도 있습니다.
지원하지 않는 경우에는 오류를 throw할 것입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const resizeObserver = new ResizeObserver(onResize);
try {
  // 디바이스 픽셀이 변할 경우에만 호출
  resizeObserver.observe(canvas, {box: &#39;device-pixel-content-box&#39;});
} catch (ex) {
  // device-pixel-content-box를 지원하지 않는 경우에는 아래 코드를 사용
  resizeObserver.observe(canvas, {box: &#39;content-box&#39;});
}
</code></pre>
<p><code class="notranslate" translate="no">onResize</code>함수는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry"><code class="notranslate" translate="no">ResizeObserverEntry</code>s</a> 배열에 의해 호출됩니다.
크기가 변한 요소마다 한번씩 호출됩니다.
하나 이상의 요소를 처리할 수 있도록 크기를 map에 기록해 둘 것입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 기본 캔버스 크기로 초기화
const canvasToDisplaySizeMap = new Map([[canvas, [300, 150]]]);

function onResize(entries) {
  for (const entry of entries) {
    let width;
    let height;
    let dpr = window.devicePixelRatio;
    if (entry.devicePixelContentBoxSize) {
      // 주의: 이 경우에만 올바른 결과가 도출됨
      // 다른 경우에는 불완전한 처리가 수행되는데 브라우저가 
      // 이러한 문제를 해결하는 방법을 제공하지 않는 경우임
      width = entry.devicePixelContentBoxSize[0].inlineSize;
      height = entry.devicePixelContentBoxSize[0].blockSize;
      dpr = 1; // 이미 width와 height값에 포함됨
    } else if (entry.contentBoxSize) {
      if (entry.contentBoxSize[0]) {
        width = entry.contentBoxSize[0].inlineSize;
        height = entry.contentBoxSize[0].blockSize;
      } else {
        width = entry.contentBoxSize.inlineSize;
        height = entry.contentBoxSize.blockSize;
      }
    } else {
      width = entry.contentRect.width;
      height = entry.contentRect.height;
    }
    const displayWidth = Math.round(width * dpr);
    const displayHeight = Math.round(height * dpr);
    canvasToDisplaySizeMap.set(entry.target, [displayWidth, displayHeight]);
  }
}
</code></pre>
<p>지저분해 보이네요. <code class="notranslate" translate="no">devicePixelContentBoxSize</code>를 지원하지 않는 경우에 대한 3개 다른 버전의 API를 사용하는 것을 보실 수 있습니다. 😂</p>
<p>이제 이 데이터를 사용하도록 resize 함수를 수정합시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
-  // Lookup the size the browser is displaying the canvas in CSS pixels.
-  const dpr = window.devicePixelRatio;
-  const {width, height} = canvas.getBoundingClientRect();
-  const displayWidth  = Math.round(width * dpr);
-  const displayHeight = Math.round(height * dpr);
+  // 디바이스 픽셀 단위로 브라우저가 이 캔버스를 표시하는 크기를 얻어옵니다.
+ const [displayWidth, displayHeight] = canvasToDisplaySizeMap.get(canvas);

  // 캔버스와 크기가 다른지 확인합니다.
  const needResize = canvas.width  != displayWidth || 
                     canvas.height != displayHeight;

  if (needResize) {
    // 캔버스를 동일한 크기가 되도록 합니다.
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>아래는 이 코드를 사용한 예제입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-canvas-hd-dpi.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-canvas-hd-dpi.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>차이점을 발견하기 어려우실 겁니다.
스마트폰이나 2019년 이후 맥, 또는 4K 모니터와 같은 HD-DPI 디스플레이를 사용한다면 이 선이 위 예제의 선보다 얇아보일 겁니다.</p>
<p>한편, 확대를 해도(별개의 윈도우에서 열어서 확인해 보시길 바랍니다.) 선이 동일한 해상도를 유지할 겁니다.
이전 예제에서는 확대를 하면 선이 굵어지고 해상도가 떨어지는데 이는 <code class="notranslate" translate="no">devicePixelRatio</code>를 보정하지 않기 때문입니다.</p>
<p>아래는 간단히 캔버스 2D를 사용해 세 가지 방법 전체를 테스트한 결과입니다.
간단히 하기위해서 WebGL을 사용하지 않았습니다. 대신 캔버스 2D를 사용하고 
2x2 수직 흑백 패턴과 2x2 수평 흑백의 두 가지 패턴을 만들었습니다.
왼쪽에는 수평 패턴 ▤를 그리고 오른쪽에는 수직 패턴 ▥를 그렸습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-the-canvas-comparison.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-the-canvas-comparison.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>윈도우를 리사이즈 하거나, 더 좋은 방법은 새 창으로 열어서 위에 이야기한 키를 사용하여 확대/축소 해 보십시오.
서로 다른 확대/축소 수준에서 윈도우 크기를 바꿔 보면 가장 아래쪽 예제만 올바로 동작하는 것을 볼 수 있을겁니다(크롬/엣지 브라우저의 경우).
주의할 것은 여러분 장치의 <code class="notranslate" translate="no">devicePixelRatio</code>가 커질수록 문제점을 눈치채기 어렵다는 것입니다.
주목하셔야 할 것은 오른쪽과 왼쪽 패턴이 유사하게 보이는지 입니다.
패턴이 거칠어 보이거나 음영이 다르게 보이면 제대로 동작하지 않는 것입니다.
이 기능은 크롬/엣지 브라우저에서만 동작하기 때문에 이들을 사용하여야 제대로 동작하는지 볼 수 있습니다.</p>
<p>또 다른 주의사항은 어떤 OS(MacOS)에서는 앱에서는 숨겨진 OS 수준의 스케일링 옵션이 있다는 것입니다.
이 경우 가장 아래쪽 케이스에서도 약간의 패턴을 볼 수 있는데(크롬/엣지 브라우저를 사용하는 경우에도) 그래도 일정한 패턴일 것입니다.</p>
<p>이는 다른 브라우저에는 아직 좋은 해결 방안이 없다는 뜻이지만 꼭 완전한 해결법이 필요한 것일까요?
대부분의 WebGL 앱의 역할은 텍스처와 조명 효과를 더한 3D를 그리는 것입니다.
그래서 위쪽과 같이 <code class="notranslate" translate="no">devicePixelRatio</code>를 무시하거나, <code class="notranslate" translate="no">clientWidth</code>, <code class="notranslate" translate="no">clientHeight</code> 또는 <code class="notranslate" translate="no">getBoundingClientRect()</code> * <code class="notranslate" translate="no">devicePixelRatio</code>를 사용하고 
그냥 넘어가도 크게 티가 나지는 않습니다.</p>
<p>나아가서, <code class="notranslate" translate="no">devicePixelRatio</code>를 무작정 사용하는 것은 성능 저하를 불러일으킬 수 있습니다.
iPhoneX나 iPhone11에서는 <code class="notranslate" translate="no">window.devicePixelRatio</code>가 <code class="notranslate" translate="no">3</code>인데 
이는 9배나 많은 픽셀을 그리게 된다는 뜻입니다.
Samsung Galaxy S8에서는 그 값이 <code class="notranslate" translate="no">4</code>인데 이는 16배 많은 픽셀을 그린다는 뜻입니다.
이는 여러분 프로그램을 느리게 만듭니다. 사실 게임에서 실제 그려지는 것보다 더 적은 픽셀을 그리고 GPU에서 스케일을 늘리는 것이 보편적인 최적화 기법입니다.
어떻게 할지는 여러분에게 필요한 것이 무엇인지에 달렸습니다.
프린트하기 위한 그래픽을 그리는 것이라면 HD-DPI를 지원하는 것이 필요합니다.
게임을 만든다면 이러한 기능이 필요 없거나 혹은 시스템이 충분히 빠르지 못한 경우 유저에게 이러한 기능을 켜고 끄는 옵션을 제공하는 것이 좋습니다.</p>
<p>또 다른 주의사항은, 적어도 2021 1월 현재 <code class="notranslate" translate="no">round(getBoundingClientRect * devicePixelRatio)</code>가 위의 선 예제처럼 
캔버스가 풀 사이즈인 <strong>경우에만</strong> 모던 브라우저들에서 제대로 동작한다는 것입니다.
아래는 패던을 사용한 예제입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-the-canvas-comparison-fullwindow.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-the-canvas-comparison-fullwindow.html" target="_blank">새 창으로 열기</a>
</div>

</p>
<p>여러분이 <em>이 페이지</em>를 확대/축소 하고 리사이즈 한다면 <code class="notranslate" translate="no">getBoundingClientRect</code>가 제대로 동작하지 않을 것입니다.
이는 캔버스가 전체 윈도우가 아니고 iframe내부에 있기 때문입니다.
예제를 별도의 윈도우에서 열면 제대로 동작할 것입니다.</p>
<p>어떤 방법을 사용할 것인지는 여러분에게 달렸습니다.
저같은 경우 99%의 경우 <code class="notranslate" translate="no">devicePixelRatio</code>를 사용하지 않습니다.
이는 대부분의 사람들은 눈치채지 못하는 몇 가지 그래픽적인 장점만을 제공하면서 페이지를 느리게 만들기 때문입니다.
이 사이트에서 몇 개의 다이어그램에는 이 기능을 사용하지만 대부분의 예제에서는 사용하지 않고 있습니다.</p>
<p>여러 WebGL 프로그램에서 리사이징이나 캔버스의 크기를 셋팅하는 서로 다른 방법들을 보실 수 있을겁니다.
제 생각에는 브라우저가 디스플레이되는 캔버스의 크기를 CSS를 통해 결정하고 그 뒤에 결정된 크기를 기반으로 캔버스에 얼마나 많은 필셀을 그릴지를 조정하는 것이 
가장 좋은 방법인 것 같습니다.
이유가 궁금하시다면 <a href="webgl-anti-patterns.html">여기 몇 가지 이유가 있습니다.</a> 
위에 말씀드린 방법이 가장 선호되는 방법일 것 같습니다.</p>
<!-- just to shut up the build that this link used to exist
     and still exists in older translations -->
<p><a href="webgl-animation.html"></a></p>
<script type="module" src="../resources/webgl-resizing-the-canvas.module.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-resizing-the-canvas.html" >English</a>
    <option value="/webgl/lessons/de/webgl-resizing-the-canvas.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-resizing-the-canvas.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-resizing-the-canvas.html" selected>한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-resizing-the-canvas.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-getting-webgl2.html">WebGL2 사용법</a></li>
<li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">WebGL2 작동 원리</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">WebGL2 셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl2-whats-new.html">WebGL2 새로운 기능</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2.html">WebGL1에서 WebGL2로의 변경</a></li>
<li><a href="/webgl/lessons/ko/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org과 WebGL2Fundamentals.org의 차이점</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">WebGL2 이미지 처리 심화</a></li>
        </ul>
  <li>2D 이동, 회전, 크기 변환 행렬 계산</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">WebGL2 2D 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">WebGL2 2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">WebGL2 2D 크기 변환</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">WebGL2 2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D - 카메라</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-naming.html">3D - 행렬의 이름</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명 효과(Directional Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명 효과(Point Lighting)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스팟 조명 효과(Spot Lighting)</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">더 적은 코드로 즐겁게 코딩하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체를 그리는 법</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면(Scene) 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">두개 이상의 텍스처 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지(Cross Origin Image)</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처에 렌더링하기</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skybox</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">정점 인덱스 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">인스턴스 드로잉(Instanced Drawing)</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">보일러플레이트(Boilerplate)</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">Canvas 리사이징</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL2 알파(Alpha)</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL2 행렬 vs 수학에서의 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 이슈</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Canvas Clear 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스에서 키보드 입력 받기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">HTML에서 WebGL2를 배경으로 사용하기</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffer</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈나 버그가 있나요? <a href="https://github.com/greggman/webgl2-fundamentals/issues">깃헙에서 이슈 만들기</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Canvas 리사이징.';
            var disqus_title = 'WebGL2 Canvas 리사이징.';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님, <br>당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여</a>에 감사드립니다.",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




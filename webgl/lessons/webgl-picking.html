<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-picking.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to pick things in WebGL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg">

<meta property="og:title" content="WebGL2 Picking">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg">
<meta property="og:description" content="How to pick things in WebGL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-picking.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Picking">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-picking.html">
<meta name="twitter:description" content="How to pick things in WebGL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-picking.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-picking.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/webgl-picking.html",
      "inLanguage":"en",
      "name":"WebGL2 Picking",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-picking.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Picking</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-picking.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-picking.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-picking.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-picking.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-picking.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Picking</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is about how to use WebGL to let the user pick or select
things.</p>
<p>If you&#39;ve read the other articles on this site you have hopefully realized
that WebGL itself is just a rasterization library. It draws triangles,
lines, and points into the canvas so it has no concept of &quot;objects to be
selected&quot;. It just outputs pixels via shaders you supply. That means
any concept of &quot;picking&quot; something has to come from your code. You need
to define what these things you&#39;re letting the user select are.
That means while this article can cover general concepts you&#39;ll need to
decide for yourself how to translate what you see here into usable
concepts in your own application.</p>
<h2 id="clicking-on-an-object">Clicking on an Object</h2>
<p>One of the easiest ways figure out which thing a user clicked on is
we come up with a numeric id for each object, we can then draw 
all of the objects using their id as their color with no lighting
and no textures. This will give us an image of the silhouettes of
each object. The depth buffer will handle sorting for us.
We can then read the color of the pixel under the
mouse which will give us the id of the object that was rendered there.</p>
<p>To implement this technique we&#39;ll need to combine several previous
articles. The first is the article on <a href="webgl-drawing-multiple-things.html">drawing multiple objects</a>
which we&#39;ll use because given it draws multiple things we can try to
pick them.</p>
<p>On top of that we generally want to render these ids off screen
by <a href="webgl-render-to-texture.html">rendering to a texture</a> so we&#39;ll
add in that code as well.</p>
<p>So, let&#39;s start with the last example from
<a href="webgl-drawing-multiple-things.html">the article on drawing multiple things</a>
that draws 200 things.</p>
<p>To it let&#39;s add a framebuffer with attached texture and depth buffer from
the last example in <a href="webgl-render-to-texture.html">the article on rendering to a texture</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Create a texture to render to
const targetTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, targetTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// create a depth renderbuffer
const depthBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);

function setFramebufferAttachmentSizes(width, height) {
  gl.bindTexture(gl.TEXTURE_2D, targetTexture);
  // define size and format of level 0
  const level = 0;
  const internalFormat = gl.RGBA;
  const border = 0;
  const format = gl.RGBA;
  const type = gl.UNSIGNED_BYTE;
  const data = null;
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border,
                format, type, data);

  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
}

// Create and bind the framebuffer
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

// attach the texture as the first color attachment
const attachmentPoint = gl.COLOR_ATTACHMENT0;
const level = 0;
gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);

// make a depth buffer and the same size as the targetTexture
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
</code></pre>
<p>We put the code to set the sizes of the texture and
the depth renderbuffer into a function so we can
call it to resize them to match the size of the
canvas.</p>
<p>In our rendering code if the canvas changes size
we&#39;ll adjust the texture and renderbuffer to match.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(time) {
  time *= 0.0005;

-  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
+    // the canvas was resized, make the framebuffer attachments match
+    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
+  }

...
</code></pre>
<p>Next we need a second shader. The shader in the
sample renders using vertex colors but we need
one we can set to a solid color to render with ids.
So first here is our second shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const pickingVS = `#version 300 es
  in vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
    // Multiply the position by the matrix.
    gl_Position = u_matrix * a_position;
  }
`;

const pickingFS = `#version 300 es
  precision highp float;

  uniform vec4 u_id;

  out vec4 outColor;

  void main() {
     outColor = u_id;
  }
`;
</code></pre>
<p>And we need to compile, link and look up the locations
using our <a href="webgl-less-code-more-fun.html">helpers</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// setup GLSL program
// note: we need the attribute positions to match across programs
// so that we only need one vertex array per shape
const options = {
  attribLocations: {
    a_position: 0,
    a_color: 1,
  },
};
const programInfo = twgl.createProgramInfo(gl, [vs, fs], options);
const pickingProgramInfo = twgl.createProgramInfo(gl, [pickingVS, pickingFS], options);
</code></pre>
<p>One difference above from most samples on this site, this is one
of the few times we&#39;ve needed to draw the same data with 2 different
shaders. Because of that we need the attributes locations to match
across shaders. We can do that in 2 ways. One way is to set them
manually in the GLSL</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">layout (location = 0) in vec4 a_position;
layout (location = 1) in vec4 a_color;
</code></pre>
<p>The other is to call <code class="notranslate" translate="no">gl.bindAttribLocation</code> <strong>before</strong> linking
a shader program</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.bindAttribLocation(someProgram, 0, &#39;a_position&#39;);
gl.bindAttribLocation(someProgram, 1, &#39;a_color&#39;);
gl.linkProgram(someProgram);
</code></pre>
<p>This latter style is uncommon but it&#39;s more
<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">D.R.Y.</a>.
Our helper library will call <code class="notranslate" translate="no">gl.bindAttribLocation</code> for us
if we pass in the attribute names and the location we want
which is what is happening above.</p>
<p>This we&#39;ll mean we can guarantee the <code class="notranslate" translate="no">a_position</code> attribute uses
location 0 in both programs so we can use the same vertex array
with both programs.</p>
<p>Next we need to be able to render all the objects
twice. Once with whatever shader we assigned to
them and again with the shader we just wrote
so let&#39;s extract the code that currently renders
all the objects into a function.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawObjects(objectsToDraw, overrideProgramInfo) {
  objectsToDraw.forEach(function(object) {
    const programInfo = overrideProgramInfo || object.programInfo;
    const bufferInfo = object.bufferInfo;
    const vertexArray = object.vertexArray;

    gl.useProgram(programInfo.program);

    // Setup all the needed attributes.
    gl.bindVertexArray(vertexArray);

    // Set the uniforms.
    twgl.setUniforms(programInfo, object.uniforms);

    // Draw (calls gl.drawArrays or gl.drawElements)
    twgl.drawBufferInfo(gl, object.bufferInfo);
  });
}
</code></pre>
<p><code class="notranslate" translate="no">drawObjects</code> takes an optional <code class="notranslate" translate="no">overrideProgramInfo</code>
we can pass in to use our picking shader instead of
the object&#39;s assigned shader.</p>
<p>Let&#39;s call it, once to draw into the texture with
ids and again to draw the scene to the canvas.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Draw the scene.
function drawScene(time) {
  time *= 0.0005;

  ...

  // Compute the matrices for each object.
  objects.forEach(function(object) {
    object.uniforms.u_matrix = computeMatrix(
        viewProjectionMatrix,
        object.translation,
        object.xRotationSpeed * time,
        object.yRotationSpeed * time);
  });

+  // ------ Draw the objects to the texture --------
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  gl.enable(gl.CULL_FACE);
+  gl.enable(gl.DEPTH_TEST);
+
+  // Clear the canvas AND the depth buffer.
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  drawObjects(objectsToDraw, pickingProgramInfo);
+
+  // ------ Draw the objects to the canvas
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  drawObjects(objectsToDraw);

  requestAnimationFrame(drawScene);
}
</code></pre>
<p>Our picking shader needs <code class="notranslate" translate="no">u_id</code> set to an id so let&#39;s
add that to our uniform data where we setup our objects.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Make infos for each object for each object.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
+  const id = ii + 1;

  // pick a shape
  const shape = shapes[rand(shapes.length) | 0];

  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
      u_matrix: m4.identity(),
+      u_id: [
+        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
+        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
+      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);

  // Add it to the list of things to draw.
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: shape.bufferInfo,
    vertexArray: shape.vertexArray,
    uniforms: object.uniforms,
  });
}
</code></pre>
<p>This will work because our <a href="webgl-less-code-more-fun.html">helper library</a>
handles applying uniforms for us.</p>
<p>We had to split ids across R, G, B, and A. Because our
texture&#39;s format/type is <code class="notranslate" translate="no">gl.RGBA</code>, <code class="notranslate" translate="no">gl.UNSIGNED_BYTE</code>
we get 8 bits per channel. 8 bits only represent 256 values
but by splitting the id across 4 channels we get 32bits total
which is &gt; 4 billion values.</p>
<p>We add 1 to the id because we&#39;ll use 0 for meaning
&quot;nothing under the mouse&quot;.</p>
<p>Now let&#39;s highlight the object under the mouse.</p>
<p>First we need some code to get a canvas relative
mouse position.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX and mouseY are in CSS display space relative to canvas
let mouseX = -1;
let mouseY = -1;

...

gl.canvas.addEventListener(&#39;mousemove&#39;, (e) =&gt; {
   const rect = canvas.getBoundingClientRect();
   mouseX = e.clientX - rect.left;
   mouseY = e.clientY - rect.top;
});
</code></pre>
<p>Note that with the code above <code class="notranslate" translate="no">mouseX</code> and <code class="notranslate" translate="no">mouseY</code>
are in CSS pixels in display space. That means
they are in the space the canvas is displayed,
not the space of how many pixels are in the canvas.
In other words if you had a canvas like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas width=&quot;11&quot; height=&quot;22&quot; style=&quot;width:33px; height:44px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>then <code class="notranslate" translate="no">mouseX</code> will go from 0 to 33 across the canvas and
<code class="notranslate" translate="no">mouseY</code> will go from 0 to 44 across the canvas. See <a href="webgl-resizing-the-canvas.html">this</a>
for more info.</p>
<p>Now that we have a mouse position let&#39;s add some code
look up the pixel under the mouse</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
    pixelX,            // x
    pixelY,            // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);
</code></pre>
<p>The code above that is computing <code class="notranslate" translate="no">pixelX</code> and <code class="notranslate" translate="no">pixelY</code> is converting
from <code class="notranslate" translate="no">mouseX</code> and <code class="notranslate" translate="no">mouseY</code> in display space to pixel in the canvas
space. In other words, given the example above where <code class="notranslate" translate="no">mouseX</code> went from
0 to 33 and <code class="notranslate" translate="no">mouseY</code> went from 0 to 44. <code class="notranslate" translate="no">pixelX</code> will go from 0 to 11
and <code class="notranslate" translate="no">pixelY</code> will go from 0 to 22.</p>
<p>In our actual code we&#39;re using our utility function <code class="notranslate" translate="no">resizeCanvasToDisplaySize</code>
and we&#39;re making our texture the same size as the canvas so the display
size and the canvas size match but at least we&#39;re prepared for the case
where they do not match.</p>
<p>Now that we have an id, to actually highlight the selected object
let&#39;s change the color we&#39;re using to render it to the canvas.
The shader we were using has a <code class="notranslate" translate="no">u_colorMult</code>
uniform we can use so if an object is under the mouse we&#39;ll look it up,
save off its <code class="notranslate" translate="no">u_colorMult</code> value, replace it with a selection color,
and restore it.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX and mouseY are in CSS display space relative to canvas
let mouseX = -1;
let mouseY = -1;
+let oldPickNdx = -1;
+let oldPickColor;
+let frameCount = 0;

// Draw the scene.
function drawScene(time) {
  time *= 0.0005;
+  ++frameCount;

  // ------ Draw the objects to the texture --------

  ...

  // ------ Figure out what pixel is under the mouse and read it

  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
  const data = new Uint8Array(4);
  gl.readPixels(
      pixelX,            // x
      pixelY,            // y
      1,                 // width
      1,                 // height
      gl.RGBA,           // format
      gl.UNSIGNED_BYTE,  // type
      data);             // typed array to hold result
  const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

  // restore the object&#39;s color
  if (oldPickNdx &gt;= 0) {
    const object = objects[oldPickNdx];
    object.uniforms.u_colorMult = oldPickColor;
    oldPickNdx = -1;
  }

  // highlight object under mouse
  if (id &gt; 0) {
    const pickNdx = id - 1;
    oldPickNdx = pickNdx;
    const object = objects[pickNdx];
    oldPickColor = object.uniforms.u_colorMult;
    object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
  }

  // ------ Draw the objects to the canvas
</code></pre>
<p>And with that we should be able to move the mouse over
the scene and the object under the mouse will flash</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>One optimization we can make, we&#39;re rendering
the ids to a texture that&#39;s the same size
as the canvas. This is conceptually the easiest
thing to do.</p>
<p>But, we could instead just render the pixel
under the mouse. To do this we use a frustum
who&#39;s math will cover just the space for that
1 pixel.</p>
<p>Until now, for 3D we&#39;ve been using a function called
<code class="notranslate" translate="no">perspective</code> that takes as input a field of view, an aspect, and a
near and far value for the z-planes and makes a
perspective projection matrix that converts from the
frustum defined by those values to clip space.</p>
<p>Most 3D math libraries have another function called
<code class="notranslate" translate="no">frustum</code> that takes 6 values, the left, right, top,
and bottom values for the near z-plane and then the
z-near and z-far values for the z-planes and generates
a perspective matrix defined by those values.</p>
<p>Using that we can generate a perspective matrix for
the one pixel under the mouse</p>
<p>First we compute the edges and size of what our near plane <em>would be</em>
if we were to use the <code class="notranslate" translate="no">perspective</code> function</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// compute the rectangle the near plane of our frustum covers
const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
const top = Math.tan(fieldOfViewRadians * 0.5) * near;
const bottom = -top;
const left = aspect * bottom;
const right = aspect * top;
const width = Math.abs(right - left);
const height = Math.abs(top - bottom);
</code></pre>
<p>So <code class="notranslate" translate="no">left</code>, <code class="notranslate" translate="no">right</code>, <code class="notranslate" translate="no">width</code>, and <code class="notranslate" translate="no">height</code> are the
size and position of the near plane. Now on that
plane we can compute the size and position of the
one pixel under the mouse and pass that to the
<code class="notranslate" translate="no">frustum</code> function to generate a projection matrix
that covers just that 1 pixel</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// compute the portion of the near plane covers the 1 pixel
// under the mouse.
const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

const subLeft = left + pixelX * width / gl.canvas.width;
const subBottom = bottom + pixelY * height / gl.canvas.height;
const subWidth = width / gl.canvas.width;
const subHeight = height / gl.canvas.height;

// make a frustum for that 1 pixel
const projectionMatrix = m4.frustum(
    subLeft,
    subLeft + subWidth,
    subBottom,
    subBottom + subHeight,
    near,
    far);
</code></pre>
<p>To use this we need to make some changes. As it now our shader
just takes <code class="notranslate" translate="no">u_matrix</code> which means in order to draw with a different
projection matrix we&#39;d need to recompute the matrices for every object
twice each frame, once with our normal projection matrix for drawing
to the canvas and again for this 1 pixel projection matrix.</p>
<p>We can remove that responsibility from JavaScript by moving that
multiplication to the vertex shaders.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">const vs = `#version 300 es

in vec4 a_position;
in vec4 a_color;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

out vec4 v_color;

void main() {
  // Multiply the position by the matrix.
-  gl_Position = u_matrix * a_position;
+  gl_Position = u_viewProjection * u_world * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
`;

...

const pickingVS = `#version 300 es
  in vec4 a_position;

-  uniform mat4 u_matrix;
+  uniform mat4 u_viewProjection;
+  uniform mat4 u_world;

  void main() {
    // Multiply the position by the matrix.
-   gl_Position = u_matrix * a_position;
+    gl_Position = u_viewProjection * u_world * a_position;
  }
`;
</code></pre>
<p>Then we can make our JavaScript <code class="notranslate" translate="no">viewProjectionMatrix</code> shared
among all the objects.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const objectsToDraw = [];
const objects = [];
+const viewProjectionMatrix = m4.identity();

// Make infos for each object for each object.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
  const id = ii + 1;

  // pick a shape
  const shape = shapes[rand(shapes.length) | 0];

  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
-      u_matrix: m4.identity(),
+      u_world: m4.identity(),
+      u_viewProjection: viewProjectionMatrix,
      u_id: [
        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
</code></pre>
<p>And where we compute the matrices for each object we no longer need
to include the view projection matrix</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
-  let matrix = m4.translate(viewProjectionMatrix,
+function computeMatrix(translation, xRotation, yRotation) {
+  let matrix = m4.translation(
      translation[0],
      translation[1],
      translation[2]);
  matrix = m4.xRotate(matrix, xRotation);
  return m4.yRotate(matrix, yRotation);
}
...

// Compute the matrices for each object.
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
-      viewProjectionMatrix,
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});
</code></pre>
<p>We&#39;ll create just a 1x1 pixel texture and depth buffer</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">setFramebufferAttachmentSizes(1, 1);

...

// Draw the scene.
function drawScene(time) {
  time *= 0.0005;
  ++frameCount;

-  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
-    // the canvas was resized, make the framebuffer attachments match
-    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
-  }
+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>Then before rendering the off screen ids we&#39;ll set the view projection
using our 1 pixel projection matrix and then when drawing to the canvas
we&#39;ll use the original projection matrix</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-// Compute the projection matrix
-const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
-const projectionMatrix =
-    m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

// Compute the camera&#39;s matrix using look at.
const cameraPosition = [0, 0, 100];
const target = [0, 0, 0];
const up = [0, 1, 0];
const cameraMatrix = m4.lookAt(cameraPosition, target, up);

// Make a view matrix from the camera matrix.
const viewMatrix = m4.inverse(cameraMatrix);

-const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

// Compute the matrices for each object.
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});

// ------ Draw the objects to the texture --------

// Figure out what pixel is under the mouse and setup
// a frustum to render just that pixel

{
  // compute the rectangle the near plane of our frustum covers
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const top = Math.tan(fieldOfViewRadians * 0.5) * near;
  const bottom = -top;
  const left = aspect * bottom;
  const right = aspect * top;
  const width = Math.abs(right - left);
  const height = Math.abs(top - bottom);

  // compute the portion of the near plane covers the 1 pixel
  // under the mouse.
  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

  const subLeft = left + pixelX * width / gl.canvas.width;
  const subBottom = bottom + pixelY * height / gl.canvas.height;
  const subWidth = width / gl.canvas.width;
  const subHeight = height / gl.canvas.height;

  // make a frustum for that 1 pixel
  const projectionMatrix = m4.frustum(
      subLeft,
      subLeft + subWidth,
      subBottom,
      subBottom + subHeight,
      near,
      far);
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
}

gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
gl.viewport(0, 0, 1, 1);

gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

// Clear the canvas AND the depth buffer.
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

drawObjects(objectsToDraw, pickingProgramInfo);

// read the 1 pixel
-const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
-const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
-    pixelX,            // x
-    pixelY,            // y
+    0,                 // x
+    0,                 // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

// restore the object&#39;s color
if (oldPickNdx &gt;= 0) {
  const object = objects[oldPickNdx];
  object.uniforms.u_colorMult = oldPickColor;
  oldPickNdx = -1;
}

// highlight object under mouse
if (id &gt; 0) {
  const pickNdx = id - 1;
  oldPickNdx = pickNdx;
  const object = objects[pickNdx];
  oldPickColor = object.uniforms.u_colorMult;
  object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
}

// ------ Draw the objects to the canvas

+{
+  // Compute the projection matrix
+  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+  const projectionMatrix =
+      m4.perspective(fieldOfViewRadians, aspect, near, far);
+
+  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
+}

gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

drawObjects(objectsToDraw);
</code></pre>
<p>And you can see the math works, we&#39;re only drawing a single pixel
and we&#39;re still figuring out what is under the mouse</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu-1pixel.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu-1pixel.html" target="_blank">click here to open in a separate window</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-picking.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Picking';
            var disqus_title = 'WebGL2 Picking';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




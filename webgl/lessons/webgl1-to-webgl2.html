<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl1-to-webgl2.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to move from WebGL1 to WebGL2" />
<meta name="keywords" content="webgl webgl2 graphics" />
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_en.jpg" />

<meta property="og:title" content="WebGL2 from WebGL1" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_en.jpg" />
<meta property="og:description" content="How to move from WebGL1 to WebGL2" />
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webgl2fundamentals.org" />
<meta name="twitter:title" content="WebGL2 from WebGL1" />
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html" />
<meta name="twitter:description" content="How to move from WebGL1 to WebGL2" />
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_en.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html",
      "inLanguage":"en",
      "name":"WebGL2 from WebGL1",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 from WebGL1</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl1-to-webgl2.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl1-to-webgl2.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl1-to-webgl2.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl1-to-webgl2.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl1-to-webgl2.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 from WebGL1</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL2 is <strong>nearly</strong> 100% backward compatible with WebGL1.
If you only use WebGL1 features then then there are
only 2 <strong>major</strong> differences.</p>
<ol>
<li><p>You use <code>&quot;webgl2&quot;</code> instead of <code>&quot;webgl&quot;</code> when calling <code>getContext</code></p>
<pre class="prettyprint"><code>var gl = someCanvas.getContext(&quot;webgl2&quot;);
</code></pre><p>Note: there is no &quot;experimental-webgl2&quot;. The browser vendors got
together and decided no more prefixing things because websites
get dependent on the prefix.</p>
</li>
<li><p>Many extensions are a standard part of WebGL2 and so not available
as extensions</p>
<p>For example Vertex Array Objects <code>OES_vertex_array_object</code> is a
standard feature of WebGL2. So for example in WebGL1 you&#39;d do this</p>
<pre class="prettyprint"><code>var ext = gl.getExtension(&quot;OES_vertex_array_object&quot;);
if (!ext) {
  // tell user they don&#39;t have the required extension or work around it
} else {
  var someVAO = ext.createVertexArrayOES();
}
</code></pre><p>In WebGL2 you&#39;d do this</p>
<pre class="prettyprint"><code>var someVAO = gl.createVertexArray();
</code></pre><p>Because it just exists.</p>
</li>
</ol>
<p>That being said to take advantage of most WebGL2 features you&#39;ll need to make
some changes.</p>
<h2 id="switch-to-glsl-300-es">Switch to GLSL 300 es</h2>
<p>The biggest change is you should upgrade your shaders to GLSL 3.00 ES. To do
that the first line of your shaders needs to be</p>
<pre class="prettyprint"><code>#version 300 es
</code></pre><p><strong>NOTE: THIS HAS TO BE THE FIRST LINE! No comments, no blank lines before it allowed.</strong></p>
<p>In other words this is bad</p>
<pre class="prettyprint"><code>// BAD!!!!                +---There&#39;s a new line here!
// BAD!!!!                V
var vertexShaderSource = `
#version 300 es
..
`;
</code></pre><p>This is bad too</p>
<pre class="prettyprint"><code>&lt;!-- BAD!!                   V&lt;- there&#39;s a new line here
&lt;script id=&quot;vs&quot; type=&quot;notjs&quot;&gt;
#version 300 es
...
&lt;/script&gt;
</code></pre><p>This is good</p>
<pre class="prettyprint"><code>var vertexShaderSource = `#version 300 es
...
`;
</code></pre><p>This is good too</p>
<pre class="prettyprint"><code>&lt;script id=&quot;vs&quot; type=&quot;notjs&quot;&gt;#version 300 es
...
&lt;/script&gt;
</code></pre><p>Or you could make your shader compiling functions strip
the first blank lines.</p>
<h3 id="changes-in-glsl-300-es-from-glsl-100">Changes in GLSL 300 es from GLSL 100</h3>
<p>There are several changes you&#39;ll need to make to your shaders
on top of adding the version string above</p>
<h4 id="-attribute-in-"><code>attribute</code> -&gt; <code>in</code></h4>
<p>In GLSL 100 you might have</p>
<pre class="prettyprint"><code>attribute vec4 a_position;
attribute vec2 a_texcoord;
attribute vec3 a_normal;
</code></pre><p>In GLSL 300 es that becomes</p>
<pre class="prettyprint"><code>in vec4 a_position;
in vec2 a_texcoord;
in vec3 a_normal;
</code></pre><h4 id="-varying-to-in-out-"><code>varying</code> to <code>in</code> / <code>out</code></h4>
<p>In GLSL 100 you might declare a varying in both the vertex
and fragment shaders like this</p>
<pre class="prettyprint"><code>varying vec2 v_texcoord;
varying vec3 v_normal;
</code></pre><p>In GLSL 300 es in the vertex shader the varyings become</p>
<pre class="prettyprint"><code>out vec2 v_texcoord;
out vec3 v_normal;
</code></pre><p>And in the fragment shader they become</p>
<pre class="prettyprint"><code>in vec2 v_texcoord;
in vec3 v_normal;
</code></pre><h4 id="no-more-gl_fragcolor-">No more <code>gl_FragColor</code></h4>
<p>In GLSL 100 your fragment shader would set the special
variable <code>gl_FragColor</code> to set the output of the shader.</p>
<pre class="prettyprint"><code>gl_FragColor = vec4(1, 0, 0, 1);  // red
</code></pre><p>In GLSL 300 es you declare your own output variable and
then set it.</p>
<pre class="prettyprint"><code>out vec4 myOutputColor;

void main() {
   myOutputColor = vec4(1, 0, 0, 1);  // red
}
</code></pre><p>Note: You can pick any name you want but names can <strong>not</strong> start with
<code>gl_</code> so you can&#39;t just make <code>out vec4 gl_FragColor</code></p>
<h4 id="-texture2d-texture-etc-"><code>texture2D</code> -&gt; <code>texture</code> etc.</h4>
<p>In GLSL 100 you&#39;d get a color from a texture like this</p>
<pre class="prettyprint"><code>uniform sampler2D u_some2DTexture;
uniform samplerCube u_someCubeTexture;

...

vec4 color1 = texture2D(u_some2DTexture, ...);
vec4 color2 = textureCube(u_someCubeTexture, ...);
</code></pre><p>In GLSL 300es the texture functions automatically know
what to do based on the sampler type so now it&#39;s just
<code>texture</code></p>
<pre class="prettyprint"><code>uniform sampler2D u_some2DTexture;
uniform samplerCube u_someCubeTexture;

...

vec4 color1 = texture(u_some2DTexture, ...);
vec4 color2 = texture(u_someCubeTexture, ...);
</code></pre><h2 id="features-you-can-take-for-granted">Features you can take for granted</h2>
<p>In WebGL1 many features were optional extensions. In WebGL2
all of the following are standard features</p>
<ul>
<li>Depth Textures (<a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">WEBGL_depth_texture</a>)</li>
<li>Floating Point Textures (<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float/">OES_texture_float</a>/<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear/">OES_texture_float_linear</a>)</li>
<li>Vertex Array Objects (<a href="https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/">OES_vertex_array_object</a>)</li>
<li>Standard Derivatives (<a href="https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives/">OES_standard_derivatives</a>)</li>
<li>Instanced Drawing (<a href="https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays/">ANGLE_instanced_arrays</a>)</li>
<li>UNSIGNED_INT indices (<a href="https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint/">OES_element_index_uint</a>)</li>
<li>Setting <code>gl_FragDepth</code> (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth/">EXT_frag_depth</a>)</li>
<li>Blend Equation MIN/MAX (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax/">EXT_blend_minmax</a>)</li>
<li>Direct texture LOD access (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod/">EXT_shader_texture_lod</a>)</li>
<li>Multiple Draw Buffers (<a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers/">WEBGL_draw_buffers</a>)</li>
<li>Texture access in vertex shaders</li>
</ul>
<h2 id="non-power-of-2-texture-support">Non-Power of 2 Texture Support</h2>
<p>in WebGL1 textures that were not a power of 2 could not have mips.
In WebGL2 that limit is removed. Non-power of 2 texture work exactly
the same as power of 2 textures.</p>
<h2 id="floating-point-framebuffer-attachments">Floating Point Framebuffer Attachments</h2>
<p>In WebGL1 to check for support for rendering to a floating point texture
you would first check for and enable the <code>OES_texture_float</code> extension, then
you&#39;d create a floating point texture, attach it to a framebuffer, and call
<code>gl.checkFramebufferStatus</code> to see if it returned <code>gl.FRAMEBUFFER_COMPLETE</code>.</p>
<p>In WebGL2 you need to check for and enable <code>EXT_color_buffer_float</code> or else
<code>gl.checkFramebufferStatus</code> will never return <code>gl.FRAMEBUFFER_COMPLETE</code> for
a floating point texture.</p>
<p>Note that this is also true for <code>HALF_FLOAT</code> framebuffer attachments as well.</p>
<blockquote>
<p>If you&#39;re curious this was a <em>bug</em> in the WebLG1 spec. What happened is WebGL1
shipped and <code>OES_texture_float</code> was added and it was just assumed the correct
way to use it for rendering was to create a texture, attach it a framebuffer,
and check its status. Later someone pointed out according the spec that was
not enough because the spec says colors written in a fragment shader are
always clamped to 0 to 1. <code>EXT_color_buffer_float</code> removes that clamping
restriction but since WebGL had already been shipping for a year or so
it would have broken many web sites to enforce the restriction. For WebGL2
they were able to fix it and so now you must enable <code>EXT_color_buffer_float</code>
to use floating point textures as framebuffer attachments.</p>
<p>NOTE that AFAIK, as of March 2017 very few mobile devices support rendering to
floating point textures.</p>
</blockquote>
<h2 id="vertex-array-objects">Vertex Array Objects</h2>
<p>Of all the features above the one feature I personally think you should
always ALWAYS use is vertex array objects. Everything else it really
depends on what you&#39;re trying to do but vertex array objects in particular
seem like a basic feature that should always be used.</p>
<p>In WebGL1 without vertex array objects all the data about attributes
was global WebGL state. You can imagine it like this</p>
<pre class="prettyprint"><code>var glState = {
  attributeState: {
    ELEMENT_ARRAY_BUFFER: null,
    attributes: [
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
    ],
  },
</code></pre><p>   }</p>
<p>Calling functions like <code>gl.vertexAttribPointer</code>, <code>gl.enableVertexAttribArray</code>, and
<code>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ??)</code> would effect that global state.
Before each thing you wanted to draw you needed to setup all the attributes and if you
were drawing indexed data you needed to set the <code>ELEMENT_ARRAY_BUFFER</code>.</p>
<p>With Vertex Array Objects that entire <code>attributeState</code> above becomes a <em>Vertex Array</em>.</p>
<p>In other words</p>
<pre class="prettyprint"><code>var someVAO = gl.createVertexArray();
</code></pre><p>Makes a new instance of the thing above called <code>attributeState</code>.</p>
<pre class="prettyprint"><code>gl.bindVertexArray(someVAO);
</code></pre><p>Is equivalent to</p>
<pre class="prettyprint"><code>glState.attributeState = someVAO;
</code></pre><p>What that means is you should setup all of your attributes at init time now.</p>
<pre class="prettyprint"><code>// at init time
for each model / geometry / ...
  var vao = gl.createVertexArray()
  gl.bindVertexArray(vao);
  for each attribute
    gl.enableVertexAttribArray(...);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufferForAttribute);
    gl.vertexAttribPointer(...);
  if indexed geometry
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bindVertexArray(null);
</code></pre><p>Then at render time to use a particular geometry all you need to do
is</p>
<pre class="prettyprint"><code>gl.bindVertexArray(vaoForGeometry);
</code></pre><p>In WebGL1 the init loop above would have appeared at render time.
This is a HUGE speed up!</p>
<p>There are a few caveats though:</p>
<ol>
<li><p>attribute locations are program dependent.</p>
<p>If you&#39;re going to use the same geometry with multiple
programs consider manually assigning attribute locations.
In GLSL 300 es you can do this in the shader</p>
<p>For example:</p>
<pre class="prettyprint"><code>layout(location = 0) in vec4 a_position;
layout(location = 1) in vec2 a_texcoord;
layout(location = 2) in vec3 a_normal;
layout(location = 3) in vec4 a_color;
</code></pre><p>Sets the locations of the 4 attributes.</p>
<p>You can also still do it the WebGL1 way by calling
<code>gl.bindAttribLocation</code> before calling <code>gl.linkProgram</code>.</p>
<p>For example:</p>
<pre class="prettyprint"><code>gl.bindAttribLocation(someProgram, 0, &quot;a_position&quot;);
gl.bindAttribLocation(someProgram, 1, &quot;a_texcoord&quot;);
gl.bindAttribLocation(someProgram, 2, &quot;a_normal&quot;);
gl.bindAttribLocation(someProgram, 3, &quot;a_color&quot;);
</code></pre><p>This means you can force them to be compatible across multiple shader
programs. If one program doesn&#39;t need all attributes
the attributes they do need will still be assigned to
the same locations</p>
<p>If you don&#39;t do this you&#39;ll need different VAOs for
different shader programs when using same geometry OR
you&#39;ll need to just do the WebGL1 thing and not use
VAOs and always setup attributes at render time which is slow.</p>
<p>NOTE: of the 2 methods above I&#39;m leaning toward using
<code>gl.bindAttribLocation</code> because it&#39;s easy to have it in one
place in my code where as the method of using <code>layout(location = ?)</code> has
to be in all shaders so in the interest of D.R.Y. <code>gl.bindAttribLocation</code>
seems better. Maybe if I was using a shader generator then there&#39;d be no difference.</p>
</li>
<li><p>Always unbind the VAO when you&#39;re done</p>
<pre class="prettyprint"><code>gl.bindVertexArray(null);
</code></pre><p>This just comes from my own experience. If you look above
the <code>ELEMENT_ARRAY_BUFFER</code> state is part of a Vertex Array.</p>
<p>So, I ran into this issue. I created some geometry, then
I created a VAO for that geometry and set up the attributes
and <code>ELEMENT_ARRAY_BUFFER</code>. I then created some more
geometry. When that geometry setup its indices, because
I still had the previous VAO bound setting up the indices
effected the <code>ELEMENT_ARRAY_BUFFER</code> binding for the previous
VAO. It took me several hours to debug.</p>
<p>So, my suggestion is never leave a VAO bound if you&#39;re done
with it. Either immediately bind the next VAO you&#39;re going
to use or if you&#39;re done bind <code>null</code></p>
</li>
</ol>
<p>As mentioned at the top many extensions from WebGL1 are standard features
of WebGL2 so if you were using extensions in WebGL1 you&#39;ll need to
change your code to use them not as extensions in WebGL2. See below.</p>
<p>Two that need special care though</p>
<ol>
<li><p><code>OES_texture_float</code> and floating point textures.</p>
<p> Floating point textures are a standard feature of WebGL2 but</p>
<ul>
<li><p>Being able to filter floating point textures is still an extension, <code>OES_texture_float_linear</code></p>
</li>
<li><p>Being able to render to a floating point texture is an extension, <code>EXT_color_buffer_float</code></p>
</li>
<li><p>Creating a floating point texture is different. You must use one of the new WebGL2 internal
formats like <code>RGBA32F</code>, <code>R32F</code> etc. This is different than the WebGL1 <code>OES_texture_float</code>
extension in which the internal format was inferred from the <code>type</code> passed to <code>texImage2D</code></p>
</li>
</ul>
</li>
<li><p><code>WEBGL_depth_texture</code> and depth textures</p>
<p> Similar to the previous difference, to create a depth texture in WebGL2 you must use one of
 WebGL2&#39;s internal formats<code>DEPTH_COMPONENT16</code>, <code>DEPTH_COMPONENT24</code>,
 <code>DEPTH_COMPONENT32F</code>, <code>DEPTH24_STENCIL8</code>, or <code>DEPTH32F_STENCIL8</code> where as in the WebGL1
 <code>WEBGL_depth_texture</code> extension used <code>DEPTH_COMPONENT</code> and <code>DEPTH_STENCIL_COMPONENT</code></p>
</li>
</ol>
<p>That&#39;s my personal short list of things to be aware of when switching
from WebGL1 to WebGL2. <a href="webgl2-whats-new.html">There&#39;s even more stuff you can do in WebGL2 though</a>.</p>
<div class="webgl_bottombar">
<h3>Making WebGL1 extensions look like WebGL2</h3>
<p>Functions that were on extensions in WebGL1 are now on the main
context in WebGL2. For example in WebGL</p>
<pre class="prettyprint">
var ext = gl.getExtension("OES_vertex_array_object");
if (!ext) {
  // tell user they don't have the required extension or work around it
} else {
  var someVAO = ext.createVertexArrayOES();
}
</pre>
<p>
vs in webgl2
</p>
<pre class="prettyprint">
var someVAO = gl.createVertexArray();
</pre>
<p>As you can see if you want your code to run in both WebGL1 and WebGL2
that can present some challenges.</p>
<p>One workaround would be to copy WebGL1 extensions to the WebGL context at init time.
That way the rest of your code can stay the same. Example:</p>
<pre class="prettyprint">
const gl = someCanvas.getContext("webgl");
const haveVAOs = getAndApplyExtension(gl, "OES_vertex_array_object");

function getAndApplyExtension(gl, name) {
  const ext = gl.getExtension(name);
  if (!ext) {
    return null;
  }
  const fnSuffix = name.split("_")[0];
  const enumSuffix = '_' + fnSuffix;
  for (const key in ext) {
    const value = ext[key];
    const isFunc = typeof (value) === 'function';
    const suffix = isFunc ? fnSuffix : enumSuffix;
    let name = key;
    // examples of where this is not true are WEBGL_compressed_texture_s3tc
    // and WEBGL_compressed_texture_pvrtc
    if (key.endsWith(suffix)) {
      name = key.substring(0, key.length - suffix.length);
    }
    if (gl[name] !== undefined) {
      if (!isFunc && gl[name] !== value) {
        console.warn("conflict:", name, gl[name], value, key);
      }
    } else {
      if (isFunc) {
        gl[name] = function(origFn) {
          return function() {
            return origFn.apply(ext, arguments);
          };
        }(value);
      } else {
        gl[name] = value;
      }
    }
  }
  return ext;
}
</pre>
<p>Now your code can mostly just work the same on both. Example:</p>
<pre class="prettyprint">
if (haveVAOs) {
  var someVAO = gl.createVertexArray();
  ...
} else {
  ... do whatever for no VAOs.
}
</pre>
<p>The alternative would be having to do something like this</p>
<pre class="prettyprint">
if (haveVAOs) {
  if (isWebGL2)
     someVAO = gl.createVertexArray();
  } else {
     someVAO = vaoExt.createVertexArrayOES();
  }
  ...
} else {
  ... do whatever for no VAOs.
}
</pre>
<p>Note: In the case of Vertex Array Objects in particular I suggest you <a href="https://github.com/greggman/oes-vertex-array-object-polyfill">use a polyfill</a>
so you'll have them everywhere. VAOs are available on most systems. Those few system
where they aren't available the polyfill will handle for you and your code
can stay simple.</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl1-to-webgl2.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl1-to-webgl2.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl1-to-webgl2.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl1-to-webgl2.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl1-to-webgl2.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">WebGL2 3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="https://stackoverflow.com/questions/tagged/webgl2">Ask on stackoverflow</a>.</div>
    <div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 from WebGL1';
            var disqus_title = 'WebGL2 from WebGL1';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90754717-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>




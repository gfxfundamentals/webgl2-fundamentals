<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-shadertoy.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Shadertoy shaders">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_en.jpg">

<meta property="og:title" content="WebGL2 Shadertoy">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_en.jpg">
<meta property="og:description" content="Shadertoy shaders">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Shadertoy">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html">
<meta name="twitter:description" content="Shadertoy shaders">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html",
      "inLanguage":"en",
      "name":"WebGL2 Shadertoy",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Shadertoy</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shadertoy.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-shadertoy.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Shadertoy</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article assumes you&#39;ve read many of the other articles
starting with <a href="webgl-fundamentals.html">the fundamentals</a>.
If you have not read them please start there first. </p>
<p>In <a href="webgl-drawing-without-data.html">the article on the drawing without data</a>
we showed a few examples of drawing things with no data using a
vertex shader. This article will be about drawing things with
no data using fragment shaders.</p>
<p>We&#39;ll start with a simple solid color shader
with no math using the code <a href="webgl-fundamentals.html">from the very first article</a>.</p>
<p>A simple vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
  // an attribute is an input (in) to a vertex shader.
  // It will receive data from a buffer
  in vec4 a_position;

  // all shaders have a main function
  void main() {

    // gl_Position is a special variable a vertex shader
    // is responsible for setting
    gl_Position = a_position;
  }
`;
</code></pre>
<p>and a simple fragment shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
    outColor = vec4(1, 0, 0.5, 1); // return reddish-purple
  }
`;
</code></pre>
<p>Then we need to compile and link the shaders and look up position attribute location.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector(&quot;#canvas&quot;);
  const gl = canvas.getContext(&quot;webgl2&quot;);
  if (!gl) {
    return;
  }

  // setup GLSL program
  const program = webglUtils.createProgramFromSources(gl, [vs, fs]);

  // look up where the vertex data needs to go.
  const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p>and then create a vertex array,
fill out a buffer with 2 triangles that make a rectangle in clip space that
goes from -1 to +1 in x and y to cover the canvas, set set the attributes.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // Create a vertex array object (attribute state)
  const vao = gl.createVertexArray();

  // and make it the one we&#39;re currently working with
  gl.bindVertexArray(vao);

  // Create a buffer to put three 2d clip space points in
  const positionBuffer = gl.createBuffer();

  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // fill it with a 2 triangles that cover clip space
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  // first triangle
     1, -1,
    -1,  1,
    -1,  1,  // second triangle
     1, -1,
     1,  1,
  ]), gl.STATIC_DRAW);

  // Turn on the attribute
  gl.enableVertexAttribArray(positionAttributeLocation);

  // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
  gl.vertexAttribPointer(
      positionAttributeLocation,
      2,          // 2 components per iteration
      gl.FLOAT,   // the data is 32bit floats
      false,      // don&#39;t normalize the data
      0,          // 0 = move forward size * sizeof(type) each iteration to get the next position
      0,          // start at the beginning of the buffer
  );
</code></pre>
<p>And then we draw</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // Tell WebGL how to convert from clip space to pixels
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // Tell it to use our program (pair of shaders)
  gl.useProgram(program);

  // Bind the attribute/buffer set we want.
  gl.bindVertexArray(vao);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // offset
      6,     // num vertices to process
  );
</code></pre>
<p>And of course we get a solid color that covers the canvas.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-solid.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-solid.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>In <a href="webgl-how-it-works.html">the article on how WebGL works</a> we added more
color by providing a color for each vertex. In <a href="webgl-3d-textures.html">the article on textures</a>
we added more color by supplying textures and texture coordinates.
So how do we get something more than a solid color with out any more data? 
WebGL provides a variable called <code class="notranslate" translate="no">gl_FragCoord</code> that is equal to the <strong>pixel</strong>
coordinate of the pixel currently being drawn.</p>
<p>So let&#39;s change our fragment shader to use that to compute a color</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(1, 0, 0.5, 1); // return reddish-purple
+    outColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
  }
`;
</code></pre>
<p>Like we mentioned above <code class="notranslate" translate="no">gl_FragCoord</code> is a <strong>pixel</strong> coordinate so it will
count across and up the canvas. By dividing by 50 we&#39;ll get a value that goes
from 0 to 1 from as <code class="notranslate" translate="no">gl_FragCoord</code> goes from 0 to 50. By using <code class="notranslate" translate="no">fract</code> we&#39;ll
keep just the <em>fract</em>ional part so for example when <code class="notranslate" translate="no">gl_FragCoord</code> is 75.
75 / 50 = 1.5, fract(1.5) = 0.5 so we&#39;ll get a value that goes from 0 to 1
every 50 pixels.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-gl-fragcoord.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-gl-fragcoord.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>As you can see above every 50 pixels across red goes from 0 to 1
and every 50 pixels up green goes from 0 to 1.</p>
<p>With our setup now we could make more complex math for a fancier image.
but we have one problem in that we have no idea how large the canvas is
so we&#39;d have to hard code for a specific size. We can solve that problem
by passing in the size of the canvas and then divide <code class="notranslate" translate="no">gl_FragCoord</code> by
the size to give us a value that goes from 0 to 1 across and up the canvas
regardless of size.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

+  uniform vec2 u_resolution;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
+    outColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>and look up and set the uniform</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up where the vertex data needs to go.
const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);

+// look up uniform locations
+const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);

...

+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

gl.drawArrays(
    gl.TRIANGLES,
    0,     // offset
    6,     // num vertices to process
);

...
</code></pre>
<p>which lets us make our spread of red and green always fit the canvas regardless
of resolution</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-resolution.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-resolution.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Let&#39;s also pass in the mouse position in pixel coordinates.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;
+  uniform vec2 u_mouse;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
+    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>And then we need to look up the uniform location,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up uniform locations
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
+const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
</code></pre>
<p>track the mouse,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;

function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
  render();
}

canvas.addEventListener(&#39;mousemove&#39;, setMousePosition);
</code></pre>
<p>and set the uniform.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
+gl.uniform2f(mouseLocation, mouseX, mouseY);
</code></pre>
<p>We also need to change the code so we render when the mouse position changes</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
+  render();
}

+function render() {
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // offset
      6,     // num vertices to process
  );
+}
+render();
</code></pre>
<p>and while we&#39;re at it lets handle touch too</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">canvas.addEventListener(&#39;mousemove&#39;, setMousePosition);
+canvas.addEventListener(&#39;touchstart&#39;, (e) =&gt; {
+  e.preventDefault();
+}, {passive: false});
+canvas.addEventListener(&#39;touchmove&#39;, (e) =&gt; {
+  e.preventDefault();
+  setMousePosition(e.touches[0]);
+}, {passive: false});
</code></pre>
<p>and now you can see if you move the mouse over the example it affects our image.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-mouse.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-mouse.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>The final major piece is we want to be able to animate something so we pass in one
more thing, a time value we can use to add to our computations.</p>
<p>For example if we did this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
+  uniform float u_time;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
+    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), fract(u_time), 1);
  }
`;
</code></pre>
<p>And now the blue channel will pulse to the time. We just need to 
look up the uniform, and set it in a <a href="webgl-animation.html">requestAnimationFrame loop</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up uniform locations
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
+const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);

...

-function render() {
+function render(time) {
+  time *= 0.001;  // convert to seconds

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
  gl.uniform2f(mouseLocation, mouseX, mouseY);
+  gl.uniform1f(timeLocation, time);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // offset
      6,     // num vertices to process
  );

+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
-render();
</code></pre>
<p>Also we no longer need to render on mousemove since we&#39;re rendering continuously.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;
canvas.addEventListener(&#39;mousemove&#39;, (e) =&gt; {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
-  render();
});
</code></pre>
<p>And we get some simple but boring animation.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-time.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-time.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>So now with all of that we can take a shader from <a href="https://shadertoy.com">Shadertoy.com</a>. Shadertoy shaders you provide a function called <code class="notranslate" translate="no">mainImage</code> in this form</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void mainImage(out vec4 fragColor, in vec2 fragCoord)
{    
}
</code></pre>
<p>Where your job is to set <code class="notranslate" translate="no">fragColor</code> just like you&#39;d normally set <code class="notranslate" translate="no">gl_FragColor</code> and
<code class="notranslate" translate="no">fragCoord</code> is the same as <code class="notranslate" translate="no">gl_FragCoord</code>. Adding this extra function lets Shadertoy
impose a little more structure as well as do some extra work before or after calling
<code class="notranslate" translate="no">mainImage</code>. For us to use it we just need to call it like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

out vec4 outColor;

//---insert shadertoy code here--

void main() {
  mainImage(outColor, gl_FragCoord.xy);
}
</code></pre>
<p>Except that Shadertoy uses the uniform names <code class="notranslate" translate="no">iResolution</code>, <code class="notranslate" translate="no">iMouse</code> and <code class="notranslate" translate="no">iTime</code> so let&#39;s rename them.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

-uniform vec2 u_resolution;
-uniform vec2 u_mouse;
-uniform float u_time;
+uniform vec2 iResolution;
+uniform vec2 iMouse;
+uniform float iTime;

//---insert shadertoy code here--

out vec4 outColor;

void main() {
  mainImage(outColor, gl_FragCoord.xy);
}
</code></pre>
<p>and look them up by the new names</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up uniform locations
-const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
-const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
-const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);
+const resolutionLocation = gl.getUniformLocation(program, &quot;iResolution&quot;);
+const mouseLocation = gl.getUniformLocation(program, &quot;iMouse&quot;);
+const timeLocation = gl.getUniformLocation(program, &quot;iTime&quot;);
</code></pre>
<p>Taking <a href="https://www.shadertoy.com/view/3l23Rh">this shadertoy shader</a> and pasting it
in our shader above where it says <code class="notranslate" translate="no">//---insert shadertoy code here--</code> gives us...</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>That&#39;s an extraordinarily beautiful image for having no data!</p>
<p>I made the sample above only render when the mouse is over the canvas or when touched.
This is because the math required
to draw the image above is complex and slow and letting it run continuously would
make it very difficult to interact with this page. If you have
a very fast GPU the image above might run smooth. On my laptop
though it runs slow and jerky.</p>
<p>This brings up an extremely important point. <strong>The shaders on
shadertoy are not best practice</strong>. Shadertoy is a puzzle and
a challenge of <em>&quot;If I have no data and only a function that
takes very little input can I make an interesting or beautiful
image&quot;</em>. It&#39;s not the way to make performant WebGL.</p>
<p>Take for example <a href="https://www.shadertoy.com/view/4sS3zG">this amazing shadertoy shader</a> that looks like this</p>
<div class="webgl_center"><img src="resources/shadertoy-dolphin.png" style="width: 639px;"></div>

<p>It&#39;s beautiful but it runs at about 19 frames a second in a tiny
640x360 window on my high powered laptop. Expand the window to full screen and it runs around
2 or 3 frames per second. Testing on my higher spec desktop it still only hits 45 frames per
second at 640x360 and maybe 10 full screen.</p>
<p>Compare it to this game that&#39;s also fairly beautiful and yet runs at 30 to 60 frames per second
even on lower-powered GPUs</p>
<iframe class="webgl_center" style="width:560px; height: 360px;" src="https://www.youtube-nocookie.com/embed/7v9gZK9HqqI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>This is because the game uses best practices drawing things with textured
triangles instead of complex math.</p>
<p>So, please take that to heart. The examples on Shadertoy are
simply amazing in part because now you know they are made
under the extreme limit of almost no data and are complex
functions that draw pretty pictures. As such they are a thing
of wonder.</p>
<p>They are also a great way to learn a lot of math.
But, they are also not remotely the way you get a performant
WebGL app. So please keep that in mind.</p>
<p>Otherwise, if you want to run more Shadertoy shaders you&#39;ll
need to provide a few more uniforms. Here&#39;s a list of the
uniforms Shadertoy provides </p>
<div class="webgl_center"><table  class="tabular-data tabular-data1">
<thead><tr><td>type</td><td>name</td><td>where</td><td>description</td></tr></thead>
<tbody>
<tr><td><b>vec3</b></td><td><b>iResolution</b></td><td>image / buffer</td><td>The viewport resolution (z is pixel aspect ratio, usually 1.0)</td></tr>
<tr><td><b>float</b></td><td><b>iTime</b></td><td>image / sound / buffer</td><td>Current time in seconds</td></tr>
<tr><td><b>float</b></td><td><b>iTimeDelta</b></td><td>image / buffer</td><td>Time it takes to render a frame, in seconds</td></tr>
<tr><td><b>int</b></td><td><b>iFrame</b></td><td>image / buffer</td><td>Current frame</td></tr>
<tr><td><b>float</b></td><td><b>iFrameRate</b></td><td>image / buffer</td><td>Number of frames rendered per second</td></tr>
<tr><td><b>float</b></td><td><b>iChannelTime[4]</b></td><td>image / buffer</td><td>Time for channel (if video or sound), in seconds</td></tr>
<tr><td><b>vec3</b></td><td><b>iChannelResolution[4]</b></td><td>image / buffer / sound</td><td>Input texture resolution for each channel</td></tr>
<tr><td><b>vec4</b></td><td><b>iMouse</b></td><td>image / buffer</td><td>xy = current pixel coords (if LMB is down). zw = click pixel</td></tr>
<tr><td><b>sampler2D</b></td><td><b>iChannel{i}</b></td><td>image / buffer / sound</td><td>Sampler for input textures i</td></tr>
<tr><td><b>vec4</b></td><td><b>iDate</b></td><td>image / buffer / sound</td><td>Year, month, day, time in seconds in .xyzw</td></tr>
<tr><td><b>float</b></td><td><b>iSampleRate</b></td><td>image / buffer / sound</td><td>The sound sample rate (typically 44100)</td></tr>
</tbody></table></div>

<p>Notice <code class="notranslate" translate="no">iMouse</code> and <code class="notranslate" translate="no">iResolution</code> are actually supposed to be
a <code class="notranslate" translate="no">vec4</code> and a <code class="notranslate" translate="no">vec3</code> respectively so you may need to adjust
those to match.</p>
<p><code class="notranslate" translate="no">iChannel</code> are textures so if the shader needs them you&#39;ll need
to provide <a href="webgl-3d-textures.html">textures</a>.</p>
<p>Shadertoy also lets you use multiple shaders to render to
offscreen textures so if a shader needs those you&#39;ll need to setup
<a href="webgl-render-to-texture.html">textures to render to</a>.</p>
<p>The &quot;where&quot; column indicates which uniforms are
available in which shaders. &quot;image&quot; is a shader
that renders to the canvas. &quot;buffer&quot; is a shader
that renders to an offscreen texture. &quot;sound&quot; is
a shader where <a href="https://stackoverflow.com/questions/34859701/how-do-shadertoys-audio-shaders-work">your shader is expected to generate
sound data into a texture</a>.</p>
<p>I hope this helped explain Shadertoy. It&#39;s a great site with amazing works
but is good to know what&#39;s really going on. If you want to learn more about
the techniques used in these kinds of shader 2 good resources are
<a href="&quot;https://www.iquilezles.org/www/index.htm">the blog of the person that created the shadertoy website</a> and <a href="https://thebookofshaders.com/">The Book of Shaders</a> (which is a little misleading since it really only covers the kind of shaders used on shadertoy, not the kind used in performant apps and games. Still, it&#39;s a great resource!</p>
<div class="webgl_bottombar" id="pixel-coords">
<h3>Pixel Coordinates</h3>
<p>Pixel coordinates in WebGL
are referenced by their edges. So for example if we had a canvas that was 3x2 pixels big then
the value for <code class="notranslate" translate="no">gl_FragCoord</code> at the pixel 2
from the left and 1 from the bottom
would be 2.5, 1.5
</p>
<div class="webgl_center"><img src="resources/webgl-pixels.svg" style="width: 500px;"></div>
</div>
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-shadertoy.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Shadertoy';
            var disqus_title = 'WebGL2 Shadertoy';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-3d-orthographic.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="从正射投影开始讲 WebGL 中的三维">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-orthographic_zh-cn.jpg">

<meta property="og:title" content="WebGL2 - 三维正射投影">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-orthographic_zh-cn.jpg">
<meta property="og:description" content="从正射投影开始讲 WebGL 中的三维">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 - 三维正射投影">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html">
<meta name="twitter:description" content="从正射投影开始讲 WebGL 中的三维">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-orthographic_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-orthographic_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html",
      "inLanguage":"zh-cn",
      "name":"WebGL2 - 三维正射投影",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 - 三维正射投影</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-3d-orthographic.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-3d-orthographic.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-orthographic.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-orthographic.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-3d-orthographic.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-orthographic.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-orthographic.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-orthographic.html" >English</a>
    <option value="/webgl/lessons/de/webgl-3d-orthographic.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-3d-orthographic.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-orthographic.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-orthographic.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-3d-orthographic.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-orthographic.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 - 三维正射投影</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>此文上接一系列相关文章，首先是<a href="webgl-fundamentals.html">基础概念</a>，上一篇是
<a href="webgl-2d-matrices.html">二维矩阵运算</a>，如果没读过请从那里开始。</p>
<p>上一篇文章概述了二维矩阵的工作原理，我们讲到了如何平移，
旋转，缩放甚至从像素空间投影到裁剪空间，并且将这些操作通过一个矩阵实现，
做三维只需要再迈出一小步。</p>
<p>二维例子中的二维点 (x, y) 与 3x3 的矩阵相乘，
在三维中我们需要三维点 (x, y, z) 与 4x4 的矩阵相乘。</p>
<p>让我们将上个例子改成三维的，这里会继续使用 F ，但是这次是三维的 ‘F’ 。</p>
<p>首先需要修改顶点着色器以支持三维处理，这是原顶点着色器。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">#version 300 es

// 属性是输入(in)顶点着色器的，从缓冲区接收数据
in vec2 a_position;

// 一个用来转换位置的矩阵
uniform mat3 u_matrix;

// 所有着色器都有一个 main 函数
void main() {
  // 将位置和矩阵相乘
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
}
</code></pre>
<p>这是新着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">// 属性是输入(in)顶点着色器的，从缓冲区接收数据
*in vec4 a_position;

// 一个用来转换位置的矩阵
*uniform mat4 u_matrix;

// 所有着色器都有一个 main 函数
void main() {
  // 将位置和矩阵相乘
*  gl_Position = u_matrix * a_position;
}
</code></pre>
<p>它甚至变简单了！在二维中我们提供<code class="notranslate" translate="no">x</code>和<code class="notranslate" translate="no">y</code>并设置<code class="notranslate" translate="no">z</code>为 1，
在三维中我们将提供<code class="notranslate" translate="no">x</code>，<code class="notranslate" translate="no">y</code>和<code class="notranslate" translate="no">z</code>，然后将<code class="notranslate" translate="no">w</code>设置为 1,
而在属性中<code class="notranslate" translate="no">w</code>的默认值就是 1，我们可以利用这点不用再次设置。</p>
<p>然后提供三维数据。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  ...

  // 告诉属性怎么从 positionBuffer (ARRAY_BUFFER) 中读取位置
*  var size = 3;          // 每次迭代使用 3 个单位的数据
  var type = gl.FLOAT;   // 单位数据类型是32位的浮点型
  var normalize = false; // 不需要归一化数据
  var stride = 0;        // 0 = 移动距离 * 单位距离长度sizeof(type)  每次迭代跳多少距离到下一个数据
  var offset = 0;        // 从绑定缓冲的起始处开始
  gl.vertexAttribPointer(
      positionAttributeLocation, size, type, normalize, stride, offset);

  ...

  // 使用组成 'F' 的数据填充当前 ARRAY_BUFFER 缓冲
  function setGeometry(gl) {
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
            // 左竖
              0,   0,  0,
             30,   0,  0,
              0, 150,  0,
              0, 150,  0,
             30,   0,  0,
             30, 150,  0,

            // 上横
             30,   0,  0,
            100,   0,  0,
             30,  30,  0,
             30,  30,  0,
            100,   0,  0,
            100,  30,  0,

            // 下横
             30,  60,  0,
             67,  60,  0,
             30,  90,  0,
             30,  90,  0,
             67,  60,  0,
             67,  90,  0]),
        gl.STATIC_DRAW);
  }
</code></pre>
<p>接下来把二维矩阵方法改成三维的</p>
<p>这是二维（之前的）版本的 m3.translation, m3.rotation, 和 m3.scaling 方法</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var m3 = {
    translation: function translation(tx, ty) {
        return [1, 0, 0, 0, 1, 0, tx, ty, 1]
    },

    rotation: function rotation(angleInRadians) {
        var c = Math.cos(angleInRadians)
        var s = Math.sin(angleInRadians)
        return [c, -s, 0, s, c, 0, 0, 0, 1]
    },

    scaling: function scaling(sx, sy) {
        return [sx, 0, 0, 0, sy, 0, 0, 0, 1]
    }
}
</code></pre>
<p>这是升级到三维的版本。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var m4 = {
    translation: function (tx, ty, tz) {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]
    },

    xRotation: function (angleInRadians) {
        var c = Math.cos(angleInRadians)
        var s = Math.sin(angleInRadians)

        return [1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]
    },

    yRotation: function (angleInRadians) {
        var c = Math.cos(angleInRadians)
        var s = Math.sin(angleInRadians)

        return [c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]
    },

    zRotation: function (angleInRadians) {
        var c = Math.cos(angleInRadians)
        var s = Math.sin(angleInRadians)

        return [c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    },

    scaling: function (sx, sy, sz) {
        return [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]
    }
}
</code></pre>
<p>注意到我们现在有三个旋转方法，在二维中只需要一个是因为我们只需要绕 Z
轴旋转，现在在三维中还可以绕 X 轴和 Y 轴旋转。它们看起来还是很简单，
如果使用它们后你会发现和之前一样</p>
<p>绕 Z 轴旋转</p>
<div class="webgl_center">
<div>newX = x *  c + y * s;</div>
<div>newY = x * -s + y * c;</div>
</div>
<p>绕 Y 轴旋转</p>
<div class="webgl_center">
<div>newX = x *  c + z * s;</div>
<div>newZ = x * -s + z * c;</div>
</div>
<p>绕 X 轴旋转</p>
<div class="webgl_center">
<div>newY = y *  c + z * s;</div>
<div>newZ = y * -s + z * c;</div>
</div>
<p>它们提供这些旋转方式。</p>
<iframe class="external_diagram" src="../resources/axis-diagram.html" style="width: 540px; height: 240px;"></iframe>
<p>同样的我们将实现一些简单的方法</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  translate: function(m, tx, ty, tz) {
    return m4.multiply(m, m4.translation(tx, ty, tz));
  },

  xRotate: function(m, angleInRadians) {
    return m4.multiply(m, m4.xRotation(angleInRadians));
  },

  yRotate: function(m, angleInRadians) {
    return m4.multiply(m, m4.yRotation(angleInRadians));
  },

  zRotate: function(m, angleInRadians) {
    return m4.multiply(m, m4.zRotation(angleInRadians));
  },

  scale: function(m, sx, sy, sz) {
    return m4.multiply(m, m4.scaling(sx, sy, sz));
  },
</code></pre>
<p>我们需要一个 4x4 矩阵乘法函数</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  multiply: multiply(a, b) {
    var b00 = b[0 * 4 + 0];
    var b01 = b[0 * 4 + 1];
    var b02 = b[0 * 4 + 2];
    var b03 = b[0 * 4 + 3];
    var b10 = b[1 * 4 + 0];
    var b11 = b[1 * 4 + 1];
    var b12 = b[1 * 4 + 2];
    var b13 = b[1 * 4 + 3];
    var b20 = b[2 * 4 + 0];
    var b21 = b[2 * 4 + 1];
    var b22 = b[2 * 4 + 2];
    var b23 = b[2 * 4 + 3];
    var b30 = b[3 * 4 + 0];
    var b31 = b[3 * 4 + 1];
    var b32 = b[3 * 4 + 2];
    var b33 = b[3 * 4 + 3];
    var a00 = a[0 * 4 + 0];
    var a01 = a[0 * 4 + 1];
    var a02 = a[0 * 4 + 2];
    var a03 = a[0 * 4 + 3];
    var a10 = a[1 * 4 + 0];
    var a11 = a[1 * 4 + 1];
    var a12 = a[1 * 4 + 2];
    var a13 = a[1 * 4 + 3];
    var a20 = a[2 * 4 + 0];
    var a21 = a[2 * 4 + 1];
    var a22 = a[2 * 4 + 2];
    var a23 = a[2 * 4 + 3];
    var a30 = a[3 * 4 + 0];
    var a31 = a[3 * 4 + 1];
    var a32 = a[3 * 4 + 2];
    var a33 = a[3 * 4 + 3];

    return [
      b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
      b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
      b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
      b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
      b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
      b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
      b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
      b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
      b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
      b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
      b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
      b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
      b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
      b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
      b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
      b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,
    ];
  },
</code></pre>
<p>我们还需要更新投影方法，这是原代码</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  projection: function (width, height) {
    // 注意：这个矩阵翻转了 Y 轴，所以 0 在上方
    return [
      2 / width, 0, 0,
      0, -2 / height, 0,
      -1, 1, 1
    ];
  },
}
</code></pre>
<p>它将像素坐标转换到裁剪空间，在初次尝试三维时我们将这样做</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  projection: function(width, height, depth) {
    // 注意：这个矩阵翻转了 Y 轴，所以 0 在上方
    return [
       2 / width, 0, 0, 0,
       0, -2 / height, 0, 0,
       0, 0, 2 / depth, 0,
      -1, 1, 0, 1,
    ];
  },
</code></pre>
<p>就像 X 和 Y 需要从像素空间转换到裁剪空间一样，Z 也需要。
在这个例子中我也将 Z 单位化了，我会传递一些和 <code class="notranslate" translate="no">width</code> 相似的值给
<code class="notranslate" translate="no">depth</code> ，所以我们的空间将会是 0 到 <code class="notranslate" translate="no">width</code> 像素宽，0 到 <code class="notranslate" translate="no">height</code> 像素高，
但是对于<code class="notranslate" translate="no">depth</code>将会是 <code class="notranslate" translate="no">-depth / 2</code> 到 <code class="notranslate" translate="no">+depth / 2</code> 。</p>
<p>最后需要更新计算矩阵的代码</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // 计算矩阵
*  var matrix = m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400);
*  matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);
*  matrix = m4.xRotate(matrix, rotation[0]);
*  matrix = m4.yRotate(matrix, rotation[1]);
*  matrix = m4.zRotate(matrix, rotation[2]);
*  matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);

  // 设置矩阵
*  gl.uniformMatrix4fv(matrixLocation, false, matrix);
</code></pre>
<p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step1.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step1.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>我们遇到的第一个问题是 F 在三维中过于扁平，
所以很难看出三维效果。解决这个问题的方法是将它拉伸成三维几何体。
现在的 F 是由三个矩形组成，每个矩形两个三角形。让它变三维需要 16 个矩形。
三个矩形在正面，三个背面，一个左侧，四个右侧，两个上侧，三个底面。</p>
<img class="webgl_center noinvertdark" width="300" src="../resources/3df.svg" />
<p>需要列出的还有很多，16 个矩形每个有两个三角形，每个三角形有 3 个顶点，
所以一共有 96 个顶点。如果你想看这些可以去示例的源码里找。</p>
<p>我们需要绘制更多顶点所以</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">    // 绘制几何体
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
*    var count = 16 * 6;
    gl.drawArrays(primitiveType, offset, count);
</code></pre>
<p>这是对应结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step2.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step2.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>拖动滑块很难看出它是三维的，让我们给矩形上不同的颜色。
需要在顶点着色器中添加一个属性和一个可变量，
将颜色值传到片断着色器中。</p>
<p>这是新的顶点着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es

// 属性是输入(in)顶点着色器的，从缓冲区接收数据
in vec4 a_position;
+in vec4 a_color;

// 定义一个用来转换位置的矩阵
uniform mat4 u_matrix;

+// 定义一个传递给片段着色器的颜色变量
+out vec4 v_color;

// 所有着色器都有一个 main 函数
void main() {
  // 将位置和矩阵相乘
  gl_Position = u_matrix * a_position;

+  // 将颜色传递给片段着色器
+  v_color = a_color;
}
</code></pre>
<p>然后在片断着色器中使用颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es

precision highp float;

+// 从顶点着色器传递过来颜色
+in vec4 v_color;

// 我们需要为片段着色器声明一个输出
out vec4 outColor;

void main() {
*  outColor = v_color;
}
</code></pre>
<p>我们需要找到属性的位置，然后在另一个缓冲中存入对应的颜色。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  ...
  var colorAttributeLocation = gl.getAttribLocation(program, &quot;a_color&quot;);

  ...

  // 创建颜色缓冲区，将其与当前的 ARRAY_BUFFER 绑定
  var colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  setColors(gl);

  // 启用颜色属性
  gl.enableVertexAttribArray(colorAttributeLocation);

  // 告诉颜色属性怎么从 colorBuffer (ARRAY_BUFFER) 中读取颜色值
  var size = 3;          // 每次迭代使用3个单位的数据
  var type = gl.UNSIGNED_BYTE;   // 单位数据类型是无符号 8 位整数
  var normalize = true;  // 标准化数据 (从 0-255 转换到 0.0-1.0)
  var stride = 0;        // 0 = 移动距离 * 单位距离长度sizeof(type)  每次迭代跳多少距离到下一个数据
  var offset = 0;        // 从绑定缓冲的起始处开始
  gl.vertexAttribPointer(
      colorAttributeLocation, size, type, normalize, stride, offset);

  ...

// 向缓冲传入 'F' 的颜色值

function setColors(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Uint8Array([
          // 正面左竖
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,
        200,  70, 120,

          // 正面上横
        200,  70, 120,
        200,  70, 120,
        ...
        ...
      gl.STATIC_DRAW);
}
</code></pre>
<p>现在我们得到这个。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step3.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step3.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>呃，发生了什么？它好像把 ‘F’ 的所有部分都按照提供的顺序显示出来了，
正面，背面，侧面等等。有时候这并不是想要的结果，在背面的物体反而被绘制出来了。</p>
<img class="webgl_center" style="background-color: transparent;" width="163" height="190" src="../resources/polygon-drawing-order.gif" />
<p><span style="background: rgb(200, 70, 120); color: white; padding: 0.25em">红色部分</span>是 ‘F’ 的<strong>正面</strong>，但是因为它在数据的前部所以最先被绘制出来，然后它后面的面绘制后挡住了它。
例如<span style="background: rgb(80, 70, 200); color: white; padding: 0.25em">紫色部分</span>
实际上是 ‘F’ 的背面，由于它在数据中是第二个所以第二个被画出来。</p>
<p>WebGL 中的三角形有正反面的概念，正面三角形的顶点顺序是逆时针方向，
反面三角形是顺时针方向。</p>
<img src="../resources/triangle-winding.svg" class="webgl_center" width="400" />
<p>WebGL 可以只绘制正面或反面三角形，可以这样开启</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.enable(gl.CULL_FACE)
</code></pre>
<p>将它放在 <code class="notranslate" translate="no">drawScene</code> 方法里，开启这个特性后 WebGL 默认“剔除”背面三角形，
&quot;剔除&quot;在这里是“不用绘制”的花哨叫法。</p>
<p>对于 WebGL 而言，一个三角形是顺时针还是逆时针是根据裁剪空间中的顶点顺序判断的，
换句话说，WebGL 是根据你在顶点着色器中运算后提供的结果来判定的，
这就意味着如果你把一个顺时针的三角形沿 X 轴缩放 -1 ，它将会变成逆时针，
或者将顺时针的三角形旋转 180 度后变成逆时针。由于我们没有开启 CULL_FACE，
所以可以同时看到顺时针（正面）和逆时针（反面）三角形。现在开启了，
任何时候正面三角形无论是缩放还是旋转的原因导致翻转了，WebGL 就不会绘制它。
这件事很有用，因为通常情况下你只需要看到你正面对的面。</p>
<p>开启 CULL_FACE 后得到</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step4.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step4.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>嗨！三角形都去哪了？结果证明，大多数三角形朝向都是错的，
旋转的时候你会看到背面的三角形，幸好它很容易解决，
我们只需要看看哪些是三角形是反的，然后交换它们的两个顶点。
例如一个反的三角形</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">           1,   2,   3,
          40,  50,  60,
         700, 800, 900,
</code></pre>
<p>只需要交换后两个顶点的位置</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">           1,   2,   3,
*         700, 800, 900,
*          40,  50,  60,
</code></pre>
<p>通过修正朝向错误后得到</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step5.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step5.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>这很接近实际效果了但是还有一个问题，即使所有三角形的朝向是正确的，
然后背面的被剔除了，有些应该在背面的部分还是出现在了前面。</p>
<p>接触 DEPTH BUFFER（深度缓冲）。</p>
<p>深度缓冲有时也叫 Z-Buffer，是一个存储像素深度的矩形，
一个深度像素对应一个着色像素，在绘制图像时组合使用。
当 WebGL 绘制每个着色像素时也会写入深度像素，
它的值基于顶点着色器返回的 Z 值，就像我们将 X 和 Y 转换到裁剪空间一样，
Z 也在裁剪空间或者 (-1 到 +1) 。这个值会被转换到深度空间( 0 到 +1)，
WebGL 绘制一个着色像素之前会检查对应的深度像素，
如果对应的深度像素中的深度值小于当前像素的深度值，WebGL 就不会绘制新的颜色。
反之它会绘制片断着色器提供的新颜色并更新深度像素中的深度值。
这也意味着在其他像素后面的像素不会被绘制。</p>
<p>我们可以像这样开启这个特性</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.enable(gl.DEPTH_TEST)
</code></pre>
<p>在开始绘制前还需要清除深度缓冲为 1.0 。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // 绘制场景
  function drawScene() {

    ...

    // 清空画布和深度缓冲
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    ...
</code></pre>
<p>现在得到</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-step6.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-step6.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>这才是三维！</p>
<p>还有一件小事，在大多数三维数学库中没有负责像素空间与裁剪空间转换的 <code class="notranslate" translate="no">projection</code> 方法。
代替的是叫做 <code class="notranslate" translate="no">ortho</code> 或 <code class="notranslate" translate="no">orthographic</code> 的方法，它看起来像这样</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var m4 = {
  orthographic: function(left, right, bottom, top, near, far) {
    return [
      2 / (right - left), 0, 0, 0,
      0, 2 / (top - bottom), 0, 0,
      0, 0, 2 / (near - far), 0,

      (left + right) / (left - right),
      (bottom + top) / (bottom - top),
      (near + far) / (near - far),
      1,
    ];
  }
</code></pre>
<p>和我们简单的 <code class="notranslate" translate="no">projection</code> 方法不同的是正射投影有更多的参数可以传递，
左，右，上，下，近和远，给我们更灵活的选择。为了用这个方法实现之前的投影，
需要这样调用</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var left = 0;
var right = gl.canvas.clientWidth;
var bottom = gl.canvas.clientHeight;
var top = 0;
var near = 200;
var far = -200;
m4.orthographic(left, right, bottom, top, near, far);
</code></pre>
<p>下一篇将讲述<a href="webgl-3d-perspective.html">如何实现透视投影</a>。</p>
<div class="webgl_bottombar">
<h3>为什么属性类型是 vec4 但是 gl.vertexAttribPointer 的大小是 3</h3>
<p>
注意细节的你可能发现，我们定义了这样两个属性
</p>
<pre class="prettyprint showlinemods">
in vec4 a_position;
in vec4 a_color;
</pre>
<p>两个都是 'vec4' 类型，当我们告诉WebGL如何从缓冲中获取数据时使用</p>
<pre class="prettyprint showlinemods">
// 告诉属性怎么从 positionBuffer (ARRAY_BUFFER) 中读取位置
var size &#x3D; 3;          // 每次迭代使用 3 个单位的数据
var type &#x3D; gl.FLOAT;   // 单位数据类型是32位的浮点型
var normalize &#x3D; false; // 不需要归一化数据
var stride &#x3D; 0;        // 0 &#x3D; 移动距离 * 单位距离长度sizeof(type)
                       // 每次迭代跳多少距离到下一个数据
var offset &#x3D; 0;        // 从绑定缓冲的起始处开始
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset);

...
// 告诉颜色属性怎么从 colorBuffer (ARRAY_BUFFER) 中读取颜色值
var size &#x3D; 3; // 每次迭代使用 3 个单位的数据
var type &#x3D; gl.UNSIGNED_BYTE; // 单位数据类型是无符号 8 位整数
var normalize &#x3D; true; // 标准化数据 (从 0-255 转换到 0.0-1.0)
var stride &#x3D; 0; // 0 &#x3D; 移动距离 \* 单位距离长度 sizeof(type)
// 每次迭代跳多少距离到下一个数据
var offset &#x3D; 0; // 从绑定缓冲的起始处开始
gl.vertexAttribPointer(
colorAttributeLocation, size, type, normalize, stride, offset);

</pre>
<p>
这里的 '3' 表示的时每次迭代从缓冲中提取三个值给顶点着色器中的属性。
能正常运行是因为WebGL会给这些值设定默认值，默认值是0, 0, 0, 1
也就是 x = 0, y = 0, z = 0 和 w = 1 。我们需要传入 x 和 y 并且需要 z 是 1 ，
由于 z 的默认值是 0 所以我们需要额外提供 z 值，对于三维，即使我们没有提供 'w'，
默认的 1 正是矩阵运算需要的值。
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-orthographic.html" >English</a>
    <option value="/webgl/lessons/de/webgl-3d-orthographic.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-3d-orthographic.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-orthographic.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-orthographic.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-3d-orthographic.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-orthographic.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-getting-webgl2.html">怎样使用WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">基本原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">如何工作的</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">着色器和 GLSL 语言</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html?lang=zh_cn">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl2-whats-new.html">WebGL2有什么新内容</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2.html">迁移WebGL1到WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org和WebGL2Fundamentals.org的区别</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">三维相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-naming.html">WebGL2 三维矩阵命名</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">二维 DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL2 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL2 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL2 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL2 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL2 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">拾取（点击物体）</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">文字 - 二维 Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">文字 - 使用字形纹理</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">通用GPU计算(GPGPU)</a></li>
        </ul>
        </ul>
  <li>技巧</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">无数据绘制</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">顶点拉取</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">点、线段与三角形</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">多视图与多画布</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">可视化相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL2 和 Alpha</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">反模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL2中的矩阵vs数学中的矩阵</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">精度问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">跨平台问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">属性（Attributes）</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">纹理单元（Texture Units）</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">帧缓冲区（Framebuffers）</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">参考资料</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL，一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>有意见或建议? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">在GitHub上提issue</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 - 三维正射投影';
            var disqus_title = 'WebGL2 - 三维正射投影';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 个贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-skinning.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="在WebGL中如何蒙皮网格">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_zh-cn.jpg">

<meta property="og:title" content="WebGL2 蒙皮">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_zh-cn.jpg">
<meta property="og:description" content="在WebGL中如何蒙皮网格">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 蒙皮">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html">
<meta name="twitter:description" content="在WebGL中如何蒙皮网格">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-skinning_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html",
      "inLanguage":"zh-cn",
      "name":"WebGL2 蒙皮",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 蒙皮</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-skinning.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-skinning.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-skinning.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-skinning.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-skinning.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" >English</a>
    <option value="/webgl/lessons/de/webgl-skinning.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 蒙皮</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>图形学中的蒙皮是根据多矩阵的加权影响来移动一组顶点。这很抽象。</p>
<p>它被称为<em>蒙皮</em>因为通常使3D角色拥有由骨骼“bone”组成的骨架“skeleton”，在这里骨骼“bone”是矩阵的另一种表述方式，并对<strong>每个顶点</strong>设置每个骨骼对该顶点的影响。</p>
<p>举个例子一个角色手部的骨骼对于靠近手的顶点的影响几乎是100%，脚部的骨骼对于这些顶点则不会有影响。手腕附近的顶点会受手骨一些影响还会受臂骨一些影响。</p>
<p>基本你需要骨骼(这只是矩阵层级的一种奇妙描述方法)和权重。权重是每个顶点从0到1的值表示某一骨骼矩阵对此顶点位置的影响程度。至于数据，权重有点像顶点颜色。每个顶点有一组权重。换句话说权重放在缓冲中通过属性提供。</p>
<p>通常你限制每个顶点的一部分权重数量，因为否则会有太多的数据。一个角色可拥有位于任何地方的15个骨骼(VR 战士1)到150-300个骨骼(许多现代游戏)。
如果你有300个骨骼，那么每个顶点需要300个权重对应300个骨骼。如果你有10000个顶点就会需要3百万个权重。</p>
<p>所以，大多数实时蒙皮系统限制每个顶点~4个权重。通常这是在导出器／转换器中完成的，从像blender／maya／3dsmax的3D软件包中获取数据，并对于每个顶点找到最大的四个权重并归一化这些权重。</p>
<p>伪代码示例，非蒙皮顶点通常会像这样计算</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl_Position = projection * view * model * position;
</code></pre><p>蒙皮顶点像这样被有效计算</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl_Position = projection * view *
              (bone1Matrix * position * weight1 +
               bone2Matrix * position * weight2 +
               bone3Matrix * position * weight3 +
               bone4Matrix * position * weight4);
</code></pre><p>正如你看到的那样，每个顶点计算四个不同的位置，然后通过应用权重融合成一个。</p>
<p>假设你将骨骼矩阵存储在全局变量数组中, 并且通过属性传入权重以及是哪个骨骼的权重，你应该会这样做</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_position;
in vec4 a_weights;         // 每个顶点4个权重
in uvec4 a_boneNdx;        // 4个骨骼下标
uniform mat4 bones[MAX_BONES];  // 每个骨骼1个矩阵

gl_Position = projection * view *
              (a_bones[a_boneNdx[0]] * a_position * a_weight[0] +
               a_bones[a_boneNdx[1]] * a_position * a_weight[1] +
               a_bones[a_boneNdx[2]] * a_position * a_weight[2] +
               a_boneS[a_boneNdx[3]] * a_position * a_weight[3]);
</code></pre><p>这还有一个问题。假设你有一个人的模型，原点(0,0,0)在两脚之间的地上。</p>
<div class="webgl_center"><img src="../resources/bone-head.svg" style="width: 500px;"></div>

<p>假设你放一个矩阵matrix/骨骼bone/关节joint在头的位置，并想用它作为蒙皮的骨骼。简单起见，假设你只设定了头部的顶点有1.0的权重对于头部骨骼，其他地方的关节不影响这些顶点。</p>
<div class="webgl_center"><img src="../resources/bone-head-setup.svg" style="width: 500px;"></div>

<p>这会有一个问题。头部顶点在原点上方2个单位。头部骨骼也在原点上方2个单位。如果你真的将头部顶点和头部骨骼矩阵相乘，你将得到原点上方4个单位的顶点位置。原本顶点的2个单位 + 头部骨骼矩阵的2个单位。</p>
<div class="webgl_center"><img src="../resources/bone-head-problem.svg" style="width: 500px;"></div>

<p>一种解决方案是存储&quot;绑定姿势&quot;，这是每个关节的额外矩阵，你用矩阵来作用于顶点位置之前的位置。这个例子，头部矩阵的绑定姿势比原点高2个单位。所以现在你可以使用该矩阵的逆来减去额外的2个矩阵。</p>
<p>换句话说，传递给着色器的骨骼矩阵每个都乘以了他们的绑定姿势的逆矩阵，以便只影响从原有位置的变化，相对于网格原点。</p>
<p>我们举一个例子。我们将制作像这样的格子动画</p>
<div class="webgl_center"><img src="../resources/skinned-mesh.svg" style="width: 400px;"></div>

<ul>
<li><code class="notranslate" translate="no">b0</code>, <code class="notranslate" translate="no">b1</code>和 <code class="notranslate" translate="no">b2</code>是骨骼矩阵。</li>
<li><code class="notranslate" translate="no">b1</code>是<code class="notranslate" translate="no">b0</code>的子，<code class="notranslate" translate="no">b2</code>是<code class="notranslate" translate="no">b1</code>的子</li>
<li>点<code class="notranslate" translate="no">0,1</code>对于骨骼b0的权重为1.0 </li>
<li>点<code class="notranslate" translate="no">2,3</code>对于骨骼b0和骨骼b1的权重都为0.5</li>
<li>点<code class="notranslate" translate="no">4,5</code>对于骨骼b1的权重为1.0 </li>
<li>点<code class="notranslate" translate="no">6,7</code>对于骨骼b1和骨骼b2的权重都为0.5 </li>
<li>点<code class="notranslate" translate="no">8,9</code>对于骨骼b2的权重为1.0</li>
</ul>
<p>我们会使用<a href="webgl-less-code-more-fun.html">码少趣多</a>文章中介绍的utils。</p>
<p>首先我们需要顶点位置和影响每个顶点的每个骨骼下标以及0到1的数字权重表示这个骨骼的影响量。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const arrays = {
  position: {
    numComponents: 2,
    data: [
    0,  1,  // 0
    0, -1,  // 1
    2,  1,  // 2
    2, -1,  // 3
    4,  1,  // 4
    4, -1,  // 5
    6,  1,  // 6
    6, -1,  // 7
    8,  1,  // 8
    8, -1,  // 9
    ],
  },
  boneNdx: {
    numComponents: 4,
    data: new Uint8Array([
      0, 0, 0, 0,  // 0
      0, 0, 0, 0,  // 1
      0, 1, 0, 0,  // 2
      0, 1, 0, 0,  // 3
      1, 0, 0, 0,  // 4
      1, 0, 0, 0,  // 5
      1, 2, 0, 0,  // 6
      1, 2, 0, 0,  // 7
      2, 0, 0, 0,  // 8
      2, 0, 0, 0,  // 9
    ]),
  },
  weight: {
    numComponents: 4,
    data: [
    1, 0, 0, 0,  // 0
    1, 0, 0, 0,  // 1
    .5,.5, 0, 0,  // 2
    .5,.5, 0, 0,  // 3
    1, 0, 0, 0,  // 4
    1, 0, 0, 0,  // 5
    .5,.5, 0, 0,  // 6
    .5,.5, 0, 0,  // 7
    1, 0, 0, 0,  // 8
    1, 0, 0, 0,  // 9
    ],
  },

  indices: {
    numComponents: 2,
    data: [
      0, 1,
      0, 2,
      1, 3,
      2, 3, //
      2, 4,
      3, 5,
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  },
};
// 调用gl.createBuffer, gl.bindBuffer, gl.bufferData
const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
const skinVAO = twgl.createVAOFromBufferInfo(gl, programInfo, bufferInfo);
</code></pre><p>我们定义全局变量包括对应每个骨骼的矩阵</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 4个矩阵, 每个骨骼一个
const numBones = 4;
const boneArray = new Float32Array(numBones * 16);

var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
  bones: boneArray,
  color: [1, 0, 0, 1],
};
</code></pre><p>在boneArray中创建视图，每个矩阵一个</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 为所有骨骼创建视图
// 在一个数组中以便上传，但是是分割的
// 数学计算用到的数组
const boneMatrices = [];  // 全局变量数据
const bones = [];         // 乘以绑定矩阵的逆之前的值
const bindPose = [];      // 绑定矩阵
for (let i = 0; i &lt; numBones; ++i) {
  boneMatrices.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
  bindPose.push(m4.identity());  // 仅仅分配存储空间
  bones.push(m4.identity());     // 仅仅分配存储空间
}
</code></pre><p>接下来是一些计算骨骼矩阵的代码。我们仅仅是在层级中旋转他们就像手指的骨头一样。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 旋转每个骨骼角度，模拟一个层级
function computeBoneMatrices(bones, angle) {
  const m = m4.identity();
  m4.zRotate(m, angle, bones[0]);
  m4.translate(bones[0], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[1]);
  m4.translate(bones[1], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[2]);
  // bones[3]没有用到
}
</code></pre><p>现在调用一次来生成他们的初始位置（绑定姿势），用结果来计算绑定姿势矩阵的逆。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 计算每个矩阵的初始位置
computeBoneMatrices(bindPose, 0);

// 计算他们的逆
const bindPoseInv = bindPose.map(function(m) {
  return m4.inverse(m);
});
</code></pre><p>现在我们可以开始渲染</p>
<p>首先我们为骨骼设置动画，为每个骨骼计算一个新的世界矩阵</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const t = time * 0.001;
const angle = Math.sin(t) * 0.8;
computeBoneMatrices(bones, angle);
</code></pre><p>之后我们将结果乘以绑定姿势的逆来解决之前提到的问题</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 每个都乘以绑定矩阵的逆
bones.forEach((bone, ndx) =&gt; {
  m4.multiply(bone, bindPoseInv[ndx], boneMatrices[ndx]);
});
</code></pre><p>然后就是所有常规的步骤，设置属性，设置全局变量，渲染</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(programInfo.program);

gl.bindVertexArray(skinVAO);

// 调用gl.uniformXXX, gl.activeTexture, gl.bindTexture
twgl.setUniforms(programInfo, uniforms);

// 调用gl.drawArrays or gl.drawIndices
twgl.drawBufferInfo(gl, bufferInfo, gl.LINES);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>红线是<em>蒙皮</em>网格。绿线和蓝线分别代表每个骨骼或者“关节”的x轴和y轴。你可以看到顶点是如何受多个骨骼影响并在他们之间移动的。我们没有介绍如何绘制骨骼，因为它对于解释蒙皮怎么工作不重要。如果你感兴趣参见代码。</p>
<p>注意: 骨骼bones vs 关节joints 让人迷惑。都指的是1件事情，<em>矩阵</em>。
但是，在3d模型包中通常画一个gizmo(一个ui部件)
在矩阵之间。最终看起来像骨骼一样。关节是矩阵所处的位置，他们从一个关节到下一个画一条线或锥体使它看起来像一个骨架。</p>
<div class="webgl_center">
  <img src="../resources/bone-display.png" style="width: 351px;">
  <div class="caption"><a href="https://www.blendswap.com/blends/view/66412">LowPoly Man</a> by <a href="https://www.blendswap.com/user/TiZeta">TiZeta</a></div>
</div>

<p>另一个需要注意的小事，上面的例子权重和骨骼下标使用的是浮点数，可以使用<code class="notranslate" translate="no">UNSIGNED_BYTE</code>来节省一些空间。</p>
<p>不幸的是着色器中可以使用的全局变量的数量是有限制的。对WebGL比较低的限制是64个vec4，即8个mat4 你可能需要一些全局变量用于其他的事情像片断着色器中的<code class="notranslate" translate="no">color</code> 以及<code class="notranslate" translate="no">projection</code>和<code class="notranslate" translate="no">view</code>这意味着如果我们在一个限制为64个vec4的设备上，我们只能有5个骨骼！查看
<a href="https://web3dsurvey.com/webgl/parameters/MAX_VERTEX_UNIFORM_VECTORS">WebGLStats</a>
大多数设备支持128个vec4，其中70%支持256个vec4 但是对于上面的例子，这分别只有13个骨骼和29个骨骼。13对于90年代VR战士1风格的角色尚且不够，29与现代游戏中使用的数字相距甚远。</p>
<p>关于这个问题有很多方法。一个是离线预处理模型并打破它们为多个部分，每个使用不超过N个骨骼。这很复杂并带来了自身的一系列问题。</p>
<p>另一种是将骨骼矩阵存储在纹理中。一个重要的启示纹理不仅仅是图片，它们实际上是你可以传递给着色器的随机访问的2D数组数据，你可以使用它们做各种事情，不仅仅是读取图像。</p>
<p>让我们用纹理传递矩阵来绕过全局变量的限制问题。让其简单我们准备使用浮点型纹理。</p>
<p>让我们更新着色器从纹理中获取矩阵。
我们会制作每行一个矩阵的纹理。纹理的每个纹素texel
有R，G，B和A，这是4个值所以每个矩阵我们只需4个像素，一个像素对应矩阵的每一行。纹理在某一纬度上的限制通常至少2048个像素，所以这会给我们至少2048的骨骼矩阵的空间，这已足够。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_position;
in vec4 a_weight;
in uvec4 a_boneNdx;

uniform mat4 projection;
uniform mat4 view;
*uniform sampler2D boneMatrixTexture;

+mat4 getBoneMatrix(uint boneNdx) {
+  return mat4(
+    texelFetch(boneMatrixTexture, ivec2(0, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(1, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(2, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(3, boneNdx), 0));
+}

void main() {

  gl_Position = projection * view *
*                (getBoneMatrix(a_boneNdx[0]) * a_position * a_weight[0] +
*                 getBoneMatrix(a_boneNdx[1]) * a_position * a_weight[1] +
*                 getBoneMatrix(a_boneNdx[2]) * a_position * a_weight[2] +
*                 getBoneMatrix(a_boneNdx[3]) * a_position * a_weight[3]);

}
</code></pre><p>注意我们使用<code class="notranslate" translate="no">texelFetch</code>代替<code class="notranslate" translate="no">texture</code>从纹理中获取数据。<code class="notranslate" translate="no">texelFetch</code>从纹理中取回一个单独的纹素。参数为sampler，纹理纹素坐标x，y的整数向量ivec2 ，和mip的层级。像这样</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 data = texelFetch(sampler2D, ivec2(x, y), lod);
</code></pre><p>现在我们设定一个放入骨骼矩阵的纹理</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// p准备纹理来存骨骼矩阵
const boneMatrixTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
// 因为我们希望使用纹理的原始数据
// 我们关闭筛选
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre><p>我们会用全局变量传递纹理。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
*  boneMatrixTexture,
  color: [1, 0, 0, 1],
};
</code></pre><p>然后我们唯一需要改变的是在渲染时用最新的骨骼矩阵更新纹理</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 用此时的矩阵更新纹理
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,          // 层级
    gl.RGBA32F, // 内部格式
    4,          // 4像素宽,每个像素RGBA4个通道所以4像素是16个值
    numBones,   // 每个骨骼一行
    0,          // 边框
    gl.RGBA,    // 格式
    gl.FLOAT,   // 类型
    boneArray);
</code></pre><p>结果是一样的，但我们已经解决了没有足够的全局变量来传递矩阵的问题</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-bone-matrices-in-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-bone-matrices-in-texture.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>所以这就是蒙皮的基础知识。写呈现蒙皮网格的代码并不困难。更困难的部分实际上是获取数据。你通常需要一些3D软件像blender/maya/3d studio max，然后要么写你自己的导出器或者找到一个导出器提供所有你需要的数据。你会看到像我们介绍的一样加载蒙皮相较于展示它会有10倍多的代码，这还不包括大约20-30倍多的代码从3D程序中导出的导出器。题外话这部分通常是人们写他们的3D引擎通常忽略的。引擎是简单的部分😜</p>
<p>将会有很多代码，所以让我们先尝试显示未蒙皮的模型。</p>
<p>让我们尝试加载一个glTF文件。 <a href="https://www.khronos.org/gltf/">glTF</a>是为WebGL而设计的。在网上我找到了这个<a href="https://www.blendswap.com/blends/view/65255">虎鲸文件</a>是<a href="https://www.blendswap.com/user/pasilan">Junskie Pastilan</a>制作的。</p>
<div class="webgl_center"><img src="../../resources/models/killer_whale/thumbnail.jpg"></div>

<p>glTF有两种格式。<code class="notranslate" translate="no">.gltf</code>格式是一个JSON文件通常引用一个 <code class="notranslate" translate="no">.bin</code>文件，这是一个二进制文件通常只包含几何体，可能包含动画数据。另一种格式是<code class="notranslate" translate="no">.glb</code>二进制格式。通常是JSON和其他文件连接到一个二进制文件内，每个连接部分之间有一个短头和一个大小／类型描述。对于JavaScript，我认为<code class="notranslate" translate="no">.gltf</code>格式稍微容易上手，所以让我们尝试加载它。</p>
<p>首先我下载了<a href="https://www.blendswap.com/blends/view/65255">.blend文件</a>，安装<a href="https://blender.org">blender</a>，安装<a href="https://github.com/KhronosGroup/glTF-Blender-IO">gltf导出器</a>，blender中加载文件并导出。</p>
<div class="webgl_center"><img src="../resources/blender-killer-whale.png" style="width: 700px;" class="nobg"></div>

<blockquote>
<p>快速说明：3D软件像Blender，Maya，3DSMax是极其复杂的软件，有1000多种选项。当我在1996年第一次学习3DSMax时，我大约3周每天花2-3小时阅读1000多页的手册，通过教程工作。几年后，当我学习Maya时，我做了类似的事情。Blender同样复杂并且更甚它与几乎所有其他软件的界面非常不同。你应该花费一些时间来学习你决定使用的3D软件包。</p>
</blockquote>
<p>导出之后我用文本编辑器打开.gltf文件并浏览了一下。我用这个<a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">表</a>来弄清楚格式。</p>
<p>我想说明下面的代码不是一个完美的gltf加载器，只是足以展示鲸鱼的代码。我怀疑如果我们尝试不同的文件，我们会遇到需要更改的区域。</p>
<p>首先要做的事情是加载文件。简单起见，我们使用JavaScript的<a href="https://javascript.info/async-await">async/await</a>。首先我们写一些代码来加载<code class="notranslate" translate="no">.gltf</code> 文件和它引用的文件。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">async function loadGLTF(url) {
  const gltf = await loadJSON(url);

  // 加载所有gltf文件相关连的文件
  const baseURL = new URL(url, location.href);
  gltf.buffers = await Promise.all(gltf.buffers.map((buffer) =&gt; {
    const url = new URL(buffer.uri, baseURL.href);
    return loadBinary(url.href);
  }));

  ...

async function loadFile(url, typeFunc) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`could not load: ${url}`);
  }
  return await response[typeFunc]();
}

async function loadBinary(url) {
  return loadFile(url, &#39;arrayBuffer&#39;);
}

async function loadJSON(url) {
  return loadFile(url, &#39;json&#39;);
}
</code></pre><p>现在我们需要遍历数据将其连接起来。</p>
<p>首先让我们着手于glTF如何定义一个网格。网格是图元的集合。图元实际上是渲染所需的缓冲和属性。让我们使用<a href="webgl-less-code-more-fun.html">码少趣多</a>文章中介绍的<a href="https://twgljs.org">twgl库</a>。我们将遍历网格，为每个网格创建一个传递给<code class="notranslate" translate="no">twgl.createVAOFromBufferInfo</code>的<code class="notranslate" translate="no">BufferInfo</code>。回忆 <code class="notranslate" translate="no">BufferInfo</code>实际上只是属性信息，及下标如果有的话，和传递给<code class="notranslate" translate="no">gl.drawXXX</code>的元素数量。举个例子一个只有位置和法线的立方体会具有如下结构的BufferInfo</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const cubeBufferInfo = {
  attribs: {
    &#39;a_POSITION&#39;: { buffer: WebGLBuffer, type: gl.FLOAT, numComponents: 3, },
    &#39;a_NORMAL&#39;: { buffer: WebGLBuffer, type: gl.FLOAT, numComponents: 3, },
  },
  numElements: 24,
  indices: WebGLBuffer,
  elementType: gl.UNSIGNED_SHORT,
}
</code></pre><p>所以我们将遍历每个图元生成一个像这样的BufferInfo。</p>
<p>图元有一组属性，每个属性引用一个访问器。访问器描述是哪种数据，例如<code class="notranslate" translate="no">VEC3</code>/<code class="notranslate" translate="no">gl.FLOAT</code>并引用一个视图缓冲。给定一个访问器下标，我们可以编写一些代码来返回一个WebGLBuffer，其中包含加载的数据，访问器和，缓冲视图的stride。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 给定一个访问器下标返回一个访问器, WebGLBuffer和一个stride
function getAccessorAndWebGLBuffer(gl, gltf, accessorIndex) {
  const accessor = gltf.accessors[accessorIndex];
  const bufferView = gltf.bufferViews[accessor.bufferView];
  if (!bufferView.webglBuffer) {
    const buffer = gl.createBuffer();
    const target = bufferView.target || gl.ARRAY_BUFFER;
    const arrayBuffer = gltf.buffers[bufferView.buffer];
    const data = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, data, gl.STATIC_DRAW);
    bufferView.webglBuffer = buffer;
  }
  return {
    accessor,
    buffer: bufferView.webglBuffer,
    stride: bufferView.stride || 0,
  };
}
</code></pre><p>我们也需要一个将glTF访问器的type类型转换为数字的方法</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function throwNoKey(key) {
  throw new Error(`no key: ${key}`);
}

const accessorTypeToNumComponentsMap = {
  &#39;SCALAR&#39;: 1,
  &#39;VEC2&#39;: 2,
  &#39;VEC3&#39;: 3,
  &#39;VEC4&#39;: 4,
  &#39;MAT2&#39;: 4,
  &#39;MAT3&#39;: 9,
  &#39;MAT4&#39;: 16,
};

function accessorTypeToNumComponents(type) {
  return accessorTypeToNumComponentsMap[type] || throwNoKey(type);
}
</code></pre><p>现在我们已经创建了这些函数，我们可以使用他们来设置网格</p>
<p>注意：glTF文件可以定义材质，但是导出器并没有导出任何材质到文件内，即使已经勾选了导出材质的选项。我只能猜测在blender中导出器不处理任何材质。我们会使用默认材质如果文件中没有材质的话。因为这个文件中没有任何材质，这里没有使用glTF材质的代码。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const defaultMaterial = {
  uniforms: {
    u_diffuse: [.5, .8, 1, 1],
  },
};

// 设置网格
gltf.meshes.forEach((mesh) =&gt; {
  mesh.primitives.forEach((primitive) =&gt; {
    const attribs = {};
    let numElements;
    for (const [attribName, index] of Object.entries(primitive.attributes)) {
      const {accessor, buffer, stride} = getAccessorAndWebGLBuffer(gl, gltf, index);
      numElements = accessor.count;
      attribs[`a_${attribName}`] = {
        buffer,
        type: accessor.componentType,
        numComponents: accessorTypeToNumComponents(accessor.type),
        stride,
        offset: accessor.byteOffset | 0,
      };
    }

    const bufferInfo = {
      attribs,
      numElements,
    };

    if (primitive.indices !== undefined) {
      const {accessor, buffer} = getAccessorAndWebGLBuffer(gl, gltf, primitive.indices);
      bufferInfo.numElements = accessor.count;
      bufferInfo.indices = buffer;
      bufferInfo.elementType = accessor.componentType;
    }

    primitive.bufferInfo = bufferInfo;

    // 为图元创建一个VAO 
    primitive.vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, primitive.bufferInfo);

    // 存储此图元的材质信息
    primitive.material = gltf.materials &amp;&amp; gltf.materials[primitive.material] || defaultMaterial;
  });
});
</code></pre><p>现在每个图元都有一个<code class="notranslate" translate="no">bufferInfo</code>和一个<code class="notranslate" translate="no">material</code>属性。</p>
<p>对于蒙皮，我们通常需要某种场景图。我们在<a href="webgl-scene-graph.html">场景图</a>的文章中创建了一个场景图，所以让我们使用那个。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class TRS {
  constructor(position = [0, 0, 0], rotation = [0, 0, 0, 1], scale = [1, 1, 1]) {
    this.position = position;
    this.rotation = rotation;
    this.scale = scale;
  }
  getMatrix(dst) {
    dst = dst || new Float32Array(16);
    m4.compose(this.position, this.rotation, this.scale, dst);
    return dst;
  }
}

class Node {
  constructor(source, name) {
    this.name = name;
    this.source = source;
    this.parent = null;
    this.children = [];
    this.localMatrix = m4.identity();
    this.worldMatrix = m4.identity();
    this.drawables = [];
  }
  setParent(parent) {
    if (this.parent) {
      this.parent._removeChild(this);
      this.parent = null;
    }
    if (parent) {
      parent._addChild(this);
      this.parent = parent;
    }
  }
  updateWorldMatrix(parentWorldMatrix) {
    const source = this.source;
    if (source) {
      source.getMatrix(this.localMatrix);
    }

    if (parentWorldMatrix) {
      // 一个矩阵传入，所以做数学运算
      m4.multiply(parentWorldMatrix, this.localMatrix, this.worldMatrix);
    } else {
      // 没有矩阵传入，所以只是拷贝局部矩阵到世界矩阵
      m4.copy(this.localMatrix, this.worldMatrix);
    }

    // 现在处理所有子
    const worldMatrix = this.worldMatrix;
    for (const child of this.children) {
      child.updateWorldMatrix(worldMatrix);
    }
  }
  traverse(fn) {
    fn(this);
    for (const child of this.children) {
      child.traverse(fn);
    }
  }
  _addChild(child) {
    this.children.push(child);
  }
  _removeChild(child) {
    const ndx = this.children.indexOf(child);
    this.children.splice(ndx, 1);
  }
}
</code></pre><p>相较于<a href="webgl-scene-graph.html">场景图</a>文章中的代码有一些值的注意的变化。</p>
<ul>
<li><p>此代码使用ES6的<code class="notranslate" translate="no">class</code>特性。</p>
<p>使用<code class="notranslate" translate="no">class</code>语法比定义类的旧方法要好得多。</p>
</li>
<li><p>我们给<code class="notranslate" translate="no">Node</code>添加了要绘制的数组</p>
<p>这将列出从此节点要绘制的的物体。我们会用类的实例实际上来绘制。这个方法我们通常可以用不同的类绘制不同的物体。</p>
<p>注意：我不确定在Node里添加一个要绘制的数组是最好的方法。我觉得场景图本身应该可能不包含要绘制的物体。需要绘制的东西可改为图中节点的引用来获取数据。要绘制物体的方法比较常见所以让我们开始使用。</p>
</li>
<li><p>我们增加了一个<code class="notranslate" translate="no">traverse</code>方法。</p>
<p>它用当前节点调用传入的函数，并对子节点递归执行。</p>
</li>
<li><p><code class="notranslate" translate="no">TRS</code>类使用四元数进行旋转</p>
<p>我们并没有介绍过四元数，说实话我不认为我非常理解足以解释他们。幸运的是，我们用它们并不需要知道他们如何工作。我们只是从gltf文件中取出数据，调用一个函数它通过这些数据创建一个矩阵，使用该矩阵。</p>
</li>
</ul>
<p>glTF文件中的节点数据存储为数组。
我们会转换glTF文件中的节点数据为<code class="notranslate" translate="no">Node</code>实例。我们存储节点数据的旧数组为<code class="notranslate" translate="no">origNodes</code>，我们稍后会需要用它。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const origNodes = gltf.nodes;
gltf.nodes = gltf.nodes.map((n) =&gt; {
  const {name, skin, mesh, translation, rotation, scale} = n;
  const trs = new TRS(translation, rotation, scale);
  const node = new Node(trs, name);
  const realMesh =　gltf.meshes[mesh];
  if (realMesh) {
    node.drawables.push(new MeshRenderer(realMesh));
  }
  return node;
});
</code></pre><p>上面我们为每个节点创建一个<code class="notranslate" translate="no">TRS</code>实例，一个<code class="notranslate" translate="no">Node</code>实例，我们查找之前设置的网格数据，如果有<code class="notranslate" translate="no">mesh</code>属性的话，创建一个 <code class="notranslate" translate="no">MeshRenderer</code>来绘制它。</p>
<p>让我们来创建<code class="notranslate" translate="no">MeshRenderer</code>。它只是<a href="webgl-less-code-more-fun.html">码少趣多</a>文章中渲染单个模型代码的封装。它所做的就是存一个对于网格的引用，然后为每个图元设置程序，属性和全局变量，最终通过<code class="notranslate" translate="no">twgl.drawBufferInfo</code>调用<code class="notranslate" translate="no">gl.drawArrays</code>或者 <code class="notranslate" translate="no">gl.drawElements</code>;</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class MeshRenderer {
  constructor(mesh) {
    this.mesh = mesh;
  }
  render(node, projection, view, sharedUniforms) {
    const {mesh} = this;
    gl.useProgram(meshProgramInfo.program);
    for (const primitive of mesh.primitives) {
      gl.bindVertexArray(primitive.vao);
      twgl.setUniforms(meshProgramInfo, {
        u_projection: projection,
        u_view: view,
        u_world: node.worldMatrix,
      }, primitive.material.uniforms, sharedUniforms);
      twgl.drawBufferInfo(gl, primitive.bufferInfo);
    }
  }
}
</code></pre><p>我们已经创建了节点，现在我们需要将它们实际安排到场景图中。在glTF中2步完成。
首先，每个节点有一个可选的children属性，为子节点的下标数组，所以我们可以遍历所有节点为它们的子节点设定父节点。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function addChildren(nodes, node, childIndices) {
  childIndices.forEach((childNdx) =&gt; {
    const child = nodes[childNdx];
    child.setParent(node);
  });
}

// 将节点加入场景图
gltf.nodes.forEach((node, ndx) =&gt; {
  const children = origNodes[ndx].children;
  if (children) {
    addChildren(gltf.nodes, node, children);
  }
});
</code></pre><p>然后有一个场景的数组。一个场景有一个场景底部节点在nodes数组中下标的数组来引用这些节点。我不是很清楚为什么不简单地从单个根节点开始，但是无论如何这就是glTF文件中地内容。所以我们创建一个根节点，作为所有场景子节点的父节点。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // 设置场景
  for (const scene of gltf.scenes) {
    scene.root = new Node(new TRS(), scene.name);
    addChildren(gltf.nodes, scene.root, scene.nodes);
  }

  return gltf;
}
</code></pre><p>我们已经完成了加载，至少只是网格部分。让我们将主函数标记为<code class="notranslate" translate="no">async</code> 所以我们能使用<code class="notranslate" translate="no">await</code>关键字。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">async function main() {
</code></pre><p>我们可以像这样加载gltf文件</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const gltf = await loadGLTF(&#39;resources/models/killer_whale/whale.CYCLES.gltf&#39;);
</code></pre><p>我们需要一个与gltf文件中的数据匹配的着色器。让我们看看gltf文件中的图元数据。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">{
    &quot;name&quot; : &quot;orca&quot;,
    &quot;primitives&quot; : [
        {
            &quot;attributes&quot; : {
                &quot;JOINTS_0&quot; : 5,
                &quot;NORMAL&quot; : 2,
                &quot;POSITION&quot; : 1,
                &quot;TANGENT&quot; : 3,
                &quot;TEXCOORD_0&quot; : 4,
                &quot;WEIGHTS_0&quot; : 6
            },
            &quot;indices&quot; : 0
        }
    ]
}
</code></pre><p>看一下，我们只使用<code class="notranslate" translate="no">NORMAL</code>和<code class="notranslate" translate="no">POSITION</code>来渲染。我们在每个属性前添加了<code class="notranslate" translate="no">a_</code>，因此像这样的顶点着色器应该可以工作。 </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_POSITION;
in vec3 a_NORMAL;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

out vec3 v_normal;

void main() {
  gl_Position = u_projection * u_view * u_world * a_POSITION;
  v_normal = mat3(u_world) * a_NORMAL;
}
</code></pre><p>片断着色器中我们使用一个简单的平行光</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
precision highp float;

int vec3 v_normal;

uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;

out vec4 outColor;

void main () {
  vec3 normal = normalize(v_normal);
  float light = dot(u_lightDirection, normal) * .5 + .5;
  outColor = vec4(u_diffuse.rgb * light, u_diffuse.a);
}
</code></pre><p>注意我们使用了<a href="webgl-3d-lighting-directional.html">平行光</a>文章中提到的点乘，但与此不同，这里点乘结果乘以.5并加上.5。正常平行光照，当直接面向光源时，表面100%照亮，减弱到0%当表面方向和光照垂直。这意味着远离光线的模型的1/2是黑的。通过乘以.5并加上.5，我们将点乘从-1 &lt;-&gt; 1转换到0 &lt;-&gt; 1，这意味着当完全反方向时才会是黑色。这为简单测试提供了简单并很好的照明。</p>
<p>所以，我们需要编译和连接着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 编译和连接着色器，查找属性和全局变量的位置
const meshProgramInfo = twgl.createProgramInfo(gl, [meshVS, fs]);
</code></pre><p>接着渲染，所有和之前不同的地方是</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const sharedUniforms = {
  u_lightDirection: m4.normalize([-1, 3, 5]),
};

function renderDrawables(node) {
  for(const drawable of node.drawables) {
      drawable.render(node, projection, view, sharedUniforms);
  }
}

for (const scene of gltf.scenes) {
  // 更新场景中的世界矩阵。
  scene.root.updateWorldMatrix();
  // 遍历场景并渲染所有renderables
  scene.root.traverse(renderDrawables);
}
</code></pre><p>之前遗留下来的(未在上面显示)是用于计算投影矩阵，相机矩阵，和视图矩阵的代码。接下来我们遍历每个场景，调用<code class="notranslate" translate="no">scene.root.updateWorldMatrix</code>会更新场景图中所有节点的矩阵。然后我们为<code class="notranslate" translate="no">renderDrawables</code>调用<code class="notranslate" translate="no">scene.root.traverse</code>。</p>
<p><code class="notranslate" translate="no">renderDrawables</code>调用该节点上所有绘制对象的渲染方法，传入投影，视图矩阵，<code class="notranslate" translate="no">sharedUniforms</code>包含的光照信息。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-3d-gltf.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-3d-gltf.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>现在，这是我们处理蒙皮的工作。</p>
<p>首先让我们创建一个代表蒙皮的类。它将管理关节列表，关节是应用于蒙皮的场景图中节点的另一个名字。它还会有绑定矩阵的逆矩阵。它会管理我们放入关节矩阵的材质。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class Skin {
  constructor(joints, inverseBindMatrixData) {
    this.joints = joints;
    this.inverseBindMatrices = [];
    this.jointMatrices = [];
    // 为每个关节矩阵分配足够的空间
    this.jointData = new Float32Array(joints.length * 16);
    // 为每个关节和绑定逆矩阵创建视图
    for (let i = 0; i &lt; joints.length; ++i) {
      this.inverseBindMatrices.push(new Float32Array(
          inverseBindMatrixData.buffer,
          inverseBindMatrixData.byteOffset + Float32Array.BYTES_PER_ELEMENT * 16 * i,
          16));
      this.jointMatrices.push(new Float32Array(
          this.jointData.buffer,
          Float32Array.BYTES_PER_ELEMENT * 16 * i,
          16));
    }
    // 创建存储关节矩阵的纹理
    this.jointTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.jointTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }
  update(node) {
    const globalWorldInverse = m4.inverse(node.worldMatrix);
    // 遍历每个关节获得当前世界矩阵
    // 来计算绑定矩阵的逆 
    // 并在纹理中存储整个结果
    for (let j = 0; j &lt; this.joints.length; ++j) {
      const joint = this.joints[j];
      const dst = this.jointMatrices[j];
      m4.multiply(globalWorldInverse, joint.worldMatrix, dst);
      m4.multiply(dst, this.inverseBindMatrices[j], dst);
    }
    gl.bindTexture(gl.TEXTURE_2D, this.jointTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, 4, this.joints.length, 0,
                  gl.RGBA, gl.FLOAT, this.jointData);
  }
}
</code></pre><p>像<code class="notranslate" translate="no">MeshRenderer</code>一样，我们制作<code class="notranslate" translate="no">SkinRenderer</code>，来用<code class="notranslate" translate="no">Skin</code>来渲染蒙皮网格。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">class SkinRenderer {
  constructor(mesh, skin) {
    this.mesh = mesh;
    this.skin = skin;
  }
  render(node, projection, view, sharedUniforms) {
    const {skin, mesh} = this;
    skin.update(node);
    gl.useProgram(skinProgramInfo.program);
    for (const primitive of mesh.primitives) {
      gl.bindVertexArray(primitive.vao);
      twgl.setUniforms(skinProgramInfo, {
        u_projection: projection,
        u_view: view,
        u_world: node.worldMatrix,
        u_jointTexture: skin.jointTexture,
        u_numJoints: skin.joints.length,
      }, primitive.material.uniforms, sharedUniforms);
      twgl.drawBufferInfo(gl, primitive.bufferInfo);
    }
  }
}
</code></pre><p>你可以看到和 <code class="notranslate" translate="no">MeshRenderer</code>非常类似。它有一个<code class="notranslate" translate="no">Skin</code>的引用来更新所有渲染需要的矩阵。然后它后跟了渲染的标准模式，使用程序，设置属性，用<code class="notranslate" translate="no">webglUtils.setUniforms</code>设置全局变量，也绑定纹理，然后渲染。</p>
<p>我们也需要一个支持蒙皮的顶点着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const skinVS = `#version 300 es
in vec4 a_POSITION;
in vec3 a_NORMAL;
in vec4 a_WEIGHTS_0;
in uvec4 a_JOINTS_0;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform sampler2D u_jointTexture;
uniform float u_numJoints;

out vec3 v_normal;

mat4 getBoneMatrix(uint jointNdx) {
  return mat4(
    texelFetch(u_jointTexture, ivec2(0, jointNdx), 0),
    texelFetch(u_jointTexture, ivec2(1, jointNdx), 0),
    texelFetch(u_jointTexture, ivec2(2, jointNdx), 0),
    texelFetch(u_jointTexture, ivec2(3, jointNdx), 0));
}

void main() {
  mat4 skinMatrix = getBoneMatrix(a_JOINTS_0[0]) * a_WEIGHTS_0[0] +
                    getBoneMatrix(a_JOINTS_0[1]) * a_WEIGHTS_0[1] +
                    getBoneMatrix(a_JOINTS_0[2]) * a_WEIGHTS_0[2] +
                    getBoneMatrix(a_JOINTS_0[3]) * a_WEIGHTS_0[3];
  mat4 world = u_world * skinMatrix;
  gl_Position = u_projection * u_view * world * a_POSITION;
  v_normal = mat3(world) * a_NORMAL;
}
`;
</code></pre><p>这与我们之前介绍的蒙皮着色器几乎相同。我们重命名了属性值来匹配gltf文件中的内容。最大的不同是我们生成了一个 <code class="notranslate" translate="no">skinMatrix</code>。在我们之前的蒙皮着色器，我们将位置和每一个关节／骨骼矩阵相乘，并乘以每个关节的影响权重。在这个例子中，我们代替的将矩阵和权重相乘并相加，只乘以一次位置。这产生相同的结果，但是我们可以使用<code class="notranslate" translate="no">skinMatrix</code>和法线相乘，我们需要这样做否则法线会和蒙皮不匹配。</p>
<p>还要注意在这里我们用<code class="notranslate" translate="no">u_world</code>相乘。我们在<code class="notranslate" translate="no">Skin.update</code>里减去了它。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*const globalWorldInverse = m4.inverse(node.worldMatrix);
// 遍历每个关节，获得它当前的世界矩阵 
// 来计算绑定矩阵的逆
// 并在纹理中存储整个结果
for (let j = 0; j &lt; this.joints.length; ++j) {
  const joint = this.joints[j];
  const dst = this.jointMatrices[j];
*  m4.multiply(globalWorldInverse, joint.worldMatrix, dst);
</code></pre><p>无论你是否这样做取决于你。这样做的原因是它允许你实例化蒙皮。换句话说你可以在相同帧中在不同的地方渲染蒙皮网格。如果有很多的关节，对于一个蒙皮网格做所有的矩阵数学是非常慢的，所以你做一遍数学操作，然后你可以通过一个不同的世界矩阵将蒙皮网格重渲染在任何地方。</p>
<p>这对于显示一群角色是有效的。不幸的是所有的角色都会是相同的姿势，所以我并不清楚这是否有用。这种情况通常出现的频率是多少? 你可以在<code class="notranslate" translate="no">Skin</code>中移除乘以世界矩阵的逆并在着色器中移除乘以<code class="notranslate" translate="no">u_world</code>，结果是一样的，你仅仅不能<em>实例化</em> 那个蒙皮网格。当然你可以多次渲染不同姿势的同一蒙皮网格。你会需要一个不同的<code class="notranslate" translate="no">Skin</code>对象指向其他方向的不同节点。</p>
<p>回到我们的加载代码，当我们创建<code class="notranslate" translate="no">Node</code>实例时，如果有<code class="notranslate" translate="no">skin</code>属性，我们记录它，为了能为它创建一个<code class="notranslate" translate="no">Skin</code>。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+const skinNodes = [];
const origNodes = gltf.nodes;
gltf.nodes = gltf.nodes.map((n) =&gt; {
  const {name, skin, mesh, translation, rotation, scale} = n;
  const trs = new TRS(translation, rotation, scale);
  const node = new Node(trs, name);
  const realMesh =　gltf.meshes[mesh];
+  if (skin !== undefined) {
+    skinNodes.push({node, mesh: realMesh, skinNdx: skin});
+  } else if (realMesh) {
    node.drawables.push(new MeshRenderer(realMesh));
  }
  return node;
});
</code></pre><p>创建<code class="notranslate" translate="no">Node</code>之后我们需要创建<code class="notranslate" translate="no">Skin</code>。蒙皮通过<code class="notranslate" translate="no">joints</code>数组引用节点，该数组是为关节提供矩阵的节点下标数组。
蒙皮也引用一个访问器，访问器引用了保存在文件中的反向绑定姿势矩阵。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 设置蒙皮
gltf.skins = gltf.skins.map((skin) =&gt; {
  const joints = skin.joints.map(ndx =&gt; gltf.nodes[ndx]);
  const {stride, array} = getAccessorTypedArrayAndStride(gl, gltf, skin.inverseBindMatrices);
  return new Skin(joints, array);
});
</code></pre><p>上面的代码给定一个访问器下标，调用了<code class="notranslate" translate="no">getAccessorTypedArrayAndStride</code>。我们需要提供这部分的代码。给定一个访问器，我们会返回<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">类型化数组</a>的正确类型视图以访问缓冲中的数据。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const glTypeToTypedArrayMap = {
  &#39;5120&#39;: Int8Array,    // gl.BYTE
  &#39;5121&#39;: Uint8Array,   // gl.UNSIGNED_BYTE
  &#39;5122&#39;: Int16Array,   // gl.SHORT
  &#39;5123&#39;: Uint16Array,  // gl.UNSIGNED_SHORT
  &#39;5124&#39;: Int32Array,   // gl.INT
  &#39;5125&#39;: Uint32Array,  // gl.UNSIGNED_INT
  &#39;5126&#39;: Float32Array, // gl.FLOAT
}

// 给定一个GL类型返回需要的类型
function glTypeToTypedArray(type) {
  return glTypeToTypedArrayMap[type] || throwNoKey(type);
}

// 给定一个访问器下标返回访问器
// 和缓冲正确部分的类型化数组
function getAccessorTypedArrayAndStride(gl, gltf, accessorIndex) {
  const accessor = gltf.accessors[accessorIndex];
  const bufferView = gltf.bufferViews[accessor.bufferView];
  const TypedArray = glTypeToTypedArray(accessor.componentType);
  const buffer = gltf.buffers[bufferView.buffer];
  return {
    accessor,
    array: new TypedArray(
        buffer,
        bufferView.byteOffset + (accessor.byteOffset || 0),
        accessor.count * accessorTypeToNumComponents(accessor.type)),
    stride: bufferView.byteStride || 0,
  };
}
</code></pre><p>需要注意的是上面的代码我们用硬编码的WebGL常量制作了一个表。这是我们第一次这样做。常量不会改变，所以这是安全的。</p>
<p>现在我们有了蒙皮，我们可以返回并将它门添加到引用它们的节点。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 给蒙皮节点添加SkinRenderers
for (const {node, mesh, skinNdx} of skinNodes) {
  node.drawables.push(new SkinRenderer(mesh, gltf.skins[skinNdx]));
}
</code></pre><p>如果我们这样渲染我们看不出任何不同。我们需要让一些节点动起来。让我们遍历<code class="notranslate" translate="no">Skin</code>中的每个节点，换句话说每个关节，并在本地x轴上旋转一点点。</p>
<p>为此，我们会存每个关节的原始本地矩阵。我们会每帧旋转一些本地矩阵，使用一个特殊的方法<code class="notranslate" translate="no">m4.decompose</code>，会转换矩阵为关节的位置，旋转量，缩放量。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const origMatrix = new Map();
function animSkin(skin, a) {
  for(let i = 0; i &lt; skin.joints.length; ++i) {
    const joint = skin.joints[i];
    // 如果这个关节并没有存储矩阵
    if (!origMatrix.has(joint)) {
      // 为关节存储一个矩阵
      origMatrix.set(joint, joint.source.getMatrix());
    }
    // 获取原始的矩阵
    const origMatrix = origRotations.get(joint);
    // 旋转它
    const m = m4.xRotate(origMatrix, a);
    // decompose it back into position, rotation, scale
    // into the joint
    m4.decompose(m, joint.source.position, joint.source.rotation, joint.source.scale);
  }
}
</code></pre><p>然后在渲染之前我们会调用它</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">animSkin(gltf.skins[0], Math.sin(time) * .5);
</code></pre><p>注意<code class="notranslate" translate="no">animSkin</code>不是通常的做法。理想情况下，我们会加载一些艺术家制作的动画或者我们知道我们想要以某种方式在代码中操作某个特定关节。在这个例子里，我们只是看看蒙皮是否有效，这似乎是一种简单的方法。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-3d-gltf-skinned.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-3d-gltf-skinned.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>在我们继续之前一些注意事项</p>
<p>当我第一次尝试让它工作时，就像大多数程序一样，屏幕上没有显示的东西。</p>
<p>所以，首先做的是在蒙皮着色器的末尾添加这一行 </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  gl_Position = u_projection * u_view *  a_POSITION;
</code></pre><p>在片断着色器中，我改变了它，仅仅在末尾添加这个来画纯色的</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">outColor = vec4(1, 0, 0, 1);
</code></pre><p>这将删除所有蒙皮，仅仅在原点绘制网格。我调整相机位置直到我有了一个好的视角。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">const cameraPosition = [5, 0, 5];
const target = [0, 0, 0];
</code></pre><p>这显示了虎鲸的轮廓，所以我知道至少有一些数据正在发挥作用</p>
<div class="webgl_center"><img src="../resources/skinning-debug-01.png"></div>

<p>接下来我让片断着色器显示法线</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">outColor = vec4(normalize(v_normal) * .5 + .5, 1);
</code></pre><p>法线从-1 到 1，所以 <code class="notranslate" translate="no">* .5 + .5</code>调整它们到0 到 1来观察颜色。</p>
<p>回到顶点着色器我仅仅传递法线</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v_normal = a_NORMAL;
</code></pre><p>我可以看到这样</p>
<div class="webgl_center"><img src="../resources/skinning-debug-02.png"></div>

<p>我并没有觉得法线会出错，但是从我认为有效的开始，并确认它确实是有效的是很好的方法。</p>
<p>接下来我想我应该检查权重。所有我需要做的就是像法线一样从顶点着色器传递权重</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v_normal = a_WEIGHTS_0.xyz * 2. - 1.;
</code></pre><p>权重从0到1，但是因为片断着色器需要法线，我仅仅改变权重从-1到1</p>
<p>这最初产生了一种混乱的颜色。一旦我发现了这个bug，我得到了这样的图像</p>
<div class="webgl_center"><img src="../resources/skinning-debug-03.png"></div>

<p>它并不完全明显是正确的，但确实有道理。你希望每个骨骼最近的颜色有强烈的颜色，并且你希望在骨骼周围看到色环，因为那个区域的权重可能是1.0或者至少全部相似。</p>
<p>由于原始图像太乱了，我也尝试显示骨骼下标 </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v_normal = vec3(a_JOINTS_0.xyz) / float(textureSize(u_jointTexture, 0).y - 1) * 2. - 1.;
</code></pre><p>下标从 0 到 骨骼数量- 1，所以上边的代码会得到-1到1的结果。</p>
<p>当正常工作时，我得到了这样的图像</p>
<div class="webgl_center"><img src="../resources/skinning-debug-04.png"></div>

<p>又一次得到了乱七八糟的颜色。上图是修复后的样子。这就是你期望看到的虎鲸的权重。每个骨骼周围的色环。</p>
<p>这个bug和我在开始制作这个例子时使用的代替twgl的<code class="notranslate" translate="no">twgl.createBufferInfoFromArrays</code>有关。修复bug后我移除了着色器的改动。注意如果你想使用它们，我在注释中保留了它们。</p>
<p>我想说清楚上面的代码是为了帮助说明蒙皮。它并不意味是一个成熟的蒙皮引擎。我想如果我们试图做一个可使用的引擎，我们会遇到许多我们可能需要改动的地方，但我希望这个例子可以帮助轻微揭开蒙皮的神秘面纱。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" >English</a>
    <option value="/webgl/lessons/de/webgl-skinning.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-getting-webgl2.html">怎样使用WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">基本原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">如何工作的</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">着色器和 GLSL 语言</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html?lang=zh_cn">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl2-whats-new.html">WebGL2有什么新内容</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2.html">迁移WebGL1到WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org和WebGL2Fundamentals.org的区别</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">三维相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-naming.html">WebGL2 三维矩阵命名</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">二维 DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL2 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL2 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL2 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL2 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL2 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">文字 - 二维 Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">文字 - 使用字形纹理</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>技巧</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL，一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>有意见或建议? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">在GitHub上提issue</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 蒙皮';
            var disqus_title = 'WebGL2 蒙皮';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 个贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




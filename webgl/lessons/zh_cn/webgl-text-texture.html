<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-text-texture.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="用纹理在 WebGL 中显示文字">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-text-texture_zh-cn.jpg">

<meta property="og:title" content="WebGL2 文字 - 使用纹理">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-text-texture_zh-cn.jpg">
<meta property="og:description" content="用纹理在 WebGL 中显示文字">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 文字 - 使用纹理">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html">
<meta name="twitter:description" content="用纹理在 WebGL 中显示文字">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-text-texture_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-text-texture_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html",
      "inLanguage":"zh-cn",
      "name":"WebGL2 文字 - 使用纹理",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 文字 - 使用纹理</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-text-texture.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-text-texture.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-text-texture.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-text-texture.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-text-texture.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-text-texture.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-text-texture.html" >English</a>
    <option value="/webgl/lessons/de/webgl-text-texture.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-text-texture.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-text-texture.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-text-texture.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-text-texture.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 文字 - 使用纹理</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>此文上接 WebGL 系列文章，上一篇是<a href="webgl-text-canvas2d.html">用 Canvas 2D 在 WebGL 画布上叠加一个文字层</a>，如果没读建议从那里开始。</p>
<p>在上文中我们讲到<a href="webgl-text-canvas2d.html">如何在 WebGL 场景上方绘制一个二维画布文字层</a>，
那种方法可行并且容易实现，但是有一些限制，比如不能被三维物体遮挡。为了实现这个就需要在 WebGL
中绘制文字。</p>
<p>最简单的方式是制作一个文字纹理，你可以使用 PhotoShop 或其他绘图软件制作一个含有文字的图片。</p>
<p><img class="webgl_center" src="../resources/my-awesme-text.png" /></p>
<p>然后创建平整的几何体显示它，这其实是我做过的所有游戏使用的方法。例如 Locoroco
只有大约 270 个句子，它被本地化为 17 种语言。我们有一个 Excel 表格包含了所有语言的句子，
然后使用一个脚本将它们加载到 PhotoShop 种生成纹理，每种语言每个句子做成一个纹理。</p>
<p>当然你也可以在运行时创建纹理，由于 WebGL 运行在浏览器中，我们可以借助 Canvas 2D API
帮助生成纹理。</p>
<p>从<a href="webgl-text-canvas2d.html">上文</a>的例子开始，添加一个方法向二维画布种填充文字</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var textCtx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;);

// 将文字放在画布中间
function makeTextCanvas(text, width, height) {
  textCtx.canvas.width  = width;
  textCtx.canvas.height = height;
  textCtx.font = &quot;20px monospace&quot;;
  textCtx.textAlign = &quot;center&quot;;
  textCtx.textBaseline = &quot;middle&quot;;
  textCtx.fillStyle = &quot;black&quot;;
  textCtx.clearRect(0, 0, textCtx.canvas.width, textCtx.canvas.height);
  textCtx.fillText(text, width / 2, height / 2);
  return textCtx.canvas;
}
</code></pre><p>现在需要使用 WebGL 绘制两个不同的物体，&#39;F&#39; 和文字。我将使用
<a href="webgl-drawing-multiple-things.html">之前讲到的帮助方法</a>，
如果你不清楚 <code class="notranslate" translate="no">programInfo</code>, <code class="notranslate" translate="no">bufferInfo</code> 是什么，就看看那篇文章。</p>
<p>所以，先创建 &#39;F&#39; 和单位矩形。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 创建 &#39;F&#39; 的数据
var fBufferInfo = primitives.create3DFBufferInfo(gl);
var fVAO = webglUtils.createVAOFromBufferInfo(
    gl, fProgramInfo, fBufferInfo);

// 创建一个单位矩形供文字使用
var textBufferInfo = primitives.createXYQuadBufferInfo(gl, 1);
var textVAO = webglUtils.createVAOFromBufferInfo(
    gl, textProgramInfo, textBufferInfo);
</code></pre><p>XY 矩形是一个单位大小的矩形（正方形），这个矩形以原点为中心。 作为 1 个单位，它的范围是 -0.5、-0.5 和 0.5、0.5</p>
<p>接着创建两个着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 设置着色程序
var fProgramInfo = webglUtils.createProgramInfo(
    gl, [fVertexShaderSource, fFragmentShaderSource]);
var textProgramInfo = webglUtils.createProgramInfo(
    gl, [textVertexShaderSource, textFragmentShaderSource]);
</code></pre><p>创建文字纹理,我们生成贴图因为文本会变小
And create our text texture. We generate mips since the text will get small</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 创建文字纹理
var textCanvas = makeTextCanvas(&quot;Hello!&quot;, 100, 26);
var textWidth  = textCanvas.width;
var textHeight = textCanvas.height;
var textTex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, textTex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>设置 &#39;F&#39; 和文字的全局变量</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var fUniforms = {
  u_matrix: m4.identity(),
};

var textUniforms = {
  u_matrix: m4.identity(),
  u_texture: textTex,
};
</code></pre><p>现在，当我们计算 F 的矩阵时，我们从 viewMatrix 开始，而不是像其他例子一样使用 viewProjectionMatrix。 我们将其乘以构成 F 方向的部分</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var fViewMatrix = m4.translate(viewMatrix,
    translation[0] + xx * spread, translation[1] + yy * spread, translation[2]);
fViewMatrix = m4.xRotate(fViewMatrix, rotation[0]);
fViewMatrix = m4.yRotate(fViewMatrix, rotation[1] + yy * xx * 0.2);
fViewMatrix = m4.zRotate(fViewMatrix, rotation[2] + now + (yy * 3 + xx) * 0.1);
fViewMatrix = m4.scale(fViewMatrix, scale[0], scale[1], scale[2]);
fViewMatrix = m4.translate(fViewMatrix, -50, -75, 0);
</code></pre><p>最后，我们在设置统一值时在投影矩阵中进行乘法运算。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">fUniforms.u_matrix = m4.multiply(projectionMatrix, fViewMatrix);
</code></pre><p>重要的是要注意，<code class="notranslate" translate="no">projectionMatrix</code> 在左边。 这让我们可以在投影矩阵中进行乘法运算，就好像它是第一个矩阵一样。 通常我们在右边相乘。</p>
<p>像这样绘制 F</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 设置绘制 &#39;F&#39;
gl.useProgram(fProgramInfo.program);

// 设置属性和缓冲
gl.bindVertexArray(fVAO);

fUniforms.u_matrix = m4.multiply(projectionMatrix, fViewMatrix);

webglUtils.setUniforms(fProgramInfo, fUniforms);

webglUtils.drawBufferInfo(gl, fBufferInfo);
</code></pre><p>对于文本，我们从 projectionMatrix 开始，然后仅从我们之前保存的 fViewMatrix 中获取位置。 这将使我们在视图前面有一个空间。 我们还需要缩放我们的单位四边形以匹配纹理的尺寸。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 只使用 &#39;F&#39; 视图矩阵的位置
var textMatrix = m4.translate(projectionMatrix,
    fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]);
// 缩放 F 到所需大小
textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
</code></pre><p>然后渲染文字</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 绘制文字设置
gl.useProgram(textProgramInfo.program);

gl.bindVertexArray(textVAO);

m4.copy(textMatrix, textUniforms.u_matrix);
webglUtils.setUniforms(textProgramInfo, textUniforms);

// 绘制文字
webglUtils.drawBufferInfo(gl, textBufferInfo);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>你可能注意到文字部分覆盖了 F，那是因为我们绘制了一个矩形，画布的默认颜色是黑色透明(0,0,0,0)，
然后我们将它绘制到矩形上了，我们可以混合像素。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
</code></pre><p>这样将源像素（片断着色器产生的颜色）和目标像素（画布上的颜色）的颜色根据混合方法进行混合，
我们设置混合方法为 <code class="notranslate" translate="no">SRC_ALPHA</code> 对源，<code class="notranslate" translate="no">ONE_MINUS_SRC_ALPHA</code> 对目标。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">result = dest * (1 - src_alpha) + src * src_alpha
</code></pre><p>所以加入目标像素是绿色 <code class="notranslate" translate="no">0,1,0,1</code>，源是红色 <code class="notranslate" translate="no">1,0,0,1</code> 就得到</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">src = [1, 0, 0, 1]
dst = [0, 1, 0, 1]
src_alpha = src[3]  // this is 1
result = dst * (1 - src_alpha) + src * src_alpha

// 相当于
result = dst * 0 + src * 1

// 最后结果
result = src
</code></pre><p>对于黑色透明的部分的纹理 <code class="notranslate" translate="no">0,0,0,0</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">src = [0, 0, 0, 0]
dst = [0, 1, 0, 1]
src_alpha = src[3]  // this is 0
result = dst * (1 - src_alpha) + src * src_alpha

// 相当于
result = dst * 1 + src * 0

// 最后结果
result = dst
</code></pre><p>这是使用混合的结果。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-enable-blend.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-enable-blend.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>你会发现这样好一些，但是还是有问题，如果仔细看就会看到这样的问题</p>
<p><img class="webgl_center" src="../resources/text-zbuffer-issue.png" /></p>
<p>为什么会这样？我们现在是绘制一个 F 然后绘制文字，然后绘制下一个 F 和文字。
我们还有<a href="webgl-3d-orthographic.html">深度缓冲</a>，所以当绘制一个 F 的文字时，
即使使用混合模式保留了背景色，但是深度缓冲还是会更新，当绘制下一个 F 时如果那个 F
的某些部分在之前文字像素的后面，那些部分就不会绘制。</p>
<p>我们遇到了一个使用 GPU 渲染三维时的最难解决的问题，<strong>透明出现问题</strong>。</p>
<p>对与透明渲染常用的解决方法是先渲染不透明的物体，然后按照 z 的顺寻绘制透明物体，
绘制时开启深度检测但是关闭深度缓冲更新。</p>
<p>先将绘制的不透明物体（F）和透明物体区分开（文字），先定义一些东西保存文字的位置。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var textPositions = [];
</code></pre><p>在循环绘制 F 时保存这些位置</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 记住文字的位置
textPositions.push([fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]]);
</code></pre><p>绘制 F 前关闭混合模式开启深度缓冲</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.disable(gl.BLEND);
gl.depthMask(true);
</code></pre><p>绘制文字开启混合关闭深度缓冲写入</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.depthMask(false);
</code></pre><p>然后在所有保存的位置绘制文字</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">textPositions.forEach(function(pos) {
  // 使用 F 的视图位置
  var textMatrix = m4.translate(projectionMatrix,
      pos[0], pos[1], pos[2]);
  // 将文字缩放到需要的大小
  textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);

  // 绘制文字设置
  gl.useProgram(textProgramInfo.program);

  gl.bindVertexArray(textVAO);

  m4.copy(textMatrix, textUniforms.u_matrix);
  webglUtils.setUniforms(textProgramInfo, textUniforms);

  // 绘制文字
  webglUtils.drawBufferInfo(gl, textBufferInfo);
});
</code></pre><p>现在它基本上可以了</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-separate-opaque-from-transparent.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-separate-opaque-from-transparent.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>你可能注意到我并没有向之前提到的进行排序，在这个例子中我们绘制的几乎是透明的文字，
如果排序了也看不出明显的效果，我会将它留在其他文章中去讲。</p>
<p>另一个问题是文字和对应的 &#39;F&#39; 相交了，这其实没有一个明确的解决办法。
如果你正在制作一个 MMO 然后想给每个玩家显示一些持续文字，你可能会将文字显示在头顶。
只需要将它的 +Y 加一些距离，确保它总是在玩家头上方。</p>
<p>你也可以将它移动到相机方向，我们来实现这个吧。由于 &#39;pos&#39; 在视图空间中，
这意味着它和眼睛位置（在视图空间 0,0,0 处）有关，所以如果我们将它单位化然后乘以一个值，
将它移到眼睛方向固定距离。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+// 由于 pos 在视图空间，表示它是一个从眼睛位置出发的一个向量
+// 所以沿着向量朝眼睛方向移动一定距离
+var fromEye = m4.normalize(pos);
+var amountToMoveTowardEye = 150;  // 因为 F 是 150 个单位长
+var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
+var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
+var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;

var textMatrix = m4.translate(projectionMatrix,
*    viewX, viewY, viewZ);
// 将 F 缩放到需要的大小
// scale the F to the size we need it.
textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
</code></pre><p>这是结果。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-moved-toward-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-moved-toward-view.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>你可能还会发现文字边缘的问题。</p>
<p><img class="webgl_center" src="../resources/text-gray-outline.png" /></p>
<p>这个问题是 Canvas 2D API 只生成预乘阿尔法通道的值，当我们上传画布内容为 WebGL 纹理时，
WebGL 视图获取没有预乘阿尔法的值，但是由于预乘阿尔法的值缺失阿尔法，所以很难完美转换成非预乘值。</p>
<p>解决这个问题需要告诉 WebGL 不用做反预乘。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
</code></pre><p>这个告诉 WebGL 提供预乘值到<code class="notranslate" translate="no">gl.texImage2D</code> 和 <code class="notranslate" translate="no">gl.texSubImage2D</code>，
如果像 Canvas 2D 数据本身就是预乘的话，就直接传递到 WebGL。</p>
<p>我们还需要修改混合方法</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">-gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
+gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
</code></pre><p>旧的方法将源和它的阿尔法通道相乘，就是 <code class="notranslate" translate="no">SRC_ALPHA</code> 代表的意思。
但是现在我们的纹理数据已经乘了它的阿尔法值，就是预乘的意思。
所以就不需要让 GPU 再做乘法，设置为 <code class="notranslate" translate="no">ONE</code> 表示乘以 1。
<div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-premultiplied-alpha.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-premultiplied-alpha.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>现在边界消失了。</p>
<p>如果你想让文字保持固定大小怎么办？如果你还记得<a href="webgl-3d-perspective.html">透视投影</a>
种讲到过透视矩阵就是将物体缩放 <code class="notranslate" translate="no">-Z</code>，以实现近大远小。所以，我们只需缩放 <code class="notranslate" translate="no">-Z</code> 的期望倍数。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">...
// 由于 pos 在视图空间，表示它是一个从眼睛位置出发的一个向量
// 所以沿着向量朝眼睛方向移动一定距离
var fromEye = normalize(pos);
var amountToMoveTowardEye = 150;  // 因为 F 是 150 个单位长
var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;
+var desiredTextScale = -1 / gl.canvas.height;  // 1x1 像素大小
+var scale = viewZ * desiredTextScale;

var textMatrix = m4.translate(projectionMatrix,
    viewX, viewY, viewZ);
// 将 F 缩放到需要的大小
textMatrix = m4.scale(textMatrix, textWidth * scale, textHeight * scale, 1);
...
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-consistent-scale.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-consistent-scale.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>如果你想给每个 F 绘制不同的文字，就应该给每个 F 创建一个新纹理，然后更新那个 F 的全局变量。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 创建纹理，每个 F 一个
var textTextures = [
  &quot;anna&quot;,   // 0
  &quot;colin&quot;,  // 1
  &quot;james&quot;,  // 2
  &quot;danny&quot;,  // 3
  &quot;kalin&quot;,  // 4
  &quot;hiro&quot;,   // 5
  &quot;eddie&quot;,  // 6
  &quot;shu&quot;,    // 7
  &quot;brian&quot;,  // 8
  &quot;tami&quot;,   // 9
  &quot;rick&quot;,   // 10
  &quot;gene&quot;,   // 11
  &quot;natalie&quot;,// 12,
  &quot;evan&quot;,   // 13,
  &quot;sakura&quot;, // 14,
  &quot;kai&quot;,    // 15,
].map(function(name) {
  var textCanvas = makeTextCanvas(name, 100, 26);
  var textWidth  = textCanvas.width;
  var textHeight = textCanvas.height;
  var textTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, textTex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return {
    texture: textTex,
    width: textWidth,
    height: textHeight,
  };
});
</code></pre><p>然后再渲染时选择纹理</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*textPositions.forEach(function(pos, ndx) {

  +// select a texture
  +var tex = textTextures[ndx];
</code></pre><p>在我们的矩阵计算中使用该纹理大小</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  var textMatrix = m4.translate(projectionMatrix,
      viewX, viewY, viewZ);
  // 将 F 缩放到需要的大小
  *textMatrix = m4.scale(textMatrix, tex.width * scale, tex.height * scale, 1);
</code></pre><p>然后再绘制前设置纹理全局变量</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  textUniforms.u_texture = tex.texture;
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-different-text.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-different-text.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>我们使用黑色绘制的文字，如果使用白色会更有用。那样就可以将文字颜色乘以一个颜色值然后变成任意需要的颜色。</p>
<p>首先改变文字着色器，乘以一个颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">...
in vec2 v_texcoord;

uniform sampler2D u_texture;
+uniform vec4 u_color;

out vec4 outColor;

void main() {
*   outColor = texture2D(u_texture, v_texcoord) * u_color;
}
</code></pre><p>然后绘制使用白色绘制文字到画布</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">textCtx.fillStyle = &quot;white&quot;;
</code></pre><p>创建一些颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 颜色，每个 F 一个
var colors = [
  [0.0, 0.0, 0.0, 1], // 0
  [1.0, 0.0, 0.0, 1], // 1
  [0.0, 1.0, 0.0, 1], // 2
  [1.0, 1.0, 0.0, 1], // 3
  [0.0, 0.0, 1.0, 1], // 4
  [1.0, 0.0, 1.0, 1], // 5
  [0.0, 1.0, 1.0, 1], // 6
  [0.5, 0.5, 0.5, 1], // 7
  [0.5, 0.0, 0.0, 1], // 8
  [0.0, 0.0, 0.0, 1], // 9
  [0.5, 5.0, 0.0, 1], // 10
  [0.0, 5.0, 0.0, 1], // 11
  [0.5, 0.0, 5.0, 1], // 12,
  [0.0, 0.0, 5.0, 1], // 13,
  [0.5, 5.0, 5.0, 1], // 14,
  [0.0, 5.0, 5.0, 1], // 15,
];
</code></pre><p>绘制时选择颜色</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 设置颜色全局变量
textUniforms.u_color = colors[ndx];
</code></pre><p>不同颜色</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-different-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-different-colors.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>事实上浏览器在开启 GPU 加速时使用了这个技术，它们使用你的 HTML 内容和各种样式生成纹理，
只要内容不变就只需要不停渲染纹理，即使是滚动之类..当然，如果每次都不停的更新内容就会慢一些，
因为重生成纹理并重上传它们到 GPU 是相对较慢的操作。</p>
<p>在<a href="webgl-text-glyphs.html">下篇文章中我们将讲一个频繁更新时较好的处理方法</a>。</p>
<div class="webgl_bottombar">
<h3>缩放文字去像素化</h3>
<p>
你可能会注意到使用固定尺寸例子前的文字，在距离相机近的时候像素化很严重，如何修复？
</p>
<p>
事实上在三维中缩放二维并不是十分常见，看大多数游戏或三维编辑器就会发现无论相机近还是远，
文字总是固定尺寸。事实上那些文字通常都是绘制在二维而不是三维中，所以即使有人或物体在别的东西的背后，
例如队友在墙后面，你还是可以看到和它相关的文字。
</p>
<p>如果你确实需要在三维中缩放二维文字，我不知道有什么简单的办法，我想到了这几个
</p>
<ul>
<li>在不同的分辨率下使用不同的字体和字号生成不同大小的纹理，然后在高分辨率时使用大一点的纹理，
这个技术叫做LODing（使用不同级别的细节）。</li>
<li>另一个是在每一帧渲染文字时使用确切相关的大小，那样就会非常慢。</li>
<li>另一个可能就是使用二维文字的外包几何体。换句话说就是使用三角形代替绘制纹理。
这个方法可行，但是当文字很小的时候渲染的不是很正常，很大的时候可以看到三角形。</li>
<li>还有一个是<a href="https://www.google.com/search?q=loop+blinn+curve+rendering">使用渲染曲线的特殊着色器</a>。
这个非常酷但是超出了我可以在这里解释的范围。</li>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-text-texture.html" >English</a>
    <option value="/webgl/lessons/de/webgl-text-texture.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-text-texture.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-text-texture.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-text-texture.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-text-texture.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-getting-webgl2.html">怎样使用WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">基本原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">如何工作的</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">着色器和 GLSL 语言</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html?lang=zh_cn">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl2-whats-new.html">WebGL2有什么新内容</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2.html">迁移WebGL1到WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org和WebGL2Fundamentals.org的区别</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">三维相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-naming.html">WebGL2 三维矩阵命名</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">二维 DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL2 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL2 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL2 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL2 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL2 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">文字 - 二维 Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">文字 - 使用字形纹理</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>技巧</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL，一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>有意见或建议? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">在GitHub上提issue</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 文字 - 使用纹理';
            var disqus_title = 'WebGL2 文字 - 使用纹理';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 个贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-instanced-drawing.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="绘制同一物体的多个实例">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg">

<meta property="og:title" content="WebGL2 性能优化 - 实例化绘制">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg">
<meta property="og:description" content="绘制同一物体的多个实例">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 性能优化 - 实例化绘制">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html">
<meta name="twitter:description" content="绘制同一物体的多个实例">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-instanced-drawing_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html",
      "inLanguage":"zh-cn",
      "name":"WebGL2 性能优化 - 实例化绘制",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 性能优化 - 实例化绘制</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-instanced-drawing.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/de/webgl-instanced-drawing.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 性能优化 - 实例化绘制</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL 有一个拓展叫做<em>实例化绘制</em>。
一般来说，使用这种方法绘制多个相同的物体比一个一个绘制要快得多。</p>
<p>首先让我们来演示一下如何绘制同一物体的多个实例。</p>
<p>下面的代码<em>类似</em>于我们在
<a href="webgl-3d-orthographic.html">正射投影</a>
这篇文章中的结尾部分。我们先来看下面两个着色器的代码。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
uniform mat4 matrix;

out vec4 v_color;

void main() {
  // 顶点位置与矩阵相乘。
  gl_Position = matrix * a_position;
}
`

const fragmentShaderSource = `#version 300 es
precision highp float;

uniform vec4 color;

out vec4 outColor;

void main() {
  outColor = color;
}
`
</code></pre>
<p>在顶点着色器里我们像<a href="webgl-3d-orthographic.html">那篇文章</a>
一样让实例的每个顶点与一个矩阵相乘，因为这样非常的灵活。
在片元着色器中则使用通过 uniform 传递的颜色变量。</p>
<p>要进行绘制我们得先编译着色器并连接为一个 program，
然后再找到所有 attribute 和 uniform 的地址。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl, [
    vertexShaderSource,
    fragmentShaderSource
])

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;)
const colorLoc = gl.getUniformLocation(program, &#39;color&#39;)
const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;)
</code></pre>
<p>并制作一个顶点数组对象来保存属性状态</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 创建顶点数组对象（属性状态）
const vao = gl.createVertexArray()

// 并使它成为我们目前正在使用的
gl.bindVertexArray(vao)
</code></pre>
<p>之后我们需要使用一个缓冲区提供顶点数据。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positionBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
      -0.1,  0.4,
      -0.1, -0.4,
       0.1, -0.4,
      -0.1,  0.4,
       0.1, -0.4,
       0.1,  0.4,
      -0.4, -0.1,
       0.4, -0.1,
      -0.4,  0.1,
      -0.4,  0.1,
       0.4, -0.1,
       0.4,  0.1,
    ]),
    gl.STATIC_DRAW
)
const numVertices = 12

// 设置位置属性
gl.enableVertexAttribArray(positionLoc)
gl.vertexAttribPointer(
    positionLoc, // 位置
    2, // 大小（每次迭代从缓冲区里取出的数量）
    gl.FLOAT, // 缓冲区中的数据类型
    false, // 归一化
    0, // stride (0 = 根据size和数据类型进行推断)
    0 // 在缓冲区中的偏移
)
</code></pre>
<p>让我们绘制 5 个实例。 每个实例我们将制作 5 个矩阵和 5 种颜色。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const numInstances = 5
const matrices = [
    m4.identity(),
    m4.identity(),
    m4.identity(),
    m4.identity(),
    m4.identity()
]

const colors = [
    [1, 0, 0, 1], // 红色
    [0, 1, 0, 1], // 绿色
    [0, 0, 1, 1], // 蓝色
    [1, 0, 1, 1], // 紫红色
    [0, 1, 1, 1] // 青色
]
</code></pre>
<p>要绘制它们我们首先得使用着色器程序，并设置 attribute，
然后在一个循环当中为这 5 个实例分别计算新的矩阵，
再去设置矩阵和颜色的 uniform，最后把它们绘制出来。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001; // 秒

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // 告诉 WebGL 如何从裁剪空间转换为像素
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(program);

  // 设置所有属性
  gl.bindVertexArray(vao);

  matrices.forEach((mat, ndx) =&gt; {
    m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
    m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

    const color = colors[ndx];

    gl.uniform4fv(colorLoc, color);
    gl.uniformMatrix4fv(matrixLoc, false, mat);

    gl.drawArrays(
        gl.TRIANGLES,
        0,             // 偏移
        numVertices,   // 每个实例的顶点数量
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>注意到这个数学矩阵库里所有关于矩阵函数的最后一个参数都是一个可选的
目标矩阵。在其它大多数文章里我们并没有用到这个参数，而是让它自行创建一个
新的矩阵，但这一次我们想让结果存放在已经创建好的矩阵上。</p>
<p>于是乎我们得到了 5 个不同颜色而且还在自转的加号。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-not-instanced.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-not-instanced.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>对于每个实例来说，每绘制一次要调用一次<code class="notranslate" translate="no">gl.uniform4v</code>，<code class="notranslate" translate="no">gl.uniformMatrix4fv</code>
还有<code class="notranslate" translate="no">gl.drawArrays</code>，一共是 15 个 WebGL 的函数调用。如果我们的着色器
更加复杂，像是<a href="webgl-3d-lighting-spot.html">聚光灯那篇文章</a>一样的话，
每个物体至少要有 7 次函数调用，分别是 6 次调用<code class="notranslate" translate="no">gl.uniformXXX</code>，
最后一次调用<code class="notranslate" translate="no">gl.drawArrays</code>。如果我们要绘制 400 个物体的话
那将会是 2800 个 WebGL 函数调用。</p>
<p>实例化就是一个帮助我们减少函数调用的好路子。
它的工作原理是让你告诉 WebGL 你想绘制多少次相同的物体（实例的数量）。
对于每个 attribute，你可以让它每次调用顶点着色器时迭代到缓冲区的
<em>下一个值</em>（默认行为），或者是每绘制 N（N 通常为 1）个实例时才迭代到
<em>下一个值</em>。</p>
<p>举个栗子，我们不妨使用 attribute 来提供<code class="notranslate" translate="no">matrix</code>和<code class="notranslate" translate="no">color</code>的值以取代 uniform。
我们会在缓冲区里为每个实例提供矩阵和颜色，设置好从缓冲区里读取数据的
attribute，然后告诉 WebGL 只有在绘制下一个实例的时候才迭代到下一个值。</p>
<p>我们开始做吧！</p>
<p>首先我们改一下这些着色器，用 attribute 给<code class="notranslate" translate="no">matrix</code>和<code class="notranslate" translate="no">color</code>提供数据。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
-uniform mat4 matrix;
+in vec4 color;
+in mat4 matrix;
+
+out vec4 v_color;

void main() {
  // 顶点位置与矩阵相乘
  gl_Position = matrix * a_position;

+  // 传递颜色到片元着色器
+  v_color = color;
}
`
</code></pre>
<p>and</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fragmentShaderSource = `#version 300 es
precision highp float;

-uniform vec4 color;
+// 从顶点着色器传入
+in vec4 v_color;

void main() {
-  gl_FragColor = color;
+  gl_FragColor = v_color;
}
`
</code></pre>
<p>因为 attribute 只能在顶点着色器中声明所以我们需要用 varying
把颜色传递到片元着色器。</p>
<p>然后我们需要找到所有 attribute 的位置。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl,
    [vertexShaderSource, fragmentShaderSource]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
-const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
-const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
+const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
+const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
</code></pre>
<p>现在，我们需要一个缓冲区来储存所有一会我们要提供给 attribute 的矩阵。
因为缓冲区最好在一个<em>chunk</em>中更新，所以我们把所有的矩阵放在一个
<code class="notranslate" translate="no">Float32Array</code>当中。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 为每一个实例设置矩阵
const numInstances = 5;
+// 制作一个每个矩阵一个视图的类型化数组
+const matrixData = new Float32Array(numInstances * 16);
</code></pre>
<p>然后我们再为每一个矩阵创建一个更小的<code class="notranslate" translate="no">Float32Array</code>的观察视图。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const matrices = [
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-];
const matrices = [];
for (let i = 0; i &lt; numInstances; ++i) {
  const byteOffsetToMatrix = i * 16 * 4;
  const numFloatsForView = 16;
  matrices.push(new Float32Array(
      matrixData.buffer,
      byteOffsetToMatrix,
      numFloatsForView));
}
</code></pre>
<p>这样做的话我们可以用<code class="notranslate" translate="no">matrixData</code>来取得所有矩阵的数据，
当需要取得某一个矩阵的数据的时候只要用<code class="notranslate" translate="no">matrices[ndx]</code>即可。</p>
<p>同时我们也需要在 GPU 上创建缓冲区来储存这些数据。
目前只需要申请一段合适大小的缓冲区就好了，我们暂时不需要提供数据给它，
所以<code class="notranslate" translate="no">gl.bufferData</code>第二个参数设置为要为缓冲区申请的字节数。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const matrixBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer)
// 只为缓冲区申请特定大小的空间
gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW)
</code></pre>
<p>注意到最后一个参数是<code class="notranslate" translate="no">gl.DYNAMIC_DRAW</code>。这是一个给 WebGL 的<em>指示</em>，
告诉它我们要经常刷新这里的数据。</p>
<p>Now we need to set up the attributes for the matrices.
The matrix attribute is a <code class="notranslate" translate="no">mat4</code>. A <code class="notranslate" translate="no">mat4</code> actually uses
4 consecutive attribute slots.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const bytesPerMatrix = 4 * 16
for (let i = 0; i &lt; 4; ++i) {
    const loc = matrixLoc + i
    gl.enableVertexAttribArray(loc)
    // note the stride and offset
    const offset = i * 16 // 4 floats per row, 4 bytes per float
    gl.vertexAttribPointer(
        loc, // location
        4, // size (num values to pull from buffer per iteration)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        bytesPerMatrix, // stride, num bytes to advance to get to next set of values
        offset // offset in buffer
    )
    // this line says this attribute only changes for each 1 instance
    gl.vertexAttribDivisor(loc, 1)
}
</code></pre>
<p>The most important point relative to instanced drawing is
the call to <code class="notranslate" translate="no">gl.vertexAttribDivisor</code>. It sets this
attribute to only advance to the next value once per instance.
This means the <code class="notranslate" translate="no">matrix</code> attributes will use the first matrix for
every vertex for the first instance, the second matrix for the
second instance and so on.</p>
<p>接下来颜色值也需要储存在缓冲区当中。因为在这个例子当中颜色不会改变，
所以我们直接上传数据即可。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const colors = [
-  [ 1, 0, 0, 1, ],  // 红色
-  [ 0, 1, 0, 1, ],  // 绿色
-  [ 0, 0, 1, 1, ],  // 蓝色
-  [ 1, 0, 1, 1, ],  // 品红
-  [ 0, 1, 1, 1, ],  // 青色
-];
+// 为每一个实例设置颜色
+const colorBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+gl.bufferData(gl.ARRAY_BUFFER,
+    new Float32Array([
+        1, 0, 0, 1,  // 红色
+        0, 1, 0, 1,  // 绿色
+        0, 0, 1, 1,  // 蓝色
+        1, 0, 1, 1,  // 品红
+        0, 1, 1, 1,  // 青色
+      ]),
+    gl.STATIC_DRAW);
</code></pre>
<p>我们还需要设置颜色属性</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 设置颜色属性
gl.enableVertexAttribArray(colorLoc)
gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0)
// 此行表示此属性仅针对每 1 个实例更改
gl.vertexAttribDivisor(colorLoc, 1)
</code></pre>
<p>在绘制的时候，我们再也不用在循环中设置矩阵和颜色的 uniform，
而是先来计算一下每个实例的矩阵。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 更新所有矩阵
matrices.forEach((mat, ndx) =&gt; {
  m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
  m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

-  const color = colors[ndx];
-
-  gl.uniform4fv(colorLoc, color);
-  gl.uniformMatrix4fv(matrixLoc, false, mat);
-
-  gl.drawArrays(
-      gl.TRIANGLES,
-      0,             // 偏移
-      numVertices,   // 每个实例的顶点数量
-  );
});
</code></pre>
<p>因为我们的矩阵已经作为了目标矩阵参数来传递，同时它还是一个
<code class="notranslate" translate="no">Float32Array</code>的数组，所以在计算完以后我们就可以把数据直接上传给 GPU 了。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 上传新的矩阵数据
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer)
gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData)
</code></pre>
<p>最后我们总算是可以在一个 draw call 当中绘制所有的实例了。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.drawArraysInstanced(
    gl.TRIANGLES,
    0, // 偏移
    numVertices, // 每个实例的顶点数
    numInstances // 实例的数量
)
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>在之前的例子当中每个实例需要三次函数调用，所以一共是 15 次的调用。
但是现在我们只需要总共两次函数调用即可，第一次上传所有的矩阵数据，
第二次就是请求绘制了。</p>
<p>我不知道我是不是显得有点啰嗦了，还有一点我想说的是，上面的代码我们并没有
考虑到关于 canvas 方面的东西。我是说，我们并没有使用任何的
<a href="webgl-3d-orthographic.html">投影矩阵</a>或是<a href="webgl-3d-camera.html">视图矩阵</a>。
因为我们只是为了去演示如何实例化绘制罢了。如果你想往里加点投影或是视图矩阵的话，
那将意味着更多的计算会放到 JavaScript 当中，
这可能会引起一些性能问题。有个更好的办法是给顶点着色器添加一到两个
uniform 来储存这些矩阵。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec4 color;
in mat4 matrix;
+uniform mat4 projection;
+uniform mat4 view;

out vec4 v_color;

void main() {
  // 顶点位置与矩阵相乘
-  gl_Position = matrix * a_position;
+  gl_Position = projection * view * matrix * a_position;

  // 传递颜色到片元着色器
  v_color = color;
}
`
</code></pre>
<p>然后在初始化的时候找到他们的位置</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
+const projectionLoc = gl.getUniformLocation(program, &#39;projection&#39;);
+const viewLoc = gl.getUniformLocation(program, &#39;view&#39;);
</code></pre>
<p>然后再渲染的时候设置它们。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

+// 设置视图和投影矩阵
+// 因为对于所有实例来说它们是一样的
+const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+gl.uniformMatrix4fv(projectionLoc, false,
+    m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
+gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-projection-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-projection-view.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" >English</a>
    <option value="/webgl/lessons/de/webgl-instanced-drawing.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-instanced-drawing.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-getting-webgl2.html">怎样使用WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">基本原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">如何工作的</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">着色器和 GLSL 语言</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html?lang=zh_cn">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl2-whats-new.html">WebGL2有什么新内容</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2.html">迁移WebGL1到WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org和WebGL2Fundamentals.org的区别</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">三维相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-naming.html">WebGL2 三维矩阵命名</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">二维 DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL2 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL2 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL2 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL2 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL2 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">文字 - 二维 Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">文字 - 使用字形纹理</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>技巧</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL，一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>有意见或建议? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">在GitHub上提issue</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 性能优化 - 实例化绘制';
            var disqus_title = 'WebGL2 性能优化 - 实例化绘制';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 个贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




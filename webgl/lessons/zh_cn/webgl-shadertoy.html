<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-shadertoy.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Shadertoy 着色器">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_zh-cn.jpg">

<meta property="og:title" content="WebGL2 Shadertoy">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_zh-cn.jpg">
<meta property="og:description" content="Shadertoy 着色器">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Shadertoy">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html">
<meta name="twitter:description" content="Shadertoy 着色器">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html",
      "inLanguage":"zh-cn",
      "name":"WebGL2 Shadertoy",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Shadertoy</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shadertoy.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shadertoy.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shadertoy.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Shadertoy</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>本文假设你已经阅读过从 <a href="webgl-fundamentals.html">基础</a> 开始的许多文章。
如果你还没有阅读，请先从那开始。</p>
<p>在 <a href="webgl-drawing-without-data.html">无数据绘制的文章</a> 中，我们展示了如何使用顶点着色器绘制没有数据的图形。
本文将讲述如何使用片段着色器绘制没有数据的图像。</p>
<p>我们从一个没有数学运算的简单纯色着色器开始，使用 <a href="webgl-fundamentals.html">第一篇文章中的代码</a>。</p>
<p>简单顶点着色器：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
  // an attribute is an input (in) to a vertex shader.
  // It will receive data from a buffer
  in vec4 a_position;

  // all shaders have a main function
  void main() {

    // gl_Position is a special variable a vertex shader
    // is responsible for setting
    gl_Position = a_position;
  }
`;
</code></pre>
<p>简单片段着色器：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
    outColor = vec4(1, 0, 0.5, 1); // return reddish-purple
  }
`;
</code></pre>
<p>然后编译和链接着色器，并查找 <code class="notranslate" translate="no">position</code> 属性的位置：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector(&quot;#canvas&quot;);
  const gl = canvas.getContext(&quot;webgl2&quot;);
  if (!gl) {
    return;
  }

  // setup GLSL program
  const program = webglUtils.createProgramFromSources(gl, [vs, fs]);

  // look up where the vertex data needs to go.
  const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p>然后创建顶点数组，填充一个覆盖剪裁空间从 -1 到 +1 的矩形缓冲区，设置属性：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // Create a vertex array object (attribute state)
  const vao = gl.createVertexArray();

  // and make it the one we're currently working with
  gl.bindVertexArray(vao);

  // Create a buffer to put three 2d clip space points in
  const positionBuffer = gl.createBuffer();

  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // fill it with a 2 triangles that cover clip space
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  // first triangle
     1, -1,
    -1,  1,
    -1,  1,  // second triangle
     1, -1,
     1,  1,
  ]), gl.STATIC_DRAW);

  // Turn on the attribute
  gl.enableVertexAttribArray(positionAttributeLocation);

  // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
  gl.vertexAttribPointer(
      positionAttributeLocation,
      2,          // 2 components per iteration
      gl.FLOAT,   // the data is 32bit floats
      false,      // don't normalize the data
      0,          // 0 = move forward size * sizeof(type) each iteration to get the next position
      0,          // start at the beginning of the buffer
  );
</code></pre>
<p>然后开始绘制：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // Tell WebGL how to convert from clip space to pixels
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // Tell it to use our program (pair of shaders)
  gl.useProgram(program);

  // Bind the attribute/buffer set we want.
  gl.bindVertexArray(vao);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // offset
      6,     // num vertices to process
  );
</code></pre>
<p>我们得到了一个覆盖整个画布的纯色：</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-solid.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-solid.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>在 <a href="webgl-how-it-works.html">WebGL 工作原理的文章</a>  中，我们通过每个顶点提供颜色。在 <a href="webgl-3d-textures.html">纹理的文章</a> 中，我们通过纹理坐标和纹理添加颜色。</p>
<p>那么在没有额外数据的情况下，如何绘制更丰富的图像？WebGL 提供了一个变量 <code class="notranslate" translate="no">gl_FragCoord</code>，它表示当前像素的像素坐标。</p>
<p>我们修改片段着色器来使用这个变量：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(1, 0, 0.5, 1); // return reddish-purple
+    outColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
  }
`;
</code></pre>
<p>正如上文所述，<code class="notranslate" translate="no">gl_FragCoord</code> 是一个<strong>像素</strong>坐标，因此它会沿着画布的宽度和高度进行计数。当我们将其除以 50 时，随着 <code class="notranslate" translate="no">gl_FragCoord</code> 从 0 增加到 50，得到的值会从 0 变化到 1。
而通过 <code class="notranslate" translate="no">fract</code> 函数，我们仅保留<em>小数</em>部分。例如，当 <code class="notranslate" translate="no">gl_FragCoord</code> 为 75 时：
75 / 50 = 1.5，而 fract(1.5) = 0.5。这意味着，每 50 个像素，我们就会得到一个从 0 到 1 循环变化的值。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-gl-fragcoord.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-gl-fragcoord.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>如上所示，横向每 50 个像素，红色分量会从 0 渐变到 1；
纵向每 50 个像素，绿色分量会从 0 渐变到 1。</p>
<p>按照当前的设置，我们可以用更复杂的数学运算生成更精美的图像。
但存在一个问题：我们无法预知画布的具体尺寸，因此只能针对固定尺寸硬编码。
解决方法是传入画布的尺寸，然后将 <code class="notranslate" translate="no">gl_FragCoord</code> 除以该尺寸——
这样无论画布大小如何，横向和纵向都会得到 0 到 1 的标准化值。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

+  uniform vec2 u_resolution;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
+    outColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>查询和设置 uniform 变量</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up where the vertex data needs to go.
const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);

+// look up uniform locations
+const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);

...

+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

gl.drawArrays(
    gl.TRIANGLES,
    0,     // offset
    6,     // num vertices to process
);

...

</code></pre>
<p>这样我们就能让红色和绿色的渐变范围自动适应画布尺寸，不受分辨率影响</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-resolution.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-resolution.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>我们还需要传入鼠标位置的像素坐标。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;
+  uniform vec2 u_mouse;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
+    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>然后获取 uniform 变量的位置。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up uniform locations
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
+const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
</code></pre>
<p>实时追踪鼠标位置</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;

function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
  render();
}

canvas.addEventListener('mousemove', setMousePosition);
</code></pre>
<p>设置 uniform 变量</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
+gl.uniform2f(mouseLocation, mouseX, mouseY);
</code></pre>
<p>我们还需要修改代码，在鼠标位置变化时触发渲染</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
+  render();
}

+function render() {
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // offset
      6,     // num vertices to process
  );
+}
+render();
</code></pre>
<p>趁此机会，我们一并加入触控支持</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">canvas.addEventListener('mousemove', setMousePosition);
+canvas.addEventListener('touchstart', (e) =&gt; {
+  e.preventDefault();
+}, {passive: false});
+canvas.addEventListener('touchmove', (e) =&gt; {
+  e.preventDefault();
+  setMousePosition(e.touches[0]);
+}, {passive: false});
</code></pre>
<p>现在你可以看到，当鼠标在示例区域移动时，它会实时影响我们生成的图像效果。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-mouse.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-mouse.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>最后关键的一步是：我们需要实现动画效果，因此还要传入一个时间变量——这个值将被加入我们的计算过程以实现动态变化。</p>
<p>例如，如果我们进行如下设置：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
+  uniform float u_time;

  // we need to declare an output for the fragment shader
  out vec4 outColor;

  void main() {
-    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
+    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), fract(u_time), 1);
  }
`;
</code></pre>
<p>现在蓝色通道就会随时间产生脉动效果。
我们只需要查找这个 uniform，并在 <a href="webgl-animation.html">requestAnimationFrame 循环</a> 中设置它。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up uniform locations
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
+const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);

...

-function render() {
+function render(time) {
+  time *= 0.001;  // convert to seconds

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
  gl.uniform2f(mouseLocation, mouseX, mouseY);
+  gl.uniform1f(timeLocation, time);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // offset
      6,     // num vertices to process
  );

+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
-render();
</code></pre>
<p>当然，由于我们正在持续渲染，因此不再需要在 mousemove 时触发渲染。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;
canvas.addEventListener('mousemove', (e) =&gt; {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
-  render();
});
</code></pre>
<p>我们得到了一个简单但无聊的动画。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-time.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-time.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>所以现在有了这些准备，我们就可以从 <a href="https://shadertoy.com">Shadertoy.com</a> 拿一个 shader 来用了。Shadertoy 的着色器需要你提供一个名为 <code class="notranslate" translate="no">mainImage</code> 的函数，其形式如下：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void mainImage(out vec4 fragColor, in vec2 fragCoord)
{	
}
</code></pre>
<p>你的任务就是设置 <code class="notranslate" translate="no">fragColor</code>，方式和你通常设置 <code class="notranslate" translate="no">gl_FragColor</code> 一样，
而 <code class="notranslate" translate="no">fragCoord</code> 与 <code class="notranslate" translate="no">gl_FragCoord</code> 是相同的。引入这个额外的函数让 Shadertoy
可以在调用 <code class="notranslate" translate="no">mainImage</code> 前后增加一些结构或额外的处理逻辑。<br>
如果我们要在自己的项目中使用它，只需要像下面这样调用即可：</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

out vec4 outColor;

//---insert shadertoy code here--

void main() {
  mainImage(outColor, gl_FragCoord.xy);
}
</code></pre>
<p>不过 Shadertoy 使用的 uniform 名称是 <code class="notranslate" translate="no">iResolution</code>、<code class="notranslate" translate="no">iMouse</code> 和 <code class="notranslate" translate="no">iTime</code>，所以我们需要将它们重命名。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

-uniform vec2 u_resolution;
-uniform vec2 u_mouse;
-uniform float u_time;
+uniform vec2 iResolution;
+uniform vec2 iMouse;
+uniform float iTime;

//---insert shadertoy code here--

out vec4 outColor;

void main() {
  mainImage(outColor, gl_FragCoord.xy);
}
</code></pre>
<p>并且根据这些新的名称查找它们的位置。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// look up uniform locations
-const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
-const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
-const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);
+const resolutionLocation = gl.getUniformLocation(program, &quot;iResolution&quot;);
+const mouseLocation = gl.getUniformLocation(program, &quot;iMouse&quot;);
+const timeLocation = gl.getUniformLocation(program, &quot;iTime&quot;);
</code></pre>
<p>将 <a href="https://www.shadertoy.com/view/3l23Rh">这个 Shadertoy 着色器</a> 粘贴到我们上面的着色器中 <code class="notranslate" translate="no">//---insert shadertoy code here--</code> 的位置，就得到了……</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>这是一幅在没有任何数据的情况下产生的异常美丽的图像！</p>
<p>我让上面的示例只在鼠标悬停在 canvas 上或进行触摸时才渲染，
这是因为绘制上面图像所需的数学运算非常复杂且缓慢，
如果让它持续运行，会导致页面几乎无法交互。如果你有一块非常强大的 GPU，
那么上面的图像也许可以流畅运行。但在我的笔记本上，它运行得很慢并且卡顿。</p>
<p>这引出了一个非常重要的观点：<br>
<strong>Shadertoy 上的着色器并不是最佳实践。</strong></p>
<p>Shadertoy本质上是一个充满挑战的创意命题：
<em>“在没有外部数据输入、仅能使用极简参数函数的前提下，能否生成引人入胜的视觉图像？”</em>
这不是构建高性能 WebGL 应用的方式。</p>
<p>以 <a href="https://www.shadertoy.com/view/4sS3zG">这个令人惊叹的 Shadertoy 着色器</a> 为例，它看起来像这样：</p>
<div class="webgl_center"><img src="../resources/shadertoy-dolphin.png" style="width: 639px;"></div>
<p>效果惊艳，但即便在我的高性能笔记本上，以640x360的小窗口运行也只能达到约19帧/秒。
若全屏显示，帧率更会骤降至2-3帧/秒。
换用更高配置的台式机测试，640x360分辨率下勉强达到45帧/秒，全屏时依然只有10帧左右。</p>
<p>反观这款同样具备出色视觉效果的游戏，即使在低端显卡上也能稳定保持30到60帧/秒的流畅表现。</p>
<iframe class="webgl_center" style="width:560px; height: 360px;" src="https://www.youtube-nocookie.com/embed/7v9gZK9HqqI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>这是因为该游戏采用了最佳实践：使用带有纹理的三角形进行绘制，而不是复杂的数学计算。</p>
<p>所以，请牢记这一点。Shadertoy 上的示例令人惊艳，其中一部分原因正是你现在知道它们是在<strong>几乎没有输入数据</strong>的极端条件下，通过复杂的数学函数所绘制出的精美图像。
它们是令人惊叹的作品。</p>
<p>它们也是学习数学的极好方式。<br>
但与此同时，它们绝不是创建高性能 WebGL 应用的正确方式。请一定要记住这一点。</p>
<p>如果你想运行更多 Shadertoy 着色器，你还需要提供更多的 uniform 变量。
下面是 Shadertoy 提供的 uniform 列表：</p>
<div class="webgl_center"><table class="tabular-data tabular-data1"> <thead><tr><td>类型</td><td>变量名</td><td>作用域</td><td>描述</td></tr></thead> <tbody> <tr><td><b>vec3</b></td><td><b>iResolution</b></td><td>图像/缓冲区</td><td>视口分辨率（z分量表示像素宽高比，通常为1.0）</td></tr> <tr><td><b>float</b></td><td><b>iTime</b></td><td>图像/声音/缓冲区</td><td>当前时间（秒）</td></tr> <tr><td><b>float</b></td><td><b>iTimeDelta</b></td><td>图像/缓冲区</td><td>单帧渲染耗时（秒）</td></tr> <tr><td><b>int</b></td><td><b>iFrame</b></td><td>图像/缓冲区</td><td>当前帧序号</td></tr> <tr><td><b>float</b></td><td><b>iFrameRate</b></td><td>图像/缓冲区</td><td>每秒渲染帧数</td></tr> <tr><td><b>float</b></td><td><b>iChannelTime[4]</b></td><td>图像/缓冲区</td><td>各通道时间（视频或音频时使用，单位：秒）</td></tr> <tr><td><b>vec3</b></td><td><b>iChannelResolution[4]</b></td><td>图像/缓冲区/声音</td><td>各通道输入纹理分辨率</td></tr> <tr><td><b>vec4</b></td><td><b>iMouse</b></td><td>图像/缓冲区</td><td>xy=当前像素坐标（左键按下时）；zw=点击像素坐标</td></tr> <tr><td><b>sampler2D</b></td><td><b>iChannel{i}</b></td><td>图像/缓冲区/声音</td><td>第i个输入纹理的采样器</td></tr> <tr><td><b>vec4</b></td><td><b>iDate</b></td><td>图像/缓冲区/声音</td><td>年、月、日、秒时间数据（存储在.xyzw分量中）</td></tr> <tr><td><b>float</b></td><td><b>iSampleRate</b></td><td>图像/缓冲区/声音</td><td>音频采样率（通常为44100Hz）</td></tr> </tbody></table></div>
<div class="webgl_center"><table  class="tabular-data tabular-data1">
<thead><tr><td>type</td><td>name</td><td>where</td><td>description</td></tr></thead>
<tbody>
<tr><td><b>vec3</b></td><td><b>iResolution</b></td><td>image / buffer</td><td>The viewport resolution (z is pixel aspect ratio, usually 1.0)</td></tr>
<tr><td><b>float</b></td><td><b>iTime</b></td><td>image / sound / buffer</td><td>Current time in seconds</td></tr>
<tr><td><b>float</b></td><td><b>iTimeDelta</b></td><td>image / buffer</td><td>Time it takes to render a frame, in seconds</td></tr>
<tr><td><b>int</b></td><td><b>iFrame</b></td><td>image / buffer</td><td>Current frame</td></tr>
<tr><td><b>float</b></td><td><b>iFrameRate</b></td><td>image / buffer</td><td>Number of frames rendered per second</td></tr>
<tr><td><b>float</b></td><td><b>iChannelTime[4]</b></td><td>image / buffer</td><td>Time for channel (if video or sound), in seconds</td></tr>
<tr><td><b>vec3</b></td><td><b>iChannelResolution[4]</b></td><td>image / buffer / sound</td><td>Input texture resolution for each channel</td></tr>
<tr><td><b>vec4</b></td><td><b>iMouse</b></td><td>image / buffer</td><td>xy = current pixel coords (if LMB is down). zw = click pixel</td></tr>
<tr><td><b>sampler2D</b></td><td><b>iChannel{i}</b></td><td>image / buffer / sound</td><td>Sampler for input textures i</td></tr>
<tr><td><b>vec4</b></td><td><b>iDate</b></td><td>image / buffer / sound</td><td>Year, month, day, time in seconds in .xyzw</td></tr>
<tr><td><b>float</b></td><td><b>iSampleRate</b></td><td>image / buffer / sound</td><td>The sound sample rate (typically 44100)</td></tr>
</tbody></table></div>
<p>注意 <code class="notranslate" translate="no">iMouse</code> 和 <code class="notranslate" translate="no">iResolution</code> 实际上应该分别是 <code class="notranslate" translate="no">vec4</code> 和 <code class="notranslate" translate="no">vec3</code>，因此你可能需要调整它们以匹配。</p>
<p><code class="notranslate" translate="no">iChannel</code> 是纹理，所以如果着色器需要它们，你需要提供对应的<a href="webgl-3d-textures.html">纹理</a>。</p>
<p>Shadertoy 还允许你使用多个着色器来渲染到离屏纹理，如果着色器需要这些，你需要设置<a href="webgl-render-to-texture.html">渲染目标纹理</a>。</p>
<p>“where” 列表示这些 uniform 在哪些着色器中可用。</p>
<ul>
<li>“image” 是渲染到画布（canvas）的着色器。</li>
<li>“buffer” 是渲染到离屏纹理（offscreen texture）的着色器。</li>
<li>“sound” 是你期望生成声音数据到纹理的着色器，详见：<a href="https://stackoverflow.com/questions/34859701/how-do-shadertoys-audio-shaders-work">Shadertoy 音频着色器工作原理</a>。</li>
</ul>
<p>希望这有助于你理解 Shadertoy。它是一个拥有许多惊人作品的优秀网站，但了解其背后的原理同样重要。
如果你想深入学习这类着色器使用的技术，有两个不错的资源：</p>
<ul>
<li><a href="https://www.iquilezles.org/www/index.htm">Shadertoy 创建者的博客</a></li>
<li><a href="https://thebookofshaders.com/">The Book of Shaders</a></li>
</ul>
<p>（需要注意的是，《The Book of Shaders》有点误导，因为它主要涵盖的是 Shadertoy 上使用的那种着色器类型，而不是在高性能应用和游戏中常用的着色器类型，但它依然是一个很好的学习资源！）</p>
<div class="webgl_bottombar" id="pixel-coords">
<h3>像素坐标系</h3>
<p>在 WebGL 中，像素坐标是以像素的边缘为参考的。例如，如果画布大小是 3x2 像素，那么位于从左边数第 2 个像素、从底部数第 1 个像素的 <code class="notranslate" translate="no">gl_FragCoord</code> 值将是 (2.5, 1.5)</p>
<div class="webgl_center"><img src="../resources/webgl-pixels.svg" style="width: 500px;"></div>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shadertoy.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shadertoy.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-getting-webgl2.html">怎样使用WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">基本原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">如何工作的</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">着色器和 GLSL 语言</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html?lang=zh_cn">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl2-whats-new.html">WebGL2有什么新内容</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2.html">迁移WebGL1到WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org和WebGL2Fundamentals.org的区别</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">三维相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-naming.html">WebGL2 三维矩阵命名</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">二维 DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL2 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL2 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL2 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL2 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL2 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">拾取（点击物体）</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">文字 - 二维 Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">文字 - 使用字形纹理</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">通用GPU计算(GPGPU)</a></li>
        </ul>
        </ul>
  <li>技巧</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">无数据绘制</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">顶点拉取</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">点、线段与三角形</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">多视图与多画布</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">可视化相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL2 和 Alpha</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">反模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL2中的矩阵vs数学中的矩阵</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">精度问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">跨平台问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">属性（Attributes）</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">纹理单元（Texture Units）</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">帧缓冲区（Framebuffers）</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">参考资料</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL，一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>有意见或建议? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">在GitHub上提issue</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Shadertoy';
            var disqus_title = 'WebGL2 Shadertoy';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 个贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




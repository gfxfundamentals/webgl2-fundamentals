<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-resizing-the-canvas.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to resize a WebGL canvas and the issues involved">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_en.jpg">

<meta property="og:title" content="WebGL2 Resizing the Canvas.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_en.jpg">
<meta property="og:description" content="How to resize a WebGL canvas and the issues involved">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Resizing the Canvas.">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html">
<meta name="twitter:description" content="How to resize a WebGL canvas and the issues involved">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-resizing-the-canvas_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html",
      "inLanguage":"en",
      "name":"WebGL2 Resizing the Canvas.",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Resizing the Canvas.</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-resizing-the-canvas.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-resizing-the-canvas.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-resizing-the-canvas.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-resizing-the-canvas.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-resizing-the-canvas.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-resizing-the-canvas.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Resizing the Canvas.</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Here&#39;s what you need to know to change the size of the canvas.</p>
<p>Every canvas has 2 sizes. The size of its drawingbuffer. This is how many pixels are in the canvas.
The second size is the size the canvas is displayed. CSS determines the size the canvas is
displayed.</p>
<p>You can set the size of the canvas&#39;s drawingbuffer in 2 ways. One using HTML</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>The other using JavaScript</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>JavaScript</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const canvas = document.querySelector(&quot;#c&quot;);
canvas.width = 400;
canvas.height = 300;
</code></pre>
<p>As for setting a canvas&#39;s display size if you don&#39;t have any CSS that affects the canvas&#39;s display size
the display size will be the same size as its drawingbuffer. So in the 2 examples above the canvas&#39;s drawingbuffer is 400x300
and its display size is also 400x300.</p>
<p>Here&#39;s an example of a canvas whose drawingbuffer is 10x15 pixels that is displayed 400x300 pixels on the page</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot; width=&quot;10&quot; height=&quot;15&quot; style=&quot;width: 400px; height: 300px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>or for example like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;style&gt;
#c {
  width: 400px;
  height: 300px;
}
&lt;/style&gt;
&lt;canvas id=&quot;c&quot; width=&quot;10&quot; height=&quot;15&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>If we draw a single pixel wide rotating line into that canvas we&#39;ll see something like this</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-10x15-canvas-400x300-css.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-10x15-canvas-400x300-css.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Why is it so blurry? Because the browser takes our 10x15 pixel canvas and stretches it to 400x300 pixels and
generally it filters it when it stretches it.</p>
<p>So, what do we do if, for example, we want the canvas to fill the window? Well, first we can get
the browser to stretch the canvas to fill the window with CSS. Example</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
      /*  */
      html, body {
        height: 100%;
        margin: 0;
      }
      /* make the canvas fill its container */
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Now we just need to make the drawingbuffer match whatever size the browser has stretched the canvas. 
This is unfortunately a complicated topic. Let&#39;s go over some different methods</p>
<h2 id="use-clientwidth-and-clientheight-">Use <code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code></h2>
<p>This is the easiest way.
<code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code> are properties every element in HTML has that tell us
the size of the element in CSS pixels. </p>
<blockquote>
<p>Note: The client rect includes any CSS padding so if you&#39;re using <code class="notranslate" translate="no">clientWidth</code>
and/or <code class="notranslate" translate="no">clientHeight</code> it&#39;s best not to put any padding on your canvas element.</p>
</blockquote>
<p>Using JavaScript we can check what size that element is being displayed and then adjust
its drawingbuffer size to match.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
  // Lookup the size the browser is displaying the canvas in CSS pixels.
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;

  // Check if the canvas is not the same size.
  const needResize = canvas.width  !== displayWidth ||
                     canvas.height !== displayHeight;

  if (needResize) {
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>Let&#39;s call this function just before we render
so it will always adjust the canvas to our desired size just before drawing.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene() {
   resizeCanvasToDisplaySize(gl.canvas);

   ...
</code></pre>
<p>And here&#39;s that</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-canvas.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-canvas.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Hey, something is wrong? Why is the line not covering the entire area?</p>
<p>The reason is when we resize the canvas we also need to call <code class="notranslate" translate="no">gl.viewport</code> to set the viewport.
<code class="notranslate" translate="no">gl.viewport</code> tells WebGL how to convert from clip space (-1 to +1) back to pixels and where to do
it within the canvas. When you first create the WebGL context WebGL will set the viewport to match the size
of the canvas but after that it&#39;s up to you to set it. If you change the size of the canvas
you need to tell WebGL a new viewport setting.</p>
<p>Let&#39;s change the code to handle this. On top of that, since the WebGL context has a
reference to the canvas let&#39;s pass that into resize.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function drawScene() {
   resizeCanvasToDisplaySize(gl.canvas);

+   gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
   ...
</code></pre><p>Now it&#39;s working.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-canvas-viewport.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-canvas-viewport.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Open that in a separate window, size the window, notice it always fills the window.</p>
<p>I can hear you asking, <em>why doesn&#39;t WebGL set the viewport for us automatically
when we change the size of the canvas?</em> The reason is it doesn&#39;t know how or why
you are using the viewport. You could be <a href="webgl-render-to-texture.html">rendering to a framebuffer</a>
or doing something else that requires a different viewport size. WebGL has no
way of knowing your intent so it can&#39;t automatically set the viewport for you.</p>
<hr>
<h2 id="handling-devicepixelratio-and-zoom">Handling <code class="notranslate" translate="no">devicePixelRatio</code> and Zoom</h2>
<p>Why is that not the end of it? Well, This is where it gets complicated. </p>
<p>The first thing to understand is that most sizes in the browser are in CSS pixel
units. This is an attempt to make the sizes device independent. So for example
at the top of this article we set the canvas&#39;s display size to 400x300 CSS
pixels. Depending on if the user has an HD-DPI display, or is zoomed in or
zoomed out, or has an OS zoom level set, how many actual pixels that becomes on
the monitor will be different.</p>
<p><code class="notranslate" translate="no">window.devicePixelRatio</code> will tell us in general, the ratio of actual pixels
to CSS pixels on your monitor. For example here&#39;s your browser&#39;s current setting</p>
<blockquote>
<div>devicePixelRatio = <span data-diagram="dpr"></span></div>

</blockquote>
<p>If you&#39;re on a desktop or laptop try pressing <kbd>ctrl</kbd>+<kbd>+</kbd> and <kbd>ctrl</kbd>+<kbd>-</kbd> to zoom in and out (<kbd>⌘</kbd>+<kbd>+</kbd> and <kbd>⌘</kbd>+<kbd>-</kbd> on Mac). You should see the number change.</p>
<p>So if we want the number of pixels in the canvas to match the number of pixels actually used to display it
the seemingly obvious solution would be to multiply <code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code> by the <code class="notranslate" translate="no">devicePixelRatio</code> like this:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
  // Lookup the size the browser is displaying the canvas in CSS pixels.
-  const displayWidth  = canvas.clientWidth;
-  const displayHeight = canvas.clientHeight;
+  const dpr = window.devicePixelRatio;
+  const displayWidth  = Math.round(canvas.clientWidth * dpr);
+  const displayHeight = Math.round(canvas.clientHeight * dpr);

  // Check if the canvas is not the same size.
  const needResize = canvas.width  != displayWidth || 
                     canvas.height != displayHeight;

  if (needResize) {
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>We need to call <code class="notranslate" translate="no">Math.round</code> (or <code class="notranslate" translate="no">Math.ceil</code>, or <code class="notranslate" translate="no">Math.floor</code> or <code class="notranslate" translate="no">| 0</code>) to get the number
to an integer because <code class="notranslate" translate="no">canvas.width</code> and <code class="notranslate" translate="no">canvas.height</code> are always in integers so
our comparison might fail if <code class="notranslate" translate="no">devicePixelRatio</code> is not an integer which is common, especially
if the user zooms.</p>
<blockquote>
<p>Note: Whether to use <code class="notranslate" translate="no">Math.floor</code> or <code class="notranslate" translate="no">Math.ceil</code> or <code class="notranslate" translate="no">Math.round</code> is not defined by the HTML
spec. It&#39;s up to the browser. 🙄</p>
</blockquote>
<p>In any case, this will <strong>not</strong> actually work. The new problem is that given a <code class="notranslate" translate="no">devicePixelRatio</code> that is not 1.0
the CSS size the canvas needs to be to fill a given area might not be an integer value
but <code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code> are defined as integers. Let&#39;s say the window is
999 actual device pixels wide your devicePixelRatio = 2.0 and you ask for 100% size canvas.
There&#39;s no integer CSS size * 2.0 that = 999.</p>
<p>The next solution is to use
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect()</code></a>.
It returns a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMRect"><code class="notranslate" translate="no">DOMRect</code></a> 
that has a <code class="notranslate" translate="no">width</code> and <code class="notranslate" translate="no">height</code>. It&#39;s the same
client rect as represented by <code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code> but it is not required
to be an integer.</p>
<p>Below is a purple <code class="notranslate" translate="no">&lt;canvas&gt;</code> that&#39;s set to <code class="notranslate" translate="no">width: 100%</code> of its container. Zoom out a few times to 75% or 60%
and you may see its <code class="notranslate" translate="no">clientWidth</code> and its <code class="notranslate" translate="no">getBoundingClientRect().width</code> diverge. </p>
<blockquote>
<div data-diagram="getBoundingClientRect"></div>

</blockquote>
<p>On my machines I get these readings</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">Windows 10, zoom level 75%, Chrome
clientWidth: 700
getBoundingClientRect().width = 700.0000610351562

MacOS, zoom level 90%, Chrome
clientWidth: 700
getBoundingClientRect().width = 700.0000610351562

MacOS, zoom level -1, Safari (safari does not show the zoom level)
clientWidth: 700
getBoundingClientRect().width = 699.9999389648438

Firefox, both Windows and MacOS all zoom levels
clientWidth: 700
getBoundingClientRect().width = 700
</code></pre><p>Note: Firefox showed 700 in this particular setup but with enough various test I&#39;ve
seen it give a non-integer result from <code class="notranslate" translate="no">getBoundingClientRect</code> for example make the window
thin so that the 100% canvas is smaller than 700 and you might get a non-integer result
on Firefox.</p>
<p>So, given that we could try using <code class="notranslate" translate="no">getBoundingClientRect</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
  // Lookup the size the browser is displaying the canvas in CSS pixels.
  const dpr = window.devicePixelRatio;
-  const displayWidth  = Math.round(canvas.clientWidth * dpr);
-  const displayHeight = Math.round(canvas.clientHeight * dpr);
+  const {width, height} = canvas.getBoundingClientRect();
+  const displayWidth  = Math.round(width * dpr);
+  const displayHeight = Math.round(height * dpr);

  // Check if the canvas is not the same size.
  const needResize = canvas.width  != displayWidth || 
                     canvas.height != displayHeight;

  if (needResize) {
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>So are we done? Unfortunately no. It turns out that <code class="notranslate" translate="no">canvas.getBoundingClientRect()</code> can
not always return the exact correct size. The reason is complicated but it has to do with
the way the browser decides to draw things. Some parts are decided at the HTML level
and some parts are decided later at the &quot;compositor&quot; level (the part that actually draws).
<code class="notranslate" translate="no">getBoundingClientRect()</code> happens at the HTML level but certain things happen after that
which could affect what size the canvas is actually drawn.</p>
<p>I think an example is the HTML part works in the abstract and the compositor
works in the concrete. So lets say you have a window that&#39;s 999 device pixels
wide and a devicePixelRatio of 2.0. You make two elements side by side that are
<code class="notranslate" translate="no">width: 50%</code>. So HTML computes each one should be 499.5 device pixels. But when it
actually comes time to draw the compositor can&#39;t draw 499.5 pixels so one
element gets 499 and the other gets 500. Which one gets or loses a pixel is
undefined by any specs.</p>
<p>The solution the browser vendors came up with is to use the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code> API</a>
and provide the actual size used via the <code class="notranslate" translate="no">devicePixelContextBoxSize</code> property of
the entries it provides.
It returns the actual number of device pixels that were used. Note it&#39;s called the
<code class="notranslate" translate="no">ContentBox</code> not the <code class="notranslate" translate="no">ClientBox</code> which means it&#39;s the actual part of the
canvas element showing the <em>content</em> of the canvas so it doesn&#39;t include the padding like
the <code class="notranslate" translate="no">clientWidth</code>, <code class="notranslate" translate="no">clientHeight</code> and <code class="notranslate" translate="no">getBoundingClientRect</code>, a nice benefit.</p>
<p>It&#39;s returned this way because the result is asynchronous. The &quot;compositor&quot; mentioned
above runs asynchronously from the page. It can figure out the size it&#39;s actually going to use and then send you that size <em>out of band</em>.</p>
<p>Unfortunately while the <code class="notranslate" translate="no">ResizeObserver</code> is available in all modern browser the
<code class="notranslate" translate="no">devicePixelContentBoxSize</code> is only available in Chrome/Edge so far. Here&#39;s how
to use it.</p>
<p>We create a <code class="notranslate" translate="no">ResizeObserver</code> and we pass it a function to call anytime any elements
we&#39;re observing change size. In our case that&#39;s our canvas.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const resizeObserver = new ResizeObserver(onResize);
resizeObserver.observe(canvas, {box: &#39;content-box&#39;});
</code></pre>
<p>The code above creates a <code class="notranslate" translate="no">ResizeObserver</code> that will call the function <code class="notranslate" translate="no">onResize</code>
(below) when an element we observe changes size. We tell it to <code class="notranslate" translate="no">observe</code> our
canvas. We tell it to observe when the <code class="notranslate" translate="no">content-box</code> changes size. This is
important and a little confusing. We could ask it to tell us when the
<code class="notranslate" translate="no">device-pixel-content-box</code> changes size but let&#39;s imagine we have a canvas that
is some percentage size of the window like the common 100% of our line example
above. In that case our canvas will always be the same number of device pixels
regardless of zoom level. The window hasn&#39;t changed size when we zoom so there&#39;s
still the same number of device pixels. On the otherhand the <code class="notranslate" translate="no">content-box</code> will
change as we zoom because it&#39;s measured in CSS pixels and so as we zoom, more or
less CSS pixels fit in the number of device pixels.</p>
<p>If we don&#39;t care about the zoom level then we could just observe <code class="notranslate" translate="no">device-pixel-content-box</code>.
It will throw an error if it&#39;s not supported so we&#39;d do something like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const resizeObserver = new ResizeObserver(onResize);
try {
  // only call us of the number of device pixels changed
  resizeObserver.observe(canvas, {box: &#39;device-pixel-content-box&#39;});
} catch (ex) {
  // device-pixel-content-box is not supported so fallback to this
  resizeObserver.observe(canvas, {box: &#39;content-box&#39;});
}
</code></pre>
<p>The <code class="notranslate" translate="no">onResize</code> function will be called with an array of <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry"><code class="notranslate" translate="no">ResizeObserverEntry</code>s</a>. One for each thing
that changed size. We&#39;ll record the size in a map so that we can handle more than
one element.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// init with the default canvas size
const canvasToDisplaySizeMap = new Map([[canvas, [300, 150]]]);

function onResize(entries) {
  for (const entry of entries) {
    let width;
    let height;
    let dpr = window.devicePixelRatio;
    if (entry.devicePixelContentBoxSize) {
      // NOTE: Only this path gives the correct answer
      // The other paths are imperfect fallbacks
      // for browsers that don&#39;t provide anyway to do this
      width = entry.devicePixelContentBoxSize[0].inlineSize;
      height = entry.devicePixelContentBoxSize[0].blockSize;
      dpr = 1; // it&#39;s already in width and height
    } else if (entry.contentBoxSize) {
      if (entry.contentBoxSize[0]) {
        width = entry.contentBoxSize[0].inlineSize;
        height = entry.contentBoxSize[0].blockSize;
      } else {
        width = entry.contentBoxSize.inlineSize;
        height = entry.contentBoxSize.blockSize;
      }
    } else {
      width = entry.contentRect.width;
      height = entry.contentRect.height;
    }
    const displayWidth = Math.round(width * dpr);
    const displayHeight = Math.round(height * dpr);
    canvasToDisplaySizeMap.set(entry.target, [displayWidth, displayHeight]);
  }
}
</code></pre>
<p>That&#39;s kind of a mess. You can see the API shipped at least 3 different versions
before supporting <code class="notranslate" translate="no">devicePixelContentBoxSize</code> 😂</p>
<p>Now we&#39;ll change our resize function to use this data</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeCanvasToDisplaySize(canvas) {
-  // Lookup the size the browser is displaying the canvas in CSS pixels.
-  const dpr = window.devicePixelRatio;
-  const {width, height} = canvas.getBoundingClientRect();
-  const displayWidth  = Math.round(width * dpr);
-  const displayHeight = Math.round(height * dpr);
+  // Get the size the browser is displaying the canvas in device pixels.
+ const [displayWidth, displayHeight] = canvasToDisplaySizeMap.get(canvas);

  // Check if the canvas is not the same size.
  const needResize = canvas.width  != displayWidth || 
                     canvas.height != displayHeight;

  if (needResize) {
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }

  return needResize;
}
</code></pre>
<p>Here&#39;s an example using this code</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-canvas-hd-dpi.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-canvas-hd-dpi.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>It may be difficult to see any difference. If you have an HD-DPI display
like your smartphone or all Macs since 2019 or maybe a 4k monitor then this
line should be thinner than the line of the previous example.</p>
<p>Otherwise, if you zoom in (I suggest you open the example in a new window), as you zoom
in the line should stay the same resolution where as if you zoom in on the previous example
the line will get thicker and lower-resolution since it&#39;s not adjusting to the <code class="notranslate" translate="no">devicePixelRatio</code>.</p>
<p>Just as a test here are all 3 methods above just using a simple canvas 2d.
To keep it simple it does not use WebGL. Instead it uses Canvas 2D and makes 2 patterns, a 2x2 pixel vertical black and white pattern and a 2x2 pixel horizontal black and white
pattern. It draws the horizontal pattern ▤ on the left and the vertical pattern ▥
on the right.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-the-canvas-comparison.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-the-canvas-comparison.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Resize this window, or better, open it in a new window and zoom in an out using
the keys mentioned above. At different zoom levels resize the window, and notice
only the bottom one works in all cases (in Chrome/Edge). Note the higher your
device&#39;s <code class="notranslate" translate="no">devicePixelRatio</code> the harder it may be to see problems. What you
should see is an unvarying pattern on left and on the right. If you see harsh
patterns or you see differing darkness like a gradient then it&#39;s not working.
Since it will only work in Chrome/Edge you&#39;ll need to try it there to see it
work.</p>
<p>Also note, some OSes (MacOS) provide an OS level scaling option that is mostly
hidden from apps. In this case you&#39;ll see a slight pattern on the bottom example
(assuming your in Chrome/Edge) but it will be a regular pattern.</p>
<p>This brings up the issue that there is no good solution on the other browsers but, do you
need a real solution? The majority of WebGL apps do something like draw some things in 3D
with textures and or lighting on them. As such it&#39;s often not noticeable to either use
the top solution where we ignored <code class="notranslate" translate="no">devicePixelRatio</code> or to use <code class="notranslate" translate="no">clientWidth</code>, <code class="notranslate" translate="no">clientHeight</code>
or <code class="notranslate" translate="no">getBoundingClientRect()</code> * <code class="notranslate" translate="no">devicePixelRatio</code> and not worry about it past that.</p>
<p>Further, blindly using <code class="notranslate" translate="no">devicePixelRatio</code> can really slow down your performance.
On iPhoneX or iPhone11 <code class="notranslate" translate="no">window.devicePixelRatio</code> is <code class="notranslate" translate="no">3</code> which
means you&#39;ll be drawing 9 times as many pixels. On A Samsung Galaxy S8 that value is <code class="notranslate" translate="no">4</code> which means you&#39;d be drawing
16 times as many pixels. That can really slow down your program. In fact it&#39;s a common optimization in games to actually render
less pixels than are displayed and let the GPU scale them up. It really depends on what your needs are. If you&#39;re drawing
a graph for printing you might want to support HD-DPI. If you&#39;re making a game you might not or you might want to give the
user the option to turn support on or off if their system is not fast enough to draw so many pixels.</p>
<p>One other caveat is, at least in January 2021 the <code class="notranslate" translate="no">round(getBoundingClientRect * devicePixelRatio)</code> works on all modern browsers <strong>IF and ONLY IF</strong> the canvas is the full
size of the window like the line example above. Here&#39;s an example using the patterns</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-resize-the-canvas-comparison-fullwindow.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-resize-the-canvas-comparison-fullwindow.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>You&#39;ll notice if you zoom and resize <em>this page</em> it will fail with <code class="notranslate" translate="no">getBoundingClientRect</code>.
This is because the canvas is not the full window, it&#39;s in an iframe. Open the example
in a separate window and it will work.</p>
<p>Which solution you use is up to you. For me, 99% of the time I don&#39;t use
<code class="notranslate" translate="no">devicePixelRatio</code>. It makes my pages slow and except for a few graphics pros most
people won&#39;t notice a difference. On this site there are a few diagrams where it&#39;s
used it but majority of examples do not.</p>
<p>If you look at many WebGL programs they handle resizing or setting the size of the canvas in many different ways.
I think it&#39;s arguable the best way is to let the browser chose the size to display canvas with CSS and then looking up what size it chose and adjusting
the number of pixels in the canvas in response.
If you&#39;re curious <a href="webgl-anti-patterns.html">here are some of the reasons</a> I think the way described above is the preferable way.</p>
<!-- just to shut up the build that this link used to exist
     and still exists in older translations -->
<p><a href="webgl-animation.html"></a></p>
<script type="module" src="resources/webgl-resizing-the-canvas.module.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-resizing-the-canvas.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-resizing-the-canvas.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-resizing-the-canvas.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-resizing-the-canvas.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-resizing-the-canvas.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Resizing the Canvas.';
            var disqus_title = 'WebGL2 Resizing the Canvas.';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




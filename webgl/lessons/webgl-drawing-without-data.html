<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-drawing-without-data.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Creative Coding - Drawing Without Data">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg">

<meta property="og:title" content="WebGL2 Drawing Without Data">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg">
<meta property="og:description" content="Creative Coding - Drawing Without Data">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Drawing Without Data">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html">
<meta name="twitter:description" content="Creative Coding - Drawing Without Data">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html",
      "inLanguage":"en",
      "name":"WebGL2 Drawing Without Data",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Drawing Without Data</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-drawing-without-data.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-drawing-without-data.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-drawing-without-data.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-drawing-without-data.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-drawing-without-data.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-without-data.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-without-data.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Drawing Without Data</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article assumes you&#39;ve read many of the other articles
starting with <a href="webgl-fundamentals.html">the fundamentals</a>.
If you have not read them please start there first.</p>
<p>In <a href="webgl-smallest-programs.html">the article on the smallest WebGL programs</a>
we covered some examples of drawing with very little code.
In this article will go over drawing with no data.</p>
<p>Traditionally, WebGL apps put geometry data in buffers.
They then use attributes to pull vertex data from those buffers
into shaders and convert them to clip space.</p>
<p>The word <strong>traditionally</strong> is important. It&#39;s only a <strong>tradition</strong>
to do it this way. It is in no way a requirement. WebGL doesn&#39;t
care how we do it, it only cares that our vertex shaders
assign clip space coordinates to <code class="notranslate" translate="no">gl_Position</code>.</p>
<p>In GLSL ES 3.0 there is a special variable, <code class="notranslate" translate="no">gl_VertexID</code>
available in vertex shaders. Effectively it counts vertices.
Let&#39;s use it to draw calculate vertex positions with no data.
Well compute the points of a circle based on that variable.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
uniform int numVerts;

#define PI radians(180.0)

void main() {
  float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
  float angle = u * PI * 2.0;                      // goes from 0 to 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

  gl_Position = vec4(pos, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>The code above should be pretty straight forward.
<code class="notranslate" translate="no">gl_VertexID</code> is going to count from 0 to however
many vertices we ask to draw. We&#39;ll pass that same number
in as <code class="notranslate" translate="no">numVerts</code>.
Based on that we generate positions for a circle.</p>
<p>If we stopped there the circle would be an ellipse
because clip space is normalized (goes from -1 to 1)
across and down the canvas. If we pass in the resolution
we can take into account that -1 to 1 across might not
represent the same space as -1 to 1 down the canvas.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
uniform int numVerts;
+uniform vec2 resolution;

#define PI radians(180.0)

void main() {
  float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
  float angle = u * PI * 2.0;                      // goes from 0 to 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

+  float aspect = resolution.y / resolution.x;
+  vec2 scale = vec2(aspect, 1);

+  gl_Position = vec4(pos * scale, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>And our fragment shader can just draw a solid color</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

out vec4 outColor;

void main() {
  outColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>In our JavaScript at init time we&#39;ll compile the shader and look up the uniforms,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// setup GLSL program
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const numVertsLoc = gl.getUniformLocation(program, &#39;numVerts&#39;);
const resolutionLoc = gl.getUniformLocation(program, &#39;resolution&#39;);
</code></pre>
<p>And to render we&#39;ll use the program, 
set the <code class="notranslate" translate="no">resolution</code> and <code class="notranslate" translate="no">numVerts</code> uniforms, and draw the points.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

const numVerts = 20;

// tell the shader the number of verts
gl.uniform1i(numVertsLoc, numVerts);
// tell the shader the resolution
gl.uniform2f(resolutionLoc, gl.canvas.width, gl.canvas.height);

const offset = 0;
gl.drawArrays(gl.POINTS, offset, numVerts);
</code></pre>
<p>And we get a circle of points.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-circle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-circle.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Is this technique useful? Well with some creative code
we could make a starfield or a simple rain effect with
almost no data and a single draw call.</p>
<p>Let&#39;s do the rain just to see it work. First we&#39;ll
change the vertex shader to</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
uniform int numVerts;
uniform float time;

void main() {
  float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
  float x = u * 2.0 - 1.0;                         // -1 to 1
  float y = fract(time + u) * -2.0 + 1.0;          // 1.0 -&gt;  -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>For this situation we don&#39;t need the resolution.</p>
<p>We&#39;ve added a <code class="notranslate" translate="no">time</code> uniform which will be the time
in seconds since the page loaded.</p>
<p>For &#39;x&#39; we&#39;re just going to go from -1 to 1</p>
<p>For &#39;y&#39; we use <code class="notranslate" translate="no">time + u</code> but <code class="notranslate" translate="no">fract</code> returns
only the fractional portion so a value from 0.0 to 1.0.
By expanding that to 1.0 to -1.0 we get a y that repeats
over time but one that is offset differently for each
point.</p>
<p>Let&#39;s change the color to blue in the fragment shader.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision highp float;

out vec4 outColor;

void main() {
-  outColor = vec4(1, 0, 0, 1);
+  outColor = vec4(0, 0, 1, 1);
}
</code></pre>
<p>Then in JavaScript we need to look up the time uniform</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// setup GLSL program
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const numVertsLoc = gl.getUniformLocation(program, &#39;numVerts&#39;);
-const resolutionLoc = gl.getUniformLocation(program, &#39;resolution&#39;);
+const timeLoc = gl.getUniformLocation(program, &#39;time&#39;);
</code></pre>
<p>And we need to convert to code to <a href="webgl-animation.html">animate</a>
by creating a render loop and setting the <code class="notranslate" translate="no">time</code> uniform.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+function render(time) {
+  time *= 0.001;  // convert to seconds

+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(program);

  const numVerts = 20;

  // tell the shader the number of verts
  gl.uniform1i(numVertsLoc, numVerts);
+  // tell the shader the time
+  gl.uniform1f(timeLoc, time);

  const offset = 0;
  gl.drawArrays(gl.POINTS, offset, numVerts);

+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain-linear.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>This gives us POINTS going down the screen but they are all
in order. We need to add some randomness. There is no
random number generator in GLSL. Instead we can use a
function that generates something that appears random
enough.</p>
<p>Here&#39;s one</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">// hash function from https://www.shadertoy.com/view/4djSRW
// given a value between 0 and 1
// returns a value between 0 and 1 that *appears* kind of random
float hash(float p) {
  vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));
  p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));
  return fract(p2.x * p2.y * 95.4337);
}
</code></pre>
<p>and we can use that like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
  float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
-  float x = u * 2.0 - 1.0;                         // -1 to 1
+  float x = hash(u) * 2.0 - 1.0;                   // random position
  float y = fract(time + u) * -2.0 + 1.0;          // 1.0 -&gt;  -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>We pass <code class="notranslate" translate="no">hash</code> our previous 0 to 1 value and it gives us
back a pseudo random 0 to 1 value.</p>
<p>Let&#39;s also make the points smaller</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">  gl_Position = vec4(x, y, 0, 1);
-  gl_PointSize = 5.0;
+  gl_PointSize = 2.0;
</code></pre>
<p>And bump up the number of points we&#39;re drawing</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const numVerts = 20;
+const numVerts = 400;
</code></pre>
<p>And with that we get</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>If you look really closely you can see the rain is repeating.
Look for some clump of points and watch as they fall off
the bottom and pop back on the top.
If there was more going on in the background like if
this cheap rain effect was happening over a 3D game
it&#39;s possible no one would ever notice it&#39;s repeating.</p>
<p>We can fix the repetition by adding in a little more randomness.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
  float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
+  float off = floor(time + u) / 1000.0;           // changes once per second per vertex
-  float x = hash(u) * 2.0 - 1.0;                  // random position
+  float x = hash(u + off) * 2.0 - 1.0;            // random position
  float y = fract(time + u) * -2.0 + 1.0;         // 1.0 -&gt;  -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 2.0;
}
</code></pre>
<p>In the code above we added <code class="notranslate" translate="no">off</code>. Since we&#39;re calling <code class="notranslate" translate="no">floor</code>
the value of <code class="notranslate" translate="no">floor(time + u)</code> will effectively give us
a second timer that only changes once per second for each vertex.
This offset is in sync with the code moving the point down the screen
so at the same instance the point jumps back to the top
of the screen some small amount is added to the value
<code class="notranslate" translate="no">hash</code> is being passed which means this particular point
will get a new random number and therefore a new random horizontal position.</p>
<p>The result is a rain effect that doesn&#39;t appear to repeat</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain-less-repeat.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain-less-repeat.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Can we do more than <code class="notranslate" translate="no">gl.POINTS</code>? Of course! </p>
<p>Let&#39;s make circles. To do this we need triangles around
a center like slices of pie. We can think of each triangle
as 2 points around the edge of the pie followed by 1 point in the center.
We then repeat for each slice of the pie.</p>
<div class="webgl_center"><img src="resources/circle-points.svg" style="width: 400px;"></div>

<p>So first we want some kind of counter that changes once per pie slice</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">int sliceId = gl_VertexID / 3;
</code></pre>
<p>Then we need a count around the edge of the circle that goes</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">0, 1, ?, 1, 2, ?, 2, 3, ?, ...
</code></pre><p>The ? value doesn&#39;t really matter because looking at the
diagram above the 3rd value is always in the center (0,0)
so we can just multiply by 0 regardless of value.</p>
<p>To get the pattern above this would work</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">int triVertexId = gl_VertexID % 3;
int edge = triVertexId + sliceId;
</code></pre>
<p>For points on the edge vs points in the center we need
this pattern. 2 on the edge then 1 in the center, repeat.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">1, 1, 0, 1, 1, 0, 1, 1, 0, ...
</code></pre><p>We can get that pattern with</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float radius = step(1.5, float(triVertexId));
</code></pre>
<p><code class="notranslate" translate="no">step(a, b)</code> is 0 if a &lt; b and 1 otherwise. You can think of it as</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function step(a, b) {
  return a &lt; b ? 0 : 1;
}
</code></pre>
<p><code class="notranslate" translate="no">step(1.5, float(triVertexId))</code> will be 1 when 1.5 is less than <code class="notranslate" translate="no">triVertexId</code>.
That&#39;s true for the first 2 vertices of each triangle and false
for the last one.</p>
<p>We can get triangle vertices for a circle like this</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">int numSlices = 8;
int sliceId = gl_VertexID / 3;
int triVertexId = gl_VertexID % 3;
int edge = triVertexId + sliceId;
float angleU = float(edge) / float(numSlices);  // 0.0 to 1.0
float angle = angleU * PI * 2.0;
float radius = step(float(triVertexId), 1.5);
vec2 pos = vec2(cos(angle), sin(angle)) * radius;
</code></pre>
<p>Putting all of this together let&#39;s just try to draw 1 circle.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
uniform int numVerts;
uniform vec2 resolution;

#define PI radians(180.0)

void main() {
  int numSlices = 8;
  int sliceId = gl_VertexID / 3;
  int triVertexId = gl_VertexID % 3;
  int edge = triVertexId + sliceId;
  float angleU = float(edge) / float(numSlices);  // 0.0 to 1.0
  float angle = angleU * PI * 2.0;
  float radius = step(float(triVertexId), 1.5);
  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

  float aspect = resolution.y / resolution.x;
  vec2 scale = vec2(aspect, 1);

  gl_Position = vec4(pos * scale, 0, 1);
}
</code></pre>
<p>Notice we put <code class="notranslate" translate="no">resolution</code> back in so we don&#39;t get an ellipse.</p>
<p>For a 8 slice circle we need 8 * 3 vertices</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const numVerts = 400;
+const numVerts = 8 * 3;
</code></pre>
<p>and we need to draw <code class="notranslate" translate="no">TRIANGLES</code> not <code class="notranslate" translate="no">POINTS</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const offset = 0;
-gl.drawArrays(gl.POINTS, offset, numVerts);
+gl.drawArrays(gl.TRIANGLES, offset, numVerts);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-triangles-circle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-triangles-circle.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>And if what if we wanted to draw multiple circles?</p>
<p>All we need to do is come up with a <code class="notranslate" translate="no">circleId</code> which we
can use to pick some position for each circle that is
the same for all vertices in the circle.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">int numVertsPerCircle = numSlices * 3;
int circleId = gl_VertexID / numVertsPerCircle;
</code></pre>
<p>For example let&#39;s draw a circle of circles.</p>
<p>First let&#39;s turn the code above into a function,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">vec2 computeCircleTriangleVertex(int vertexId) {
  int numSlices = 8;
  int sliceId = vertexId / 3;
  int triVertexId = vertexId % 3;
  int edge = triVertexId + sliceId;
  float angleU = float(edge) / float(numSlices);  // 0.0 to 1.0
  float angle = angleU * PI * 2.0;
  float radius = step(float(triVertexId), 1.5);
  return vec2(cos(angle), sin(angle)) * radius;
}
</code></pre>
<p>Now here&#39;s the original code we used to draw
a circle of points at the top of this article.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
float angle = u * PI * 2.0;                      // goes from 0 to 2PI
float radius = 0.8;

vec2 pos = vec2(cos(angle), sin(angle)) * radius;

float aspect = resolution.y / resolution.x;
vec2 scale = vec2(aspect, 1);

gl_Position = vec4(pos * scale, 0, 1);
</code></pre>
<p>We just need to change it to use <code class="notranslate" translate="no">circleId</code> instead
of <code class="notranslate" translate="no">vertexId</code> and to divide by the number of circles
instead of the number of vertices.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
+  int circleId = gl_VertexID / numVertsPerCircle;
+  int numCircles = numVerts / numVertsPerCircle;

-  float u = float(gl_VertexID) / float(numVerts);  // goes from 0 to 1
+  float u = float(circleId) / float(numCircles);  // goes from 0 to 1
  float angle = u * PI * 2.0;                     // goes from 0 to 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

+  vec2 triPos = computeCircleTriangleVertex(gl_VertexID) * 0.1;

  float aspect = resolution.y / resolution.x;
  vec2 scale = vec2(aspect, 1);

-  gl_Position = vec4(pos * scale, 0, 1);
+  gl_Position = vec4((pos + triPos) * scale, 0, 1);
}
</code></pre>
<p>Then we just need to increase the number of vertices</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const numVerts = 8 * 3;
+const numVerts = 8 * 3 * 20;
</code></pre>
<p>And now we have a circle of 20 circles.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-triangles-circles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-triangles-circles.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>And of course we could apply the same things we did
above to make a rain of circles. That probably has no
point so I&#39;m not going to go through it but it does show
making triangles in the vertex shader with no data.</p>
<p>The above technique could be used for making rectangles
or squares instead, then generating UV coordinates,
passing those the fragment shader and texture mapping
our generated geometry. This might be good for 
falling snowflakes or leaves that actually flip around in 3D
by applying the 3D techniques we used in the articles
on <a href="webgl-3d-perspective.html">3D perspective</a>.</p>
<p>I want to emphasize <strong>these techniques</strong> are not common.
Making a simple particle system might be semi common or
the rain effect above but making extremely complex calculations
will hurt performance. In general you if you want performance
you should ask your computer to do as little work as possible
so if there is a bunch of stuff you can pre-calculate at init
time and pass it into the shader in some form or another you
should do that.</p>
<p>For example here&#39;s an extreme vertex shader
that calculates a bunch of cubes (warning, has sound).</p>
<iframe width="700" height="400" src="https://www.vertexshaderart.com/art/zd2E5vCZduc5JeoFz" frameborder="0" allowfullscreen></iframe>

<p>As an intellectual curiosity of the puzzle &quot;If I had no data
except a vertex id could I draw something interesting?&quot; it&#39;s
kind of neat. In fact <a href="https://www.vertexshaderart.com">that entire website</a> is about
the puzzle of if you only have a vertex id can you make something
interesting. But, for performance it would be much much faster to use
the more traditional techniques of passing in cube vertex data
in buffers and reading that data with attributes or other techniques
we&#39;ll go in other articles.</p>
<p>There is some balance to be struck. For the rain example above if you want that exact
effect then the code above is pretty efficient. Somewhere between
the two lies the boundary where one technique is more performant
than another. Usually the more traditional techniques are far more flexible
as well but you have to decide on a case by case basis when to use one
way or another.</p>
<p>The point of this article is mostly to introduce these ideas 
and to emphasize other ways of thinking about what WebGL
is actually doing. Again it only cares that you set <code class="notranslate" translate="no">gl_Position</code>
and output a color in your shaders. It doesn&#39;t care how you do it.</p>
<div class="webgl_bottombar" id="pointsissues">
<h3>A problem with <code class="notranslate" translate="no">gl.POINTS</code></h3>
<p>
One thing a technique like this can be useful for is to simulate drawing
with <code class="notranslate" translate="no">gl.POINTS</code>.
</p>

There are 2 problems with <code class="notranslate" translate="no">gl.POINTS</code>

<ol>
<li>They have a maximum size<br/><br/>Most people using <code class="notranslate" translate="no">gl.POINTS</code> use small sizes
but if that maximum size is smaller than you need you'll need to choose a different solution.
</li>
<li>How they get clipped when off the screen is inconsistent<br/><br/>
The issue here is imagine you set the center of a point to be 1 pixel off the left edge
of the canvas but you set <code class="notranslate" translate="no">gl_PointSize</code> to 32.0.
<div class="webgl_center"><img src="resources/point-outside-canvas.svg" style="width: 400px"></div>
According to the OpenGL ES 3.0
spec what is supposed to happen is that because 15 columns of those 32x32 pixels are still on the canvas
they are supposed to be drawn. Unfortunately OpenGL (not ES) says the exact opposite.
If the center of the point is off the canvas nothing is drawn. Even worse, OpenGL until
recently has been notoriously under tested and so some drivers do draw those pixels
and some don't 😭
</li>
</ol>
<p>
So, if either of those issues is a problem for your needs then as a solution you need to draw your own quads
with <code class="notranslate" translate="no">gl.TRIANGLES</code> instead of using <code class="notranslate" translate="no">gl.POINTS</code>.
 If you do that both problems are solved.
The maximum size problem goes away as does the inconsistent clipping problem. There are various
ways to draw lots of quads. <a href="https://jsgist.org/?src=6306857bfd65adbdcd54b0051d441935">One of them is using techniques like the ones in this article</a>.</p>
</div>
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-drawing-without-data.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-drawing-without-data.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-drawing-without-data.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-drawing-without-data.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-without-data.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-without-data.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Drawing Without Data';
            var disqus_title = 'WebGL2 Drawing Without Data';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




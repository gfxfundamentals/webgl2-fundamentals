<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ja/webgl-fundamentals.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="基礎から始めるWebGL2の最初のレッスン">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_ja.jpg">

<meta property="og:title" content="WebGL2の基本">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_ja.jpg">
<meta property="og:description" content="基礎から始めるWebGL2の最初のレッスン">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2の基本">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html">
<meta name="twitter:description" content="基礎から始めるWebGL2の最初のレッスン">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html",
      "inLanguage":"ja",
      "name":"WebGL2の基本",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2の基本</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-fundamentals.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-fundamentals.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-fundamentals.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fundamentals.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" selected>日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ja/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2の基本</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>まず最初に、この記事はWebGL2に関するものです。
WebGL1.0に興味のある方は<a href="https://webglfundamentals.org">こちらを見て下さい</a>。
WebGL2は<a href="webgl1-to-webgl2.html">ほぼ100% WebGL1との下位互換性があります</a>。
WebGL2を有効にし、そのまま使う事ができるかもしれません。
これらのチュートリアルはそのパスに従っています。</p>
<p>WebGLは3D APIと思われがちです。
「WebGLを使えば、<em>魔法</em> のように簡単にカッコ良い3Dを手に入れられる」と思ってしまう人も多いです。
実際には、WebGLはただのピクセルを描くエンジンです。
与えたコードによって<a href="webgl-points-lines-triangles.html">点、線、三角形</a>を描画します。
WebGLで何かしたい場合、点、線、三角形を使用したコードを追加する必要があります。</p>
<p>WebGLはGPU上で動作します。
つまり、GPUで動作するコードが必要です。
「頂点シェーダー」と「フラグメントシェーダー」と呼ばれる2つの関数が必要です。
2つとも<a href="webgl-shaders-and-glsl.html">GLSL</a>と呼ばれる非常に厳密に型付けされたC/C++のような言語で書かれています(GLシェーダー言語)。
その2つの組み合わせたものは <em>プログラム</em> と呼びます。</p>
<p>頂点シェーダーの役割は、頂点の位置計算です。
頂点シェーダーの結果で<a href="webgl-points-lines-triangles.html">点、線、三角形</a>を含む様々な種類のプリミティブを描きます。
このプリミティブを描画する際に、フラグメントシェーダーを呼び出します。
フラグメントシェーダーの役割は、現在描画されてるプリミティブの各ピクセルごとの色を計算します。</p>
<p>上記2つの関数を起動する前に、WebGL APIでその関数の<a href="../resources/webgl-state-diagram.html">状態の設定</a>する必要があります。
様々な状態の設定を行い、<code class="notranslate" translate="no">gl.drawArrays</code> または <code class="notranslate" translate="no">gl.drawElements</code> を呼び出してGPU上でシェーダーを実行します。</p>
<p>シェーダーに渡したいデータはGPUにアップロードが必要です。
シェーダーがデータを受け取る方法は4つあります。</p>
<ol>
<li>
<p>属性（Attribute）、バッファ(Buffer）、頂点配列（Vertex Array）</p>
<p>バッファはGPUにアップロードするバイナリデータの配列です。
通常はバッファには位置、法線、テクスチャ座標、頂点の色などが含まれますが、好きなデータを自由に入れられます。</p>
<p>属性はバッファからデータを取り出し、頂点シェーダーに与える設定です。
例えばあるバッファに位置ごとに3つの32ビット数字が入っており、属性にどのバッファから位置を取り出すか、どのようなデータを取り出すか（3つの32ビット浮動小数点数）、開始位置がバッファ内のどのオフセットであるか、1つの位置から次の位置への取得バイト数を伝えられます。</p>
<p>バッファから自由にデータ取得は出来ないですが、頂点シェーダーを呼び出す回数を設定し、呼び出す毎に次のデータをバッファからよむと属性にそのデータが入ります。</p>
<p>属性の状態、どのバッファを使うか、バッファからどのようにデータを引き出すかなどを頂点配列オブジェクト（VAO）に集約しています。</p>
</li>
<li>
<p>ユニフォーム（Uniform）</p>
<p>ユニフォームはシェーダープログラムの実行前に設定するグローバル変数です。</p>
</li>
<li>
<p>テクスチャ（Texture）</p>
<p>テクスチャはシェーダープログラムで自由に読み込めるデータ配列です。
よくテクスチャには画像データを入れますが、ただのデータ配列なので色以外のデータを入れる事も簡単です。</p>
</li>
<li>
<p>ヴァリイング（Varying）</p>
<p>ヴァリイングは頂点シェーダーからフラグメントシェーダーにデータを渡す方法です。
レンダリングされるデータ（点、線、三角形）によって、頂点シェーダーでヴァリイングに設定する値は異なり、フラグメントシェーダー実行中に補間されます。</p>
</li>
</ol>
<h2 id="webglでhello-world">WebGLでHello World</h2>
<p>WebGLは2つの事だけ関心があります。それはクリップ空間と色です。
プログラマーの役割は、この2つをWebGLに渡す事です。
これを行うために2つの「シェーダー」を用意します。
クリップ空間の頂点座標を与える頂点シェーダー、色を与えるフラグメントシェーダーです。</p>
<p>キャンバスのサイズに関係なく、クリップ空間の頂点座標は常に -1 〜 +1 になります。
以下は一番単純なWebGLの例です。</p>
<p>まず頂点シェーダーから始めましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec4 a_position;

// all shaders have a main function
void main() {

  // gl_Position is a special variable a vertex shader
  // is responsible for setting
  gl_Position = a_position;
}
</code></pre>
<p>GLSLではなく、JavaScriptで書かれていたとしたら以下のように動くと想像できます（疑似コードです）</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// *** PSEUDO CODE!! ***

var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;

drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i &lt; count; ++i) {
     // copy the next 4 values from positionBuffer to the a_position attribute
     const start = offset + i * stride;
     attributes.a_position = positionBuffer.slice(start, start + size);
     runVertexShader();
     ...
     doSomethingWith_gl_Position();
}
</code></pre>
<p>実際には、<code class="notranslate" translate="no">positionBuffer</code> をバイナリデータに変換する必要があり（下記参照）、
バッファからデータを取り出すための計算とは少し異なります。
これで頂点シェーダーがどのように実行されるか理解できると思います。</p>
<p>次にフラグメントシェーダーが必要です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means &quot;high precision&quot;
precision highp float;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  // Just set the output to a constant reddish-purple
  outColor = vec4(1, 0, 0.5, 1);
}
</code></pre>
<p>上記でフラグメントシェーダーの出力として <code class="notranslate" translate="no">outColor</code> を宣言しました。
<code class="notranslate" translate="no">outColor</code> を <code class="notranslate" translate="no">1, 0, 0.5, 1</code> にすると、赤＝1、緑＝0、青＝0.5、アルファ＝1になります。
WebGLでは色は0〜1の間を指定します。</p>
<p>2つのシェーダー関数を書いたのでWebGLで使ってみましょう。</p>
<p>まず、HTMLのcanvas要素が必要です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>JavaScriptでそのcanvas要素を探します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var canvas = document.querySelector(&quot;#c&quot;);
</code></pre>
<p>これでWebGL2RenderingContextを作成できるようになりました。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var gl = canvas.getContext(&quot;webgl2&quot;);
 if (!gl) {
    // no webgl2 for you!
    ...
</code></pre>
<p>次にシェーダーをコンパイルしてGPU上にアップロードする必要があるので、シェーダーコードを文字列にします。
GLSLを文字列にする方法はいくつかあります。
例えば文字列を連結したり、AJAXでダウンロードしたり、scriptタグのtypeがjavascript以外のタグです。
今回は複数行のテンプレート文字列に入れます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShaderSource = `#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec4 a_position;

// all shaders have a main function
void main() {

  // gl_Position is a special variable a vertex shader
  // is responsible for setting
  gl_Position = a_position;
}
`;

var fragmentShaderSource = `#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means &quot;high precision&quot;
precision highp float;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  // Just set the output to a constant reddish-purple
  outColor = vec4(1, 0, 0.5, 1);
}
`;
</code></pre>
<p>ほとんどの3Dエンジンでは様々なタイプのテンプレートや文字列の連結を使用し、動的にGLSLシェーダーを生成しています。
このサイトのサンプルでは、複雑でないので実行時に動的にGLSLを生成する必要はありません。</p>
<blockquote>
<p>注意: <code class="notranslate" translate="no">#version 300 es</code> <strong>必ずシェーダーの最初の行にして下さい</strong>。
最初の行にコメントや空行を入れてはいけません。
<code class="notranslate" translate="no">version 300 es</code> はWebGL2にGLSL ES 3.00と呼ばれるシェーダー言語を使う事を伝えます。
この記述がない場合、シェーダー言語のデフォルトはWebGL 1.0のGLSL ES 1.00になります。</p>
</blockquote>
<p>次にシェーダーを作成しGLSLソースをアップロードして、シェーダーをコンパイルする関数が必要です。
関数名から何をしているか明らかなのでコメントは書いてません。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}
</code></pre>
<p>この関数を呼び出すと2つのシェーダーを作成できます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
</code></pre>
<p>この2つのシェーダーを <em>プログラム</em> に <em>リンク</em> します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}
</code></pre>
<p>そして、上記の関数を呼び出します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var program = createProgram(gl, vertexShader, fragmentShader);
</code></pre>
<p>GPU上でGLSLプログラムを作成したのでデータを送ります。
WebGL APIの大部分は、GLSLプログラムにデータを送り状態を設定します。
この場合、GLSLプログラムへの入力は <code class="notranslate" translate="no">a_position</code> でこれが属性です。
最初にgl.getAttribLocationで作成したプログラムの属性の位置を調べます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p>属性の位置（およびユニフォームの位置）を調べるコードは、描画ループ内でなく初期化中に行うべきです。</p>
<p>属性はバッファからデータを取得し、バッファを作成します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionBuffer = gl.createBuffer();
</code></pre>
<p>WebGLでは、グローバルバインドポイント上で多くのWebGLリソースを操作できます。
バインドポイントとは、WebGL内部のグローバル変数と考えて下さい。
まず、リソースをバインドポイントにバインドします。
他の全ての関数はバインドポイントを通してリソースを参照します。
そこでpositionBufferをバインドしてみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre>
<p>バインドポイントを参照し、バッファにデータを入れました。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// three 2d points
var positions = [
  0, 0,
  0, 0.5,
  0.7, 0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre>
<p>ここでは様々な事が行われています。
まず、JavaScriptの配列の <code class="notranslate" translate="no">positions</code> があります。
WebGLでは型付けのデータが必要です。
<code class="notranslate" translate="no">new Float32Array(positions)</code> は32ビットの浮動小数点数の新しい配列を作成し、 <code class="notranslate" translate="no">positions</code> の値をコピーします。
<code class="notranslate" translate="no">gl.bufferData</code> はデータをGPU上の <code class="notranslate" translate="no">positionBuffer</code> にコピーします。
positionBufferは上記の <code class="notranslate" translate="no">ARRAY_BUFFER</code> でバインドポイントにバインドしています。</p>
<p>gl.bufferDataの最後の引数  <code class="notranslate" translate="no">gl.STATIC_DRAW</code> は、データをどのように使用するかのWebGLへのヒントです。
WebGLは、このヒントを使って特定のものを最適化できます。
<code class="notranslate" translate="no">gl.STATIC_DRAW</code> はこのデータはあまり更新しない意味です。</p>
<p>データをバッファに入れたので、バッファからデータを取り出す方法を属性に伝えます。
まず、頂点配列オブジェクトと呼ばれる属性状態のコレクションを作成する必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vao = gl.createVertexArray();
</code></pre>
<p>createVertexArrayで頂点配列を作成します。
これで全ての属性の設定がその属性状態に適用されます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindVertexArray(vao);
</code></pre>
<p>ここで頂点配列の属性を設定します。まず、属性を有効にします。
そして、バッファからデータを取得します。
もしこの属性を有効にしない場合、この属性は定数になります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre>
<p>次にデータを取り出す方法を指定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var size = 2;          // 2 components per iteration
var type = gl.FLOAT;   // the data is 32bit floats
var normalize = false; // don't normalize the data
var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
var offset = 0;        // start at the beginning of the buffer
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset)
</code></pre>
<p><code class="notranslate" translate="no">gl.vertexAttribPointer</code> の隠された部分は、現在の <code class="notranslate" translate="no">ARRAY_BUFFER</code> を属性にバインドします。
言い換えると、この属性は <code class="notranslate" translate="no">positionBuffer</code> にバインドされます。
つまり、<code class="notranslate" translate="no">ARRAY_BUFFER</code> のバインドポイントに何か他のものを自由にバインドできます。
属性は <code class="notranslate" translate="no">positionBuffer</code> を使い続けます。</p>
<p>GLSLの頂点シェーダーでは <code class="notranslate" translate="no">a_position</code> 属性は <code class="notranslate" translate="no">vec4</code> です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">in vec4 a_position;
</code></pre>
<p><code class="notranslate" translate="no">vec4</code> は4つの浮動小数点値です。
JavaScriptでは <code class="notranslate" translate="no">a_position = {x: 0, y. 0, z: 0, w: 0}</code> です。
上記では <code class="notranslate" translate="no">size = 2</code> としてます。
属性のデフォルトは <code class="notranslate" translate="no">0, 0, 0, 1</code> で、この属性はバッファから最初の2つの値(xとy)を取得します。
zとwはそれぞれデフォルトの0と1になります。</p>
<p>描画前にキャンバスの表示サイズに合わせて、サイズを変更しておきましょう。
画像のようなキャンバスには2つのサイズがあります。
実際に入っているピクセル数と表示されるサイズを分けて表示しています。
<strong>キャンバスを表示するサイズはCSS</strong> で必ず設定して下さい。
CSSは他の方法よりも柔軟性があります。</p>
<p>キャンバスのピクセル数と表示サイズを一致させるために<a href="webgl-resizing-the-canvas.html">こちらで紹介しているヘルパー関数を使っています</a>。</p>
<p>サンプルをブラウザの別ウィンドウで開いて実行した場合、キャンバスサイズは400 x 300ピクセルです。
このページのようにiframeの中にある場合はiframeのサイズに合わされます。</p>
<p>CSSでサイズを調整し、この2つの場合を簡単に対応できます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>クリップ空間の値から <code class="notranslate" translate="no">gl_Position </code> を設定し、ピクセルに変換します。
そして、 <code class="notranslate" translate="no">gl.viewport</code> を呼び出し、キャンバスの現在のサイズを渡します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre>
<p>これは -1 〜 +1 のクリップ空間で、X軸が「0 〜 <code class="notranslate" translate="no">gl.canvas.width</code>」、y軸が「0 〜 <code class="notranslate" translate="no">gl.canvas.height</code>」になるように設定しています。</p>
<p>そして、キャンバスをクリアします。
<code class="notranslate" translate="no">0, 0, 0, 0</code> はそれぞれ赤、緑、青、アルファです。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Clear the canvas
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre>
<p>次にどのシェーダープログラムを実行するか指定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Tell it to use our program (pair of shaders)
gl.useProgram(program);
</code></pre>
<p>どのバッファセットを使用するか、バッファからどのようにしてデータを取り出して属性に指定するか伝える必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Bind the attribute/buffer set we want.
gl.bindVertexArray(vao);
</code></pre>
<p>これでようやくWebGLでGLSLプログラムを実行できるようになりました。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 3;
gl.drawArrays(primitiveType, offset, count);
</code></pre>
<p>カウントが3なので頂点シェーダーが3回実行されます。
頂点シェーダーの属性の最初の <code class="notranslate" translate="no">a_position.x</code> と <code class="notranslate" translate="no">a_position.y</code> は、positionBufferに2つの値が設定されます。
<code class="notranslate" translate="no">a_position.xy</code> には2回目の2つの値が設定されます。
3回目は最後の2つの値が設定されます。</p>
<p><code class="notranslate" translate="no">primitiveType</code> で <code class="notranslate" translate="no">gl.TRIANGLES</code> を設定してるので、
頂点シェーダーが3回実行される毎に <code class="notranslate" translate="no">gl_Position</code> に設定した3つの値で三角形を描画します。
キャンバスのサイズに関係なく、クリップ空間の座標は -1 〜 +1 の範囲になります。</p>
<p>頂点シェーダーは単にpositionBufferの値を <code class="notranslate" translate="no">gl_Position</code> にコピーしているだけで三角形はクリップ空間座標に描画されます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  0, 0,
  0, 0.5,
  0.7, 0,
</code></pre>
<p>クリップ空間からスクリーン空間に変換すると、キャンバスのサイズが400 x 300の場合は以下のようになります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> clip space      screen space
   0, 0       -&gt;   200, 150
   0, 0.5     -&gt;   200, 225
 0.7, 0       -&gt;   340, 150
</code></pre>
<p>この座標で三角形をレンダリングします。
ピクセルごとにフラグメントシェーダーを呼び出します。
フラグメントシェーダーの <code class="notranslate" translate="no">outColor</code> を <code class="notranslate" translate="no">1, 0, 0.5, 1</code> に設定します。
キャンバスの色はRGBの各チャンネルにつき8ビットなので、<code class="notranslate" translate="no">[255, 0, 127, 255]</code> をキャンバスに書き込みます。</p>
<p>こちらが動いてるサンプルコードです。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-fundamentals.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-fundamentals.html" target="_blank">ここをクリックすると別ウィンドウで開きます</a>
</div>

</p>
<p>上記の例は頂点シェーダーは何もしてませんが、位置データを直接渡しています。
既にクリップ空間に位置データが入っているので修正作業は必要ありません。
<em>WebGLは描画APIに過ぎないので、3Dを必要とする場合はクリップ空間に変換するシェーダーを与える必要があります</em>。</p>
<p>なぜ三角形が真ん中から始まり、右上に向かっていくのか不思議に思うかもしれません。
<code class="notranslate" translate="no">x</code> のクリップ空間は -1 〜 +1 です。
つまり、0が中心で正の値はその右側になります。</p>
<p>なぜ上にあるのかと言うとクリップ空間では-1が下にあり、+1が上になります。
つまり、0が中心にあるので正の数が中心より上になります。</p>
<p>2Dの場合、クリップ空間よりもピクセル空間で作業したいと思うでしょう。
シェーダーを変更してピクセルで位置を指定し、クリップ空間に変換してみましょう。
これが変更した頂点シェーダーです。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">-  in vec4 a_position;
+  in vec2 a_position;

+  uniform vec2 u_resolution;

  void main() {
+    // convert the position from pixels to 0.0 to 1.0
+    vec2 zeroToOne = a_position / u_resolution;
+
+    // convert from 0-&gt;1 to 0-&gt;2
+    vec2 zeroToTwo = zeroToOne * 2.0;
+
+    // convert from 0-&gt;2 to -1-&gt;+1 (clip space)
+    vec2 clipSpace = zeroToTwo - 1.0;
+
*    gl_Position = vec4(clipSpace, 0, 1);
  }
</code></pre>
<p>変更点について、いくつか注意点があります。
<code class="notranslate" translate="no">a_position</code> を <code class="notranslate" translate="no">vec2</code> に変更したのは <code class="notranslate" translate="no">x</code> と <code class="notranslate" translate="no">y</code> を使うからです。
<code class="notranslate" translate="no">vec2</code> は <code class="notranslate" translate="no">vec4</code> に似ていますが、<code class="notranslate" translate="no">x</code> と <code class="notranslate" translate="no">y</code> だけを使っています。</p>
<p>次に <code class="notranslate" translate="no">u_resolution</code> という <code class="notranslate" translate="no">uniform</code> を追加しました。
これを設定するには、ロケーションを指定する必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre>
<p>あとはコメントを見れば一目瞭然でしょう。
<code class="notranslate" translate="no">u_resolution</code> にキャンバスの解像度を設定すると、シェーダーは <code class="notranslate" translate="no">positionBuffer</code> で指定した位置をピクセル座標で受け取りクリップ空間に変換します。</p>
<p>これで位置の値をクリップ空間からピクセルに変更できるようになりました。
今回は3点ずつの2つの三角形で作った長方形を描きます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positions = [
*  10, 20,
*  80, 20,
*  10, 30,
*  10, 30,
*  80, 20,
*  80, 30,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre>
<p>どのプログラムを使用するかを作成したユニフォームの値を設定します。
<code class="notranslate" translate="no">gl.useProgram</code> は上記の <code class="notranslate" translate="no">gl.bindBuffer</code> と同様に現在のプログラムを設定します。
全ての <code class="notranslate" translate="no">gl.uniformXXX</code> 関数は現在のプログラムにユニフォームを設定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(program);

// Pass in the canvas resolution so we can convert from
// pixels to clip space in the shader
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
</code></pre>
<p>2つの三角形を描画するために頂点シェーダーを6回呼び出し、<code class="notranslate" translate="no">count</code> を <code class="notranslate" translate="no">6</code> に変更します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// draw
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre>
<p>そして、これがそのコードです。</p>
<p>注意: この例と全ての例はシェーダーをコンパイルしてリンクする関数を含む <a href="/webgl/resources/webgl-utils.js"><code class="notranslate" translate="no">webgl-utils.js</code></a> を使用しています。
サンプルを煩雑にさせたくないので、<a href="webgl-boilerplate.html">ボイラーテンプレート</a>にしました。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle.html" target="_blank">ここをクリックすると別ウィンドウで開きます</a>
</div>

</p>
<p>もう1度言いますが、長方形がその領域の下の方にあります。
WebGLではYが正の場合は上、Yが負の場合は下となります。
クリップ空間で左下隅 -1, -1です。
コードを変えていないので、0が左下になります。
2DグラフィックスAPIで使用されているように左上を0, 0にしたければ、クリップ空間のy座標を反転させます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre>
<p>四角形は期待通りの位置になります。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-top-left.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-top-left.html" target="_blank">ここをクリックすると別ウィンドウで開きます</a>
</div>

</p>
<p>四角形を定義してる部分を関数にし、呼び出す時にサイズと色の変更ができるようにします。</p>
<p>まず、フラグメントシェーダーに色のユニフォームを渡します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

precision highp float;

+  uniform vec4 u_color;

out vec4 outColor;

void main() {
-  outColor = vec4(1, 0, 0.5, 1);
*  outColor = u_color;
}
</code></pre>
<p>50個の四角形をランダムな位置と色で描画するコードは以下の通りです。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
  ...

  // draw 50 random rectangles in random colors
  for (var ii = 0; ii &lt; 50; ++ii) {
    // Setup a random rectangle
    setRectangle(
        gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

    // Set a random color.
    gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);

    // Draw the rectangle.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
}

// Returns a random integer from 0 to range - 1.
function randomInt(range) {
  return Math.floor(Math.random() * range);
}

// Fills the buffer with the values that define a rectangle.

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;

  // NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...) will affect
  // whatever buffer is bound to the `ARRAY_BUFFER` bind point
  // but so far we only have one buffer. If we had more than one
  // buffer we'd want to bind that buffer to `ARRAY_BUFFER` first.

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}
</code></pre>
<p>そして、これがその四角形です。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangles.html" target="_blank">ここをクリックすると別ウィンドウで開きます</a>
</div>

</p>
<p>WebGLは、かなり単純なAPIだと気づくと思います。
単純という言葉は間違っているかもしれませんが、何をするかは簡単です。
ただ、頂点シェーダーとフラグメントシェーダーの両方を実行し、三角形、線、点を描画するだけです。
3Dを行うために複雑になりますが、その複雑さはプログラマがもっと複雑なシェーダーで追加したものです。
WebGLはただ単純に描画するAPIです。</p>
<p>今回は、1つの属性と2つのユニフォームでデータをシェーダーに渡す方法を取り上げました。
複数の属性を持ち、ユニフォームが多く使う事はよくあります。
この記事の始めの方で <em>ヴァリイング</em> と <em>テクスチャ</em> についても触れました。
これらは後のレッスンで説明します。</p>
<p>次に進む前に <code class="notranslate" translate="no">setRectangle</code> で行ったようにバッファ内のデータを更新する事は、 <em>ほとんどの</em> アプリケーションでは一般的ではないです。
この例を使ったのはピクセル座標を入力とし、GLSLで少しだけ計算をしている説明が一番簡単だと思ったからです。
それは駄目な方法ではないはずです。
この方法が適切である場合もありますが、
<a href="webgl-2d-translation.html">WebGLで移動、回転、拡大縮小する、一般的な方法も読んでみて下さい</a>。</p>
<p>WebGLの知識が全くなくて、GLSLやシェーダー、GPUが何をしているのかわからない場合は、
<a href="webgl-how-it-works.html">WebGLの仕組み</a>をチェックしてみて下さい。</p>
<p>また、WebGLの基本的な動き方を理解する別の方法として、
この<a href="/webgl/lessons/resources/webgl-state-diagram.html">インタラクティブな状態図</a>を見るのもいいかもしれません。</p>
<p>また、サンプルで使用している <a href="webgl-boilerplate.html">ボイラープレートコード</a>も簡単に読んでおきましょう。
通常のWebGLアプリの構造を理解するために<a href="webgl-drawing-multiple-things.html">複数のものを描画する方法</a>も読んでおくと良いです。</p>
<p>それ以外の場合は、ここからは2つの方向に進む事ができます。
画像処理に興味がある方は、<a href="webgl-image-processing.html">2D画像を処理する方法</a>を見て下さい。
もし移動・回転・拡大縮小の学習に興味があれば<a href="webgl-2d-translation.html">ここから始めて下さい</a>。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fundamentals.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" selected>日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-getting-webgl2.html">WebGL2の使い方</a></li>
<li><a href="/webgl/lessons/ja/webgl-fundamentals.html">基本</a></li>
<li><a href="/webgl/lessons/ja/webgl-how-it-works.html">WebGLの仕組み</a></li>
<li><a href="/webgl/lessons/ja/webgl-shaders-and-glsl.html">シェーダーとGLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl2-whats-new.html">WebGL2の新機能</a></li>
<li><a href="/webgl/lessons/ja/webgl1-to-webgl2.html">WebGL1からWebGL2への移行</a></li>
<li><a href="/webgl/lessons/ja/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.orgとWebGL2Fundamentals.orgとの違い</a></li>
        </ul>
  <li>画像処理</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-image-processing.html">WebGL2における画像処理</a></li>
<li><a href="/webgl/lessons/ja/webgl-image-processing-continued.html">WebGL2における画像処理の続き</a></li>
        </ul>
  <li>2Dの移動、回転、スケール、行列計算</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/ja/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>ライティング</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>構造と組織</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ja/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/ja/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>ジオメトリ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ja/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ja/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/ja/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ja/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/ja/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/ja/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>テクスチャのレンダリング</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>シャドウ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/ja/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ja/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ja/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ja/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ja/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ja/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ja/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ja/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ja/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>最適化</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ja/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>その他</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/ja/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ja/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/ja/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/ja/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ja/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ja/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ja/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/ja/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/ja/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ja/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/ja/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ja/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>リファレンス</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ja/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ja/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ja/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ja/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2の基本';
            var disqus_title = 'WebGL2の基本';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




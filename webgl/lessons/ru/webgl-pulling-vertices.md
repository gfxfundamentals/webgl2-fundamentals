Title: WebGL2 Вытягивание вершин
Description: Использование независимых индексов
TOC: Вытягивание вершин

В этой статье предполагается, что вы уже прочитали многие другие статьи,
начиная с [основ](webgl-fundamentals.html).
Если вы их не читали, начните с них.

Традиционно WebGL-приложения помещают геометрические данные в буферы.
Затем с помощью атрибутов эти данные автоматически подаются из буферов
в вершинный шейдер, где программист пишет код для преобразования их в clip space.

Слово **традиционно** здесь важно. Это всего лишь **традиция**
делать так. Это вовсе не требование. WebGL не
заботится о том, как мы это делаем, ему важно только, чтобы наш вершинный шейдер
присваивал координаты clip space переменной `gl_Position`.

Давайте нарисуем куб с текстурой, используя код, похожий на примеры из [статьи о текстурах](webgl-3d-textures.html).
Говорят, что нам нужно как минимум 24 уникальные вершины. Это потому, что, хотя у куба всего 8 угловых
позиций, один и тот же угол используется на 3 разных гранях,
и для каждой грани нужны свои текстурные координаты.

<div class="webgl_center"><img src="resources/cube-vertices-uv.svg" style="width: 400px;"></div>

На диаграмме выше видно, что для левой грани угол 3 требует
текстурных координат 1,1, а для правой грани тот же угол 3 требует
координат 0,1. Для верхней грани понадобятся ещё другие координаты.

Обычно это реализуется так: из 8 угловых позиций
делают 24 вершины

```js
  // front
  { pos: [-1, -1,  1], uv: [0, 1], }, // 0
  { pos: [ 1, -1,  1], uv: [1, 1], }, // 1
  { pos: [-1,  1,  1], uv: [0, 0], }, // 2
  { pos: [ 1,  1,  1], uv: [1, 0], }, // 3
  // right
  { pos: [ 1, -1,  1], uv: [0, 1], }, // 4
  { pos: [ 1, -1, -1], uv: [1, 1], }, // 5
  { pos: [ 1,  1,  1], uv: [0, 0], }, // 6
  { pos: [ 1,  1, -1], uv: [1, 0], }, // 7
  // back
  { pos: [ 1, -1, -1], uv: [0, 1], }, // 8
  { pos: [-1, -1, -1], uv: [1, 1], }, // 9
  { pos: [ 1,  1, -1], uv: [0, 0], }, // 10
  { pos: [-1,  1, -1], uv: [1, 0], }, // 11
  // left
  { pos: [-1, -1, -1], uv: [0, 1], }, // 12
  { pos: [-1, -1,  1], uv: [1, 1], }, // 13
  { pos: [-1,  1, -1], uv: [0, 0], }, // 14
  { pos: [-1,  1,  1], uv: [1, 0], }, // 15
  // top
  { pos: [ 1,  1, -1], uv: [0, 1], }, // 16
  { pos: [-1,  1, -1], uv: [1, 1], }, // 17
  { pos: [ 1,  1,  1], uv: [0, 0], }, // 18
  { pos: [-1,  1,  1], uv: [1, 0], }, // 19
  // bottom
  { pos: [ 1, -1,  1], uv: [0, 1], }, // 20
  { pos: [-1, -1,  1], uv: [1, 1], }, // 21
  { pos: [ 1, -1, -1], uv: [0, 0], }, // 22
  { pos: [-1, -1, -1], uv: [1, 0], }, // 23
```

Эти позиции и текстурные координаты
кладутся в буферы и подаются в вершинный шейдер
через атрибуты.

Но обязательно ли делать именно так? А что если
мы хотим оставить только 8 углов
и 4 текстурные координаты? Например:

```js
positions = [
  -1, -1,  1,  // 0
   1, -1,  1,  // 1
  -1,  1,  1,  // 2
   1,  1,  1,  // 3
  -1, -1, -1,  // 4
   1, -1, -1,  // 5
  -1,  1, -1,  // 6
   1,  1, -1,  // 7
];
uvs = [
  0, 0,  // 0
  1, 0,  // 1
  0, 1,  // 2
  1, 1,  // 3
];
```

А для каждой из 24 вершин мы бы указывали, какие из них использовать.

```js
positionIndexUVIndex = [
  // front
  0, 1, // 0
  1, 3, // 1
  2, 0, // 2
  3, 2, // 3
  // right
  1, 1, // 4
  5, 3, // 5
  3, 0, // 6
  7, 2, // 7
  // back
  5, 1, // 8
  4, 3, // 9
  7, 0, // 10
  6, 2, // 11
  // left
  4, 1, // 12
  0, 3, // 13
  6, 0, // 14
  2, 2, // 15
  // top
  7, 1, // 16
  6, 3, // 17
  3, 0, // 18
  2, 2, // 19
  // bottom
  1, 1, // 20
  0, 3, // 21
  5, 0, // 22
  4, 2, // 23
];
```

Можно ли использовать это на GPU? Почему бы и нет!?

Мы загрузим позиции и текстурные координаты
каждую в свою текстуру, как
рассматривалось в [статье о data-текстурах](webgl-data-textures.html).

```js
function makeDataTexture(gl, data, numComponents) {
  // расширяем данные до 4 значений на пиксель
  const numElements = data.length / numComponents;
  const expandedData = new Float32Array(numElements * 4);
  for (let i = 0; i < numElements; ++i) {
    const srcOff = i * numComponents;
    const dstOff = i * 4;
    for (let j = 0; j < numComponents; ++j) {
      expandedData[dstOff + j] = data[srcOff + j];
    }
  }
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(
      gl.TEXTURE_2D,
      0,            // mip уровень
      gl.RGBA32F,   // формат
      numElements,  // ширина
      1,            // высота
      0,            // граница
      gl.RGBA,      // формат
      gl.FLOAT,     // тип
      expandedData,
  );
  // фильтрация не нужна
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  return tex;
}

const positionTexture = makeDataTexture(gl, positions, 3);
const texcoordTexture = makeDataTexture(gl, uvs, 2);
```

Поскольку в текстуре может быть до 4 значений на пиксель, функция `makeDataTexture`
расширяет любые данные до 4 значений на пиксель.

Далее создаём vertex array для хранения состояния атрибутов

```js
// создаём vertex array object для хранения состояния атрибутов
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
```

Теперь нужно загрузить индексы позиций и texcoord в буфер.

```js
// Создаём буфер для индексов позиций и UV
const positionIndexUVIndexBuffer = gl.createBuffer();
// Биндим его к ARRAY_BUFFER (думаем об этом как ARRAY_BUFFER = positionBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, positionIndexUVIndexBuffer);
// Кладём индексы позиций и texcoord в буфер
gl.bufferData(gl.ARRAY_BUFFER, new Uint32Array(positionIndexUVIndex), gl.STATIC_DRAW);
```

и настраиваем атрибут

```js
// Включаем атрибут индекса позиции
gl.enableVertexAttribArray(posTexIndexLoc);

// Говорим атрибуту индекса позиции/texcoord, как забирать данные из буфера 
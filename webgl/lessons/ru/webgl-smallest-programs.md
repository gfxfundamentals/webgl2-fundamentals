Title: WebGL2 Самые маленькие программы
Description: Самый маленький код для тестирования
TOC: Самые маленькие программы

Эта статья предполагает, что вы прочитали многие другие статьи,
начиная с [основ](webgl-fundamentals.html).
Если вы их не читали, пожалуйста, начните сначала с них.

Я не совсем знаю, под что подвести эту статью, потому что у неё есть две
цели.

1. Показать вам самые маленькие WebGL программы.

   Эти техники супер полезны для тестирования чего-то или
   при создании [MCVE для Stack Overflow](https://meta.stackoverflow.com/a/349790/128511) или при попытке сузить
   ошибку.

2. Обучение думать нестандартно

   Я надеюсь написать еще несколько статей на эту тему,
   чтобы помочь вам увидеть большую картину, а не только общие паттерны.
   [Вот одна](webgl-drawing-without-data.html).

## Просто очистка

Вот самая маленькая WebGL программа, которая действительно что-то делает

```js
const gl = document.querySelector('canvas').getContext('webgl2');
gl.clearColor(1, 0, 0, 1);  // красный
gl.clear(gl.COLOR_BUFFER_BIT);
```

Все, что делает эта программа - очищает canvas до красного, но она действительно что-то сделала.

Подумайте об этом. С помощью только этого вы можете фактически тестировать некоторые вещи. Допустим,
вы [рендерите в текстуру](webgl-render-to-texture.html), но что-то не работает.
Допустим, это точно как в примере в [той статье](webgl-render-to-texture.html).
Вы рендерите 1 или более 3D вещей в текстуру, затем рендерите этот результат на куб.

Вы ничего не видите. Ну, как простой тест, остановите рендеринг в текстуру с
шейдерами и просто очистите текстуру до известного цвета.

```js
gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferWithTexture)
gl.clearColor(1, 0, 1, 1);  // пурпурный
gl.clear(gl.COLOR_BUFFER_BIT);
```

Теперь рендерите с текстурой из framebuffer. Ваш куб становится пурпурным? Если нет,
то ваша проблема не в части рендеринга в текстуру, это что-то другое.

## Использование `SCISSOR_TEST` и `gl.clear`

`SCISSOR_TEST` обрезает как рисование, так и очистку до некоторого подпрямоугольника canvas (или текущего framebuffer).

Вы включаете тест ножниц с помощью

```js
gl.enable(gl.SCISSOR_TEST);
```

и затем вы устанавливаете прямоугольник ножниц в пикселях относительно нижнего левого угла. Он использует те же параметры,
что и `gl.viewport`.

```js
gl.scissor(x, y, width, height);
```

Используя это, можно рисовать прямоугольники с помощью `SCISSOR_TEST` и `gl.clear`.

Пример

```js
const gl = document.querySelector('#c').getContext('webgl2');

gl.enable(gl.SCISSOR_TEST);

function drawRect(x, y, width, height, color) {
  gl.scissor(x, y, width, height);
  gl.clearColor(...color);
  gl.clear(gl.COLOR_BUFFER_BIT);
}

for (let i = 0; i < 100; ++i) {
  const x = rand(0, 300);
  const y = rand(0, 150);
  const width = rand(0, 300 - x);
  const height = rand(0, 150 - y);
  drawRect(x, y, width, height, [rand(1), rand(1), rand(1), 1]);
}


function rand(min, max) {
  if (max === undefined) {
    max = min;
    min = 0;
  }
  return Math.random() * (max - min) + min;
}
```

{{{example url="../webgl-simple-scissor.html"}}}

Не говорю, что этот конкретный пример очень полезен, но все же
хорошо знать.

## Использование одной большой `gl.POINTS`

Как показывают большинство примеров, самая распространенная вещь для выполнения в WebGL
- это создание буферов. Поместить данные вершин в эти буферы. Создать
шейдеры с атрибутами. Настроить атрибуты для извлечения данных из
этих буферов. Затем рисовать, возможно, с uniforms и текстурами, также
используемыми вашими шейдерами.

Но иногда вы просто хотите протестировать. Допустим, вы хотите просто увидеть,
как что-то рисуется.

Как насчет этого набора шейдеров

```glsl
#version 300 es
// вершинный шейдер
void main() {
  gl_Position = vec4(0, 0, 0, 1);  // центр
  gl_PointSize = 120.0;
}
```

```glsl
#version 300 es
// фрагментный шейдер
precision highp float;

out vec4 outColor;

void main() {
  outColor = vec4(1, 0, 0, 1);  // красный
}
```

И вот код для его использования

```js
// настройка GLSL программы
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);

gl.useProgram(program);

const offset = 0;
const count = 1;
gl.drawArrays(gl.POINTS, offset, count);
```

Никаких буферов для создания, никаких uniforms для настройки, и мы получаем одну
точку в центре canvas.

{{{example url="../webgl-simple-point.html"}}}

О `gl.POINTS`: Когда вы передаете `gl.POINTS` в `gl.drawArrays`, вы также
обязаны установить `gl_PointSize` в вашем вершинном шейдере в размер в пикселях. Важно
отметить, что разные GPU/Драйверы имеют разный максимальный размер точки,
который вы можете использовать. Вы можете запросить этот максимальный размер с помощью

```
const [minSize, maxSize] = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
```

Спецификация WebGL требует только максимальный размер 1.0. К счастью,
[большинство, если не все GPU и драйверы поддерживают больший размер](https://web3dsurvey.com/webgl/parameters/ALIASED_POINT_SIZE_RANGE).

После того, как вы установите `gl_PointSize`, когда вершинный шейдер завершится, любое значение, которое вы установили на `gl_Position`, преобразуется
в экранное/canvas пространство в пикселях, затем генерируется квадрат вокруг этой позиции, который составляет +/- gl_PointSize / 2 во всех 4 направлениях.

Хорошо, я слышу, как вы думаете, ну и что, кто хочет рисовать одну точку.

Ну, точки автоматически получают бесплатные [координаты текстуры](webgl-3d-textures.html). Они доступны во фрагментном
шейдере с специальной переменной `gl_PointCoord`. Итак, давайте нарисуем текстуру на этой точке.

Сначала давайте изменим фрагментный шейдер.

```glsl
#version 300 es
// фрагментный шейдер
precision highp float;

+uniform sampler tex;

out vec4 outColor;

void main() {
-  outColor = vec4(1, 0, 0, 1);  // красный
+  outColor = texture(tex, gl_PointCoord.xy);
}
```

Теперь, чтобы держать это простым, давайте сделаем текстуру с сырыми данными, как мы покрыли в
[статье о текстурах данных](webgl-data-textures.html).

```js 
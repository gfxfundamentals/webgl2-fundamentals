Title: Как работает WebGL2
Description: Что WebGL на самом деле делает под капотом
TOC: Как это работает


Это продолжение [Основ WebGL](webgl-fundamentals.html).
Прежде чем мы продолжим, я думаю, нам нужно обсудить на
базовом уровне, что WebGL и ваш GPU на самом деле делают. Есть в основном 2
части в этой GPU штуке. Первая часть обрабатывает вершины (или потоки
данных) в вершины clip space. Вторая часть рисует пиксели на основе
первой части.

Когда вы вызываете

    gl.drawArrays(gl.TRIANGLES, 0, 9);

9 там означает "обработать 9 вершин", так что вот 9 вершин обрабатываются.

<div class="webgl_center"><img src="resources/vertex-shader-anim.gif" /></div>

Слева данные, которые вы предоставляете. Вершинный шейдер - это функция, которую вы
пишете на [GLSL](webgl-shaders-and-glsl.html). Она вызывается один раз для каждой вершины.
Вы делаете некоторую математику и устанавливаете специальную переменную `gl_Position` значением clip space
для текущей вершины. GPU берет это значение и сохраняет его внутренне.

Предполагая, что вы рисуете `TRIANGLES`, каждый раз, когда эта первая часть генерирует 3
вершины, GPU использует их для создания треугольника. Он выясняет, каким
пикселям соответствуют 3 точки треугольника, а затем растеризует
треугольник, что является модным словом для "рисует его пикселями". Для каждого
пикселя он вызовет ваш фрагментный шейдер, спрашивая, какой цвет сделать для этого
пикселя. Ваш фрагментный шейдер выводит vec4
с цветом, который он хочет для этого пикселя.

Это все очень интересно, но как вы можете видеть в наших примерах до
этого момента фрагментный шейдер имеет очень мало информации на пиксель.
К счастью, мы можем передать ему больше информации. Мы определяем "varyings" для каждого
значения, которое мы хотим передать от вершинного шейдера к фрагментному шейдеру.

Как простой пример, давайте просто передадим координаты clip space, которые мы вычислили
напрямую от вершинного шейдера к фрагментному шейдеру.

Мы будем рисовать простым треугольником. Продолжая с нашего
[предыдущего примера](webgl-2d-matrices.html), давайте изменим наш прямоугольник на
треугольник.

    // Заполняем буфер значениями, которые определяют треугольник.
    function setGeometry(gl) {
      gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([
                 0, -100,
               150,  125,
              -175,  100]),
          gl.STATIC_DRAW);
    }

И нам нужно рисовать только 3 вершины.

    // Рисуем сцену.
    function drawScene() {
      ...
      // Рисуем геометрию.
    *  gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

Затем в нашем вершинном шейдере мы объявляем *varying*, делая `out` для передачи данных в
фрагментный шейдер.

    out vec4 v_color;
    ...
    void main() {
      // Умножаем позицию на матрицу.
      gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);

      // Преобразуем из clip space в цветовое пространство.
      // Clip space идет от -1.0 до +1.0
      // Цветовое пространство идет от 0.0 до 1.0
    *  v_color = gl_Position * 0.5 + 0.5;
    }

И затем мы объявляем тот же *varying* как `in` в фрагментном шейдере.

    #version 300 es

    precision highp float;

    in vec4 v_color;

    out vec4 outColor;

    void main() {
    *  outColor = v_color;
    }

WebGL соединит varying в вершинном шейдере с varying
того же имени и типа в фрагментном шейдере.

Вот рабочая версия.

{{{example url="../webgl-2d-triangle-with-position-for-color.html" }}}

Перемещайте, масштабируйте и поворачивайте треугольник. Обратите внимание, что поскольку цвета
вычисляются из clip space, они не двигаются с треугольником. Они
относительны к фону.

Теперь подумайте об этом. Мы вычисляем только 3 вершины. Наш вершинный шейдер
вызывается только 3 раза, поэтому он вычисляет только 3 цвета, но наш
треугольник имеет много цветов. Вот почему это называется *varying*.

WebGL берет 3 значения, которые мы вычислили для каждой вершины, и когда он растеризует
треугольник, он интерполирует между значениями, которые мы вычислили для
вершин. Для каждого пикселя он вызывает наш фрагментный шейдер с
интерполированным значением для этого пикселя.

В примере выше мы начинаем с 3 вершин

<style>
table.vertex_table {
  border: 1px solid black;
  border-collapse: collapse;
  font-family: monospace;
  font-size: small;
}

table.vertex_table th {
  background-color: #88ccff;
  padding-right: 1em;
  padding-left: 1em;
}

table.vertex_table td {
  border: 1px solid black;
  text-align: right;
  padding-right: 1em;
  padding-left: 1em;
}
</style>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="2">Вершины</th></tr>
<tr><td>0</td><td>-100</td></tr>
<tr><td>150</td><td>125</td></tr>
<tr><td>-175</td><td>100</td></tr>
</table>
</div>

Наш вершинный шейдер применяет матрицу для перемещения, поворота, масштабирования и преобразования
в clip space. Значения по умолчанию для перемещения, поворота и масштабирования:
перемещение = 200, 150, поворот = 0, масштаб = 1,1, так что это действительно только
перемещение. Учитывая, что наш backbuffer 400x300, наш вершинный шейдер применяет
матрицу и затем вычисляет следующие 3 вершины clip space.

<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">значения, записанные в gl_Position</th></tr>
<tr><td>0.000</td><td>0.660</td></tr>
<tr><td>0.750</td><td>-0.830</td></tr>
<tr><td>-0.875</td><td>-0.660</td></tr>
</table>
</div>

Он также преобразует их в цветовое пространство и записывает их в *varying*
v_color, который мы объявили.

<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">значения, записанные в v_color</th></tr>
<tr><td>0.5000</td><td>0.830</td><td>0.5</td></tr>
<tr><td>0.8750</td><td>0.086</td><td>0.5</td></tr>
<tr><td>0.0625</td><td>0.170</td><td>0.5</td></tr>
</table>
</div>

Те 3 значения, записанные в v_color, затем интерполируются и передаются в
фрагментный шейдер для каждого пикселя.

{{{diagram url="resources/fragment-shader-anim.html" width="600" height="400" caption="v_color интерполируется между v0, v1 и v2" }}}

Мы также можем передать больше данных в вершинный шейдер, которые мы можем затем передать
в фрагментный шейдер. Так, например, давайте нарисуем прямоугольник, который
состоит из 2 треугольников, в 2 цветах. Для этого мы добавим еще один
атрибут в вершинный шейдер, чтобы мы могли передать ему больше данных, и мы передадим
эти данные напрямую в фрагментный шейдер.

    in vec2 a_position;
    +in vec4 a_color;
    ...
    out vec4 v_color;

    void main() {
       ...
      // Копируем цвет из атрибута в varying.
    *  v_color = a_color;
    }

Теперь нам нужно предоставить цвета для WebGL.

      // ищем, куда должны идти данные вершин.
      var positionLocation = gl.getAttribLocation(program, "a_position");
    +  var colorLocation = gl.getAttribLocation(program, "a_color"); 
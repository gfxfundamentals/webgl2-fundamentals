Title: Как загружать изображения в фоне без задержек
Description: Как загружать изображения в фоне без задержек
TOC: Как загружать изображения в фоне без задержек

## Вопрос:

В нашем WebGL приложении я пытаюсь загружать и декодировать текстуры в web worker, чтобы избежать задержек рендеринга в основном потоке. Использование createImageBitmap в worker и передача image bitmap обратно в основной поток работает хорошо, но в Chrome это использует **три** или больше (возможно, в зависимости от количества ядер?) отдельных workers (ThreadPoolForegroundWorker), которые вместе с основным потоком и моим собственным worker дают пять потоков.

Я предполагаю, что это вызывает оставшиеся нарушения рендеринга на моём четырёхъядерном процессоре, поскольку я вижу необъяснимо долгие времена в функции Performance в DevTools Chrome.

Итак, могу ли я как-то ограничить количество workers, используемых createImageBitmap? Даже если я передаю изображения как blobs или array buffers в основной поток и активирую createImageBitmap оттуда, его workers будут конкурировать с моим собственным worker и основным потоком.

Я пробовал создавать обычные Images в worker вместо этого, чтобы явно декодировать их там, но Image не определён в контексте worker, как и document, если я хочу создать их как элементы. И обычные Images тоже не передаваемые, так что создание их в основном потоке и передача в worker тоже не кажется осуществимой.

Жду любых предложений...

## Ответ:

Нет причин использовать createImageBitmap в worker (ну, см. внизу). Браузер уже декодирует изображение в отдельном потоке. Делать это в worker ничего не даёт. Большая проблема в том, что ImageBitmap не может знать, как вы собираетесь использовать изображение, когда наконец передадите его в WebGL. Если вы запросите формат, отличный от того, что декодировал ImageBitmap, то WebGL должен конвертировать и/или декодировать его снова, и вы не можете дать ImageBitmap достаточно информации, чтобы сказать ему, в каком формате вы хотите его декодировать.

Кроме того, WebGL в Chrome должен передавать данные изображения из процесса рендеринга в GPU процесс, что для большого изображения является относительно большой копией (1024x1024 по RGBA это 4 мега)

Лучший API, на мой взгляд, позволил бы вам сказать ImageBitmap, какой формат вы хотите и где вы хотите его (CPU, GPU). Таким образом браузер мог бы асинхронно подготовить изображение и не требовал бы тяжёлой работы при завершении.

В любом случае, вот тест. Если вы снимите галочку "update texture", то текстуры всё ещё скачиваются и декодируются, но просто не вызывается `gl.texImage2D` для загрузки текстуры. В этом случае я не вижу задержек (не доказательство, что это проблема, но я думаю, что проблема там)

{{{example url="../webgl-qna-how-to-load-images-in-the-background-with-no-jank-example-1.html"}}}

Я довольно уверен, что единственный способ, которым вы могли бы гарантировать отсутствие задержек — это декодировать изображения самостоятельно в worker, передавать в основной поток как arraybuffer и загружать в WebGL по несколько строк за кадр с `gl.bufferSubData`.

{{{example url="../webgl-qna-how-to-load-images-in-the-background-with-no-jank-example-2.html"}}}

Примечание: Я не знаю, что это тоже будет работать. Несколько мест, которые пугают и зависят от реализации браузера

1. Какие проблемы производительности при изменении размера canvas. Код изменяет размер OffscreenCanvas в worker. Это может быть тяжёлая операция с последствиями для GPU.

2. Какая производительность рисования bitmap в canvas? Снова большие проблемы производительности GPU, поскольку браузер должен передать изображение на GPU, чтобы нарисовать его в GPU 2D canvas.

3. Какая производительность getImageData? Снова браузер должен потенциально заморозить GPU, чтобы прочитать память GPU и получить данные изображения.

4. Возможный удар по производительности при изменении размера текстуры.

5. Только Chrome в настоящее время поддерживает OffscreenCanvas

1, 2, 3 и 5 могут быть решены декодированием [jpg](https://github.com/notmasteryet/jpgjs), [png](https://github.com/arian/pngjs) изображения самостоятельно, хотя действительно отстойно, что браузер имеет код для декодирования изображения, просто вы не можете получить доступ к коду декодирования никаким полезным способом.

Для 4, если это проблема, это может быть решено выделением текстуры максимального размера изображения и затем копированием меньших текстур в прямоугольную область. Предполагая, что это проблема

{{{example url="../webgl-qna-how-to-load-images-in-the-background-with-no-jank-example-3.html"}}}

примечание: jpeg декодер медленный. Если найдёте или сделаете более быстрый, пожалуйста, оставьте комментарий

---

# Обновление

Я просто хочу сказать, что `ImageBitmap` **должен** быть достаточно быстрым и что некоторые из моих комментариев выше о том, что у него недостаточно информации, могут быть не совсем правильными.

Моё текущее понимание в том, что вся суть `ImageBitmap` была в том, чтобы сделать загрузки быстрыми. Это должно работать так: вы даёте ему blob и асинхронно он загружает это изображение в GPU. Когда вы вызываете `texImage2D` с ним, браузер может "blit" (рендерить с GPU) это изображение в вашу текстуру. Я не знаю, почему есть задержки в первом примере, учитывая это, но я вижу задержки каждые 6 или около того изображений.

С другой стороны, хотя загрузка изображения в GPU была целью `ImageBitmap`, браузеры не обязаны загружать в GPU. `ImageBitmap` всё ещё должен работать, даже если у пользователя нет GPU. Суть в том, что браузер решает, как реализовать функцию, и будет ли она быстрой или медленной, без задержек или с ними — полностью зависит от браузера.

<div class="so">
  <div>Вопрос и процитированные части являются 
    CC BY-SA 4.0 от
    <a data-href="https://stackoverflow.com/users/4105722">Andreas Ekstrand</a>
    из
    <a data-href="https://stackoverflow.com/questions/58856403">здесь</a>
  </div>
</div> 
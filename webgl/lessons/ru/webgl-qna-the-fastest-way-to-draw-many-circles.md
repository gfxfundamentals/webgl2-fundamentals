Title: Самый быстрый способ нарисовать много кругов
Description: Самый быстрый способ нарисовать много кругов
TOC: Самый быстрый способ нарисовать много кругов

## Вопрос:

Сейчас я рисую тысячи кругов, инстанцируя [геометрию круга](https://threejs.org/docs/#api/en/geometries/CircleBufferGeometry) (много треугольников).

[![enter image description here][1]][1]

Альтернативно, я мог бы просто инстанцировать quad (2 треугольника), а круг "вырезать" во фрагментном шейдере с помощью distance-функции и `discard`.

[![enter image description here][2]][2]

Какой подход будет быстрее? — дороже ли рисовать много треугольников, чем вычисления во фрагментном шейдере?

  [1]: https://i.stack.imgur.com/CZhOa.png
  [2]: https://i.stack.imgur.com/BG4p5.png

## Ответ:

Самый быстрый способ может зависеть от GPU и множества других факторов: как вы рисуете круги (2D, 3D), используете ли смешивание (blending), z-buffer и т.д. Но в целом — меньше треугольников быстрее, чем больше, и меньше пикселей быстрее, чем больше. Так что... всё, что мы можем — это попробовать.

Сначала просто нарисуем текстурированные квадраты без blending. У меня на GPU в этом 300x150 canvas с инстансингом получается 20-30 тысяч quad'ов на 60fps.

{{{example url="../webgl-qna-the-fastest-way-to-draw-many-circles-example-1.html"}}}

И такая же производительность при 60fps, если использовать повторяющуюся геометрию вместо инстансинга. Это удивительно, потому что 7-8 лет назад повторяющаяся геометрия была на 20-30% быстрее. Почему — не знаю: лучше GPU, драйвер или что-то ещё.

{{{example url="../webgl-qna-the-fastest-way-to-draw-many-circles-example-2.html"}}}

Дальше — текстуры или вычисление круга во фрагментном шейдере.

{{{example url="../webgl-qna-the-fastest-way-to-draw-many-circles-example-3.html"}}}

Разницы не заметил. Пробую вашу функцию круга:

{{{example url="../webgl-qna-the-fastest-way-to-draw-many-circles-example-4.html"}}}

Опять разницы не заметил. Замечу: как уже говорил, результаты WebGL очень нестабильны. Первый тест — 28k на 60fps, второй — 23k. Ожидал, что второй будет быстрее, но потом снова первый — 23k, последний — 29k, потом предыдущий — 29k. Короче, тестировать производительность в WebGL почти невозможно. Слишком много факторов, всё многопроцессное, получить стабильные результаты невозможно.

Можно попробовать discard:

{{{example url="../webgl-qna-the-fastest-way-to-draw-many-circles-example-5.html"}}}

Судя по ощущениям, discard медленнее. Насколько помню, discard медленный, потому что без него GPU знает заранее, что обновит z-buffer, а с discard — только после выполнения шейдера, и это мешает оптимизациям.

На этом остановлюсь, потому что слишком много комбинаций для тестов.

Можно попробовать включить blending. Blending обычно медленнее, потому что нужно смешивать (читать фон), но медленнее ли, чем discard — не знаю.

Включён ли depth test? Если да, порядок отрисовки важен.

Можно попробовать не-quads, а, например, шестиугольники или восьмиугольники — тогда меньше пикселей попадёт во фрагментный шейдер. Думаю, разницу увидите только на больших кругах. Например, quad 100x100 — это 10k пикселей, идеальный круг — pi*r^2 ≈ 7853, то есть на 21% меньше. Шестиугольник — ~8740 пикселей, на 11% меньше. Восьмиугольник — где-то между. Рисовать на 11-21% меньше пикселей — обычно плюс, но для шестиугольника будет в 3 раза больше треугольников, для восьмиугольника — в 4 раза. Всё надо тестировать.

Это ещё раз показывает, что для больших кругов на большом canvas относительные результаты будут другими: больше пикселей на круг, больше времени на пиксели, меньше — на вершины и/или переключения GPU.

## Обновление

Тесты в Chrome и Firefox: в Chrome на той же машине 60-66k во всех случаях. Почему разница такая большая — не знаю, ведь WebGL почти ничего не делает. Все 4 теста — по одному draw call на кадр. Но, по крайней мере, на 2019-10 Chrome в этом случае в 2 раза быстрее Firefox.

Есть идея: у меня ноутбук с двумя GPU. При создании контекста можно указать, что вы хотите, через атрибут `powerPreference`:

    const gl = document.createContext('webgl', {
      powerPreference: 'high-performance',
    });

Варианты: 'default', 'low-power', 'high-performance'. 'default' — "пусть браузер решает", но в итоге всё равно решает браузер. В любом случае, у меня в Firefox это ничего не меняет.

<div class="so">
  <div>Вопрос и цитируемые части взяты по лицензии CC BY-SA 4.0 у
    <a data-href="http://www.github.com">kindoflike</a>
    с сайта
    <a data-href="https://stackoverflow.com/questions/58354135">stackoverflow</a>
  </div>
</div> 
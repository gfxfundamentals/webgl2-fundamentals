<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-gpgpu.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как выполнять общие вычисления с помощью WebGL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg">

<meta property="og:title" content="WebGL2 GPGPU">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg">
<meta property="og:description" content="Как выполнять общие вычисления с помощью WebGL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 GPGPU">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html">
<meta name="twitter:description" content="Как выполнять общие вычисления с помощью WebGL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html",
      "inLanguage":"ru",
      "name":"WebGL2 GPGPU",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 GPGPU</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-gpgpu.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-gpgpu.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-gpgpu.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-gpgpu.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-gpgpu.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-gpgpu.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-gpgpu.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-gpgpu.html" >English</a>
    <option value="/webgl/lessons/de/webgl-gpgpu.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-gpgpu.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-gpgpu.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-gpgpu.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-gpgpu.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-gpgpu.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 GPGPU</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>GPGPU означает “General Purpose” GPU и означает использование GPU для чего-то
другого, кроме рисования пикселей.</p>
<p>Основное понимание для осознания GPGPU в WebGL заключается в том, что текстура</p>
<ul>
<li>это не изображение, а 2D массив значений. В <a href="webgl-3d-textures.html">статье о текстурах</a>
мы рассмотрели чтение из текстуры. В <a href="webgl-render-to-texture.html">статье о рендеринге в текстуру</a>
мы рассмотрели запись в текстуру. Итак, если осознать, что текстура - это 2D массив значений,
мы можем сказать, что мы действительно описали способ чтения из и записи в 2D массивы.
Аналогично буфер - это не просто позиции, нормали, координаты текстуры и цвета.
Эти данные могут быть чем угодно. Скорости, массы, цены акций и т.д.
Творческое использование этих знаний для выполнения математики - это суть GPGPU в WebGL.</li>
</ul>
<h2 id="сначала-сделаем-это-с-текстурами">Сначала сделаем это с текстурами</h2>
<p>В JavaScript есть функция <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code class="notranslate" translate="no">Array.prototype.map</code></a>, которая для данного массива вызывает функцию для каждого элемента</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function multBy2(v) {
  return v * 2;
}

const src = [1, 2, 3, 4, 5, 6];
const dst = src.map(multBy2);

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<p>Вы можете рассматривать <code class="notranslate" translate="no">multBy2</code> как шейдер, а <code class="notranslate" translate="no">map</code> как аналогичный вызову <code class="notranslate" translate="no">gl.drawArrays</code> или <code class="notranslate" translate="no">gl.drawElements</code>.
Некоторые различия.</p>
<h2 id="шейдеры-не-генерируют-новый-массив-вы-должны-предоставить-его">Шейдеры не генерируют новый массив, вы должны предоставить его</h2>
<p>Мы можем симулировать это, создав собственную функцию map</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function multBy2(v) {
  return v * 2;
}

function mapSrcToDst(src, fn, dst) {
  for (let i = 0; i &lt; src.length; ++i) {
    dst[i] = fn(src[i]);
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapSrcToDst(src, multBy2, dst);

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="шейдеры-не-возвращают-значение-они-устанавливают-переменную-out">Шейдеры не возвращают значение, они устанавливают переменную <code class="notranslate" translate="no">out</code></h2>
<p>Это довольно легко симулировать</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;

function multBy2(v) {
  outColor = v * 2;
}

function mapSrcToDst(src, fn, dst) {
  for (let i = 0; i &lt; src.length; ++i) {
    fn(src[i]);
    dst[i] = outColor;
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapSrcToDst(src, multBy2, dst);

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="шейдеры-основаны-на-назначении-а-не-на-источнике">Шейдеры основаны на назначении, а не на источнике.</h2>
<p>Другими словами, они перебирают назначение и спрашивают “какое значение я должен положить сюда”</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;

function multBy2(src) {
  return function(i) {
    outColor = src[i] * 2;
  }
}

function mapDst(dst, fn) {
  for (let i = 0; i &lt; dst.length; ++i) {    
    fn(i);
    dst[i] = outColor;
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapDst(dst, multBy2(src));

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="в-webgl-индекс-или-id-пикселя-значение-которого-вас-просят-предоставить-называется-gl_fragcoord">В WebGL индекс или ID пикселя, значение которого вас просят предоставить, называется <code class="notranslate" translate="no">gl_FragCoord</code></h2>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;
let gl_FragCoord;

function multBy2(src) {
  return function() {
    outColor = src[gl_FragCoord] * 2;
  }
}

function mapDst(dst, fn) {
  for (let i = 0; i &lt; dst.length; ++i) {    
    gl_FragCoord = i;
    fn();
    dst[i] = outColor;
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapDst(dst, multBy2(src));

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="в-webgl-текстуры---это-2d-массивы">В WebGL текстуры - это 2D массивы.</h2>
<p>Давайте предположим, что наш массив <code class="notranslate" translate="no">dst</code> представляет текстуру 3x2</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;
let gl_FragCoord;

function multBy2(src, across) {
  return function() {
    outColor = src[gl_FragCoord.y * across + gl_FragCoord.x] * 2;
  }
}

function mapDst(dst, across, up, fn) {
  for (let y = 0; y &lt; up; ++y) {
    for (let x = 0; x &lt; across; ++x) {
      gl_FragCoord = {x, y};
      fn();
      dst[y * across + x] = outColor;
    }
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapDst(dst, 3, 2, multBy2(src, 3));

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<p>И мы могли бы продолжать. Я надеюсь, что примеры выше помогают вам увидеть, что GPGPU в WebGL
довольно прост концептуально. Давайте действительно сделаем вышесказанное в WebGL.</p>
<p>Для понимания следующего кода вам нужно будет, как минимум, прочитать
<a href="webgl-fundamentals.html">статью об основах</a>, вероятно, статью о
<a href="webgl-how-it-works.html">Как это работает</a>, статью о <a href="webgl-shaders-and-glsl.html">GLSL</a>
и <a href="webgl-3d-textures.html">статью о текстурах</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 position;
void main() {
  gl_Position = position;
}
`;

const fs = `#version 300 es
precision highp float;

uniform sampler2D srcTex;

out vec4 outColor;

void main() {
  ivec2 texelCoord = ivec2(gl_FragCoord.xy);
  vec4 value = texelFetch(srcTex, texelCoord, 0);  // 0 = mip level 0
  outColor = value * 2.0;
}
`;

const dstWidth = 3;
const dstHeight = 2;

// создаем canvas 3x2 для 6 результатов
const canvas = document.createElement('canvas');
canvas.width = dstWidth;
canvas.height = dstHeight;

const gl = canvas.getContext('webgl2');

const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const positionLoc = gl.getAttribLocation(program, 'position');
const srcTexLoc = gl.getUniformLocation(program, 'srcTex');

// настраиваем полноэкранный quad в clip space
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
  -1,  1,
   1, -1,
   1,  1,
]), gl.STATIC_DRAW);

// Создаем объект вершинного массива (состояние атрибутов)
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// настраиваем наши атрибуты, чтобы сказать WebGL, как извлекать
// данные из буфера выше в атрибут position
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(
    positionLoc,
    2,         // размер (количество компонентов)
    gl.FLOAT,  // тип данных в буфере
    false,     // нормализовать
    0,         // шаг (0 = авто)
    0,         // смещение
);

// создаем нашу исходную текстуру
const srcWidth = 3;
const srcHeight = 2;
const tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1); // см. https://webglfundamentals.org/webgl/lessons/webgl-data-textures.html
gl.texImage2D(
    gl.TEXTURE_2D,
    0,                // mip уровень
    gl.R8,            // внутренний формат
    srcWidth,
    srcHeight,
    0,                // граница
    gl.RED,           // формат
    gl.UNSIGNED_BYTE, // тип
    new Uint8Array([
      1, 2, 3,
      4, 5, 6,
    ]));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

gl.useProgram(program);
gl.uniform1i(srcTexLoc, 0);  // говорим шейдеру, что исходная текстура находится на texture unit 0

gl.drawArrays(gl.TRIANGLES, 0, 6);  // рисуем 2 треугольника (6 вершин)

// получаем результат
const results = new Uint8Array(dstWidth * dstHeight * 4);
gl.readPixels(0, 0, dstWidth, dstHeight, gl.RGBA, gl.UNSIGNED_BYTE, results);

// выводим результаты
for (let i = 0; i &lt; dstWidth * dstHeight; ++i) {
  log(results[i * 4]);
}
</code></pre>
<p>и вот он работает</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-mult-by-2.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-mult-by-2.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Некоторые замечания о коде выше.</p>
<ul>
<li>
<p>Мы рисуем quad в clip space от -1 до +1.</p>
<p>Мы создаем вершины для quad от -1 до +1 из 2 треугольников. Это означает, что при правильной настройке viewport
мы нарисуем все пиксели в назначении. Другими словами, мы попросим
наш шейдер сгенерировать значение для каждого элемента в результирующем массиве. Этот массив в
данном случае - это сам canvas.</p>
</li>
<li>
<p><code class="notranslate" translate="no">texelFetch</code> - это функция текстуры, которая ищет один texel из текстуры.</p>
<p>Она принимает 3 параметра. Сэмплер, координаты texel на основе целых чисел, и mip уровень.
<code class="notranslate" translate="no">gl_FragCoord</code> - это vec2, нам нужно превратить его в <code class="notranslate" translate="no">ivec2</code>, чтобы использовать с
<code class="notranslate" translate="no">texelFetch</code>. Здесь нет дополнительной математики, пока исходная текстура и
текстура назначения имеют одинаковый размер, что в данном случае так и есть.</p>
</li>
<li>
<p>Наш шейдер записывает 4 значения на пиксель</p>
<p>В данном конкретном случае это влияет на то, как мы читаем вывод. Мы просим <code class="notranslate" translate="no">RGBA/UNSIGNED_BYTE</code>
из <code class="notranslate" translate="no">readPixels</code> <a href="webgl-readpixels.html">потому что другие комбинации формата/типа не поддерживаются</a>.
Поэтому нам нужно смотреть на каждое 4-е значение для нашего ответа.</p>
<p>Примечание: Было бы умно попытаться воспользоваться тем фактом, что WebGL делает 4 значения за раз
для еще большей скорости.</p>
</li>
<li>
<p>Мы используем <code class="notranslate" translate="no">R8</code> как внутренний формат нашей текстуры.</p>
<p>Это означает, что только красный канал из текстуры имеет значение из наших данных.</p>
</li>
<li>
<p>И наши входные данные, и выходные данные (canvas) - это значения <code class="notranslate" translate="no">UNSIGNED_BYTE</code></p>
<p>Это означает, что мы можем передавать и получать обратно только целые значения от 0 до 255.
Мы могли бы использовать разные форматы для ввода, предоставляя текстуру другого формата.
Мы также могли бы попытаться рендерить в текстуру другого формата для большего диапазона выходных значений.</p>
</li>
</ul>
<p>В примере выше src и dst имеют одинаковый размер. Давайте изменим это так, чтобы мы добавляли каждые 2 значения
из src, чтобы сделать dst. Другими словами, учитывая <code class="notranslate" translate="no">[1, 2, 3, 4, 5, 6]</code> как ввод, мы хотим
<code class="notranslate" translate="no">[3, 7, 11]</code> как вывод. И далее, давайте сохраним источник как данные 3x2</p>
<p>Основная формула для получения значения из 2D массива, как если бы это был 1D массив</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">y = floor(indexInto1DArray / widthOf2DArray);
x = indexInto1DArray % widthOf2Array;
</code></pre>
<p>Учитывая это, наш фрагментный шейдер должен измениться на это, чтобы добавить каждые 2 значения.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

uniform sampler2D srcTex;
uniform ivec2 dstDimensions;

out vec4 outColor;

vec4 getValueFrom2DTextureAs1DArray(sampler2D tex, ivec2 dimensions, int index) {
  int y = index / dimensions.x;
  int x = index % dimensions.x;
  return texelFetch(tex, ivec2(x, y), 0);
}

void main() {
  // вычисляем 1D индекс в dst
  ivec2 dstPixel = ivec2(gl_FragCoord.xy);
  int dstIndex = dstPixel.y * dstDimensions.x + dstPixel.x;

  ivec2 srcDimensions = textureSize(srcTex, 0);  // размер mip 0

  vec4 v1 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2);
  vec4 v2 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2 + 1);

  outColor = v1 + v2;
}
</code></pre>
<p>Функция <code class="notranslate" translate="no">getValueFrom2DTextureAs1DArray</code> - это в основном наша функция доступа к массиву.
Это означает, что эти 2 строки</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">  vec4 v1 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2.0);
  vec4 v2 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2.0 + 1.0);
</code></pre>
<p>Эффективно означают это</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">  vec4 v1 = srcTexAs1DArray[dstIndex * 2.0];
  vec4 v2 = setTexAs1DArray[dstIndex * 2.0 + 1.0];
</code></pre>
<p>В нашем JavaScript нам нужно найти местоположение <code class="notranslate" translate="no">dstDimensions</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const positionLoc = gl.getAttribLocation(program, 'position');
const srcTexLoc = gl.getUniformLocation(program, 'srcTex');
+const dstDimensionsLoc = gl.getUniformLocation(program, 'dstDimensions');
</code></pre>
<p>и установить его</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);
gl.uniform1i(srcTexLoc, 0);  // говорим шейдеру, что исходная текстура находится на texture unit 0
+gl.uniform2f(dstDimensionsLoc, dstWidth, dstHeight);
</code></pre>
<p>и нам нужно изменить размер назначения (canvas)</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const dstWidth = 3;
-const dstHeight = 2;
+const dstHeight = 1;
</code></pre>
<p>и с этим у нас теперь есть результирующий массив, способный выполнять математику
со случайным доступом в исходный массив</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-add-2-elements.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-add-2-elements.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Если вы хотели бы использовать больше массивов как ввод, просто добавьте больше текстур, чтобы поместить больше
данных в ту же текстуру.</p>
<h2 id="теперь-сделаем-это-с-transform-feedback">Теперь сделаем это с <em>transform feedback</em></h2>
<p>“Transform Feedback” - это модное название для способности записывать вывод
varyings в вершинном шейдере в один или несколько буферов.</p>
<p>Преимущество использования transform feedback в том, что вывод одномерный,
поэтому, вероятно, легче рассуждать об этом. Это даже ближе к <code class="notranslate" translate="no">map</code> из JavaScript.</p>
<p>Давайте возьмем 2 массива значений и выведем их сумму, разность
и произведение. Вот вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es

in float a;
in float b;

out float sum;
out float difference;
out float product;

void main() {
  sum = a + b;
  difference = a - b;
  product = a * b;
}
</code></pre>
<p>и фрагментный шейдер просто достаточно для компиляции</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;
void main() {
}
</code></pre>
<p>Чтобы использовать transform feedback, мы должны сказать WebGL, какие varyings мы хотим записать
и в каком порядке. Мы делаем это, вызывая <code class="notranslate" translate="no">gl.transformFeedbackVaryings</code> перед
линковкой шейдерной программы. Из-за этого мы не будем использовать наш помощник
для компиляции шейдеров и линковки программы на этот раз, просто чтобы было ясно,
что мы должны сделать.</p>
<p>Итак, вот код для компиляции шейдера, аналогичный коду в самой
<a href="webgl-fundamentals.html">первой статье</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function createShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}
</code></pre>
<p>Мы будем использовать его для компиляции наших 2 шейдеров, а затем прикрепить их и вызвать
<code class="notranslate" translate="no">gl.transformFeedbackVaryings</code> перед линковкой</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vShader = createShader(gl, gl.VERTEX_SHADER, vs);
const fShader = createShader(gl, gl.FRAGMENT_SHADER, fs);

const program = gl.createProgram();
gl.attachShader(program, vShader);
gl.attachShader(program, fShader);
gl.transformFeedbackVaryings(
    program,
    ['sum', 'difference', 'product'],
    gl.SEPARATE_ATTRIBS,
);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  throw new Error(gl.getProgramParameter(program));
}
</code></pre>
<p><code class="notranslate" translate="no">gl.transformFeedbackVaryings</code> принимает 3 аргумента. Программу, массив имен
varyings, которые мы хотим записать в том порядке, в котором вы хотите их записать.
Если бы у вас был фрагментный шейдер, который действительно что-то делал,
то, возможно, некоторые из ваших varyings предназначены только для фрагментного шейдера и поэтому
не нуждаются в записи. В нашем случае мы запишем все наши varyings, поэтому передаем
имена всех 3. Последний параметр может быть одним из 2 значений. Либо <code class="notranslate" translate="no">SEPARATE_ATTRIBS</code>,
либо <code class="notranslate" translate="no">INTERLEAVED_ATTRIBS</code>.</p>
<p><code class="notranslate" translate="no">SEPARATE_ATTRIBS</code> означает, что каждый varying будет записан в другой буфер.
<code class="notranslate" translate="no">INTERLEAVED_ATTRIBS</code> означает, что все varyings будут записаны в тот же буфер,
но перемежаться в том порядке, который мы указали. В нашем случае, поскольку мы указали
<code class="notranslate" translate="no">['sum', 'difference', 'product']</code>, если бы мы использовали <code class="notranslate" translate="no">INTERLEAVED_ATTRIBS</code>, вывод
был бы <code class="notranslate" translate="no">sum0, difference0, product0, sum1, difference1, product1, sum2, difference2, product2, etc...</code>
в один буфер. Мы используем <code class="notranslate" translate="no">SEPARATE_ATTRIBS</code>, поэтому вместо этого
каждый вывод будет записан в другой буфер.</p>
<p>Итак, как и в других примерах, нам нужно настроить буферы для наших входных атрибутов</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const aLoc = gl.getAttribLocation(program, 'a');
const bLoc = gl.getAttribLocation(program, 'b');

// Создаем объект вершинного массива (состояние атрибутов)
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

function makeBuffer(gl, sizeOrData) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, gl.STATIC_DRAW);
  return buf;
}

function makeBufferAndSetAttribute(gl, data, loc) {
  const buf = makeBuffer(gl, data);
  // настраиваем наши атрибуты, чтобы сказать WebGL, как извлекать
  // данные из буфера выше в атрибут
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(
      loc,
      1,         // размер (количество компонентов)
      gl.FLOAT,  // тип данных в буфере
      false,     // нормализовать
      0,         // шаг (0 = авто)
      0,         // смещение
  );
}

const a = [1, 2, 3, 4, 5, 6];
const b = [3, 6, 9, 12, 15, 18];

// помещаем данные в буферы
const aBuffer = makeBufferAndSetAttribute(gl, new Float32Array(a), aLoc);
const bBuffer = makeBufferAndSetAttribute(gl, new Float32Array(b), bLoc);
</code></pre>
<p>Затем нам нужно настроить “transform feedback”. “Transform feedback” - это объект,
который содержит состояние буферов, в которые мы будем записывать. В то время как <a href="webgl-attributes.html">вершинный массив</a>
указывает состояние всех входных атрибутов, “transform feedback” содержит
состояние всех выходных атрибутов.</p>
<p>Вот код для настройки нашего</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Создаем и заполняем transform feedback
const tf = gl.createTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);

// создаем буферы для вывода
const sumBuffer = makeBuffer(gl, a.length * 4);
const differenceBuffer = makeBuffer(gl, a.length * 4);
const productBuffer = makeBuffer(gl, a.length * 4);

// привязываем буферы к transform feedback
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, sumBuffer);
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, differenceBuffer);
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, productBuffer);

gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

// буферы, в которые мы записываем, не могут быть привязаны где-то еще
gl.bindBuffer(gl.ARRAY_BUFFER, null);  // productBuffer все еще был привязан к ARRAY_BUFFER, поэтому отвязываем его
</code></pre>
<p>Мы вызываем <code class="notranslate" translate="no">bindBufferBase</code>, чтобы установить, в какой буфер каждый из выходов, выход 0, выход 1 и выход 2
будет записывать. Выходы 0, 1, 2 соответствуют именам, которые мы передали в <code class="notranslate" translate="no">gl.transformFeedbackVaryings</code>
когда мы линковали программу.</p>
<p>Когда мы закончили, “transform feedback”, который мы создали, имеет состояние, как это</p>
<img src="../resources/transform-feedback-diagram.png" style="width: 625px;" class="webgl_center">
<p>Есть также функция <code class="notranslate" translate="no">bindBufferRange</code>, которая позволяет нам указать поддиапазон в буфере, где
мы будем записывать, но мы не будем использовать это здесь.</p>
<p>Итак, чтобы выполнить шейдер, мы делаем это</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

// привязываем наше состояние входных атрибутов для буферов a и b
gl.bindVertexArray(vao);

// нет необходимости вызывать фрагментный шейдер
gl.enable(gl.RASTERIZER_DISCARD);

gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
gl.beginTransformFeedback(gl.POINTS);
gl.drawArrays(gl.POINTS, 0, a.length);
gl.endTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

// включаем использование фрагментных шейдеров снова
gl.disable(gl.RASTERIZER_DISCARD);
</code></pre>
<p>Мы отключаем вызов фрагментного шейдера. Мы привязываем объект transform feedback,
который мы создали ранее, мы включаем transform feedback, затем мы вызываем draw.</p>
<p>Чтобы посмотреть на значения, мы можем вызвать <code class="notranslate" translate="no">gl.getBufferSubData</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">log(`a: ${a}`);
log(`b: ${b}`);

printResults(gl, sumBuffer, 'sums');
printResults(gl, differenceBuffer, 'differences');
printResults(gl, productBuffer, 'products');

function printResults(gl, buffer, label) {
  const results = new Float32Array(a.length);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.getBufferSubData(
      gl.ARRAY_BUFFER,
      0,    // смещение в байтах в GPU буфере,
      results,
  );
  // выводим результаты
  log(`${label}: ${results}`);
}
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-sum-difference-product-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-sum-difference-product-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Вы можете видеть, что это сработало. Мы заставили GPU вычислить сумму, разность и произведение
значений ‘a’ и ‘b’, которые мы передали.</p>
<p>Примечание: Вы можете найти <a href="https://webgl2fundamentals.org/webgl/lessons/resources/webgl-state-diagram.html?exampleId=transform-feedback">этот пример диаграммы состояния transform feedback</a> полезным для визуализации того, что такое “transform feedback”.
Это не тот же пример, что выше, хотя. Вершинный шейдер, который он использует с transform feedback, генерирует позиции и цвета для круга точек.</p>
<h2 id="первый-пример-частицы">Первый пример: частицы</h2>
<p>Допустим, у вас есть очень простая система частиц.
Каждая частица просто имеет позицию и скорость, и
если она выходит за один край экрана, она оборачивается вокруг
другой стороны.</p>
<p>Учитывая большинство других статей на этом сайте, вы бы
обновляли позиции частиц в JavaScript</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">for (const particle of particles) {
  particle.pos.x = (particle.pos.x + particle.velocity.x) % canvas.width;
  particle.pos.y = (particle.pos.y + particle.velocity.y) % canvas.height;
}
</code></pre>
<p>и затем рисовали бы частицы либо по одной за раз</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">useProgram (particleShader)
setup particle attributes
for each particle
  set uniforms
  draw particle
</code></pre>
<p>Или вы могли бы загрузить все новые позиции частиц</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">bindBuffer(..., particlePositionBuffer)
bufferData(..., latestParticlePositions, ...)
useProgram (particleShader)
setup particle attributes
set uniforms
draw particles
</code></pre>
<p>Используя пример transform feedback выше, мы могли бы создать
буфер со скоростью для каждой частицы. Затем мы могли бы
создать 2 буфера для позиций. Мы использовали бы transform feedback
для добавления скорости к одному буферу позиций и записи в
другой буфер позиций. Затем мы рисовали бы с новыми позициями.
На следующем кадре мы читали бы из буфера с новыми позициями
и записывали обратно в другой буфер для генерации еще более новых позиций.</p>
<p>Вот вершинный шейдер для обновления позиций частиц</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in vec2 oldPosition;
in vec2 velocity;

uniform float deltaTime;
uniform vec2 canvasDimensions;

out vec2 newPosition;

vec2 euclideanModulo(vec2 n, vec2 m) {
	return mod(mod(n, m) + m, m);
}

void main() {
  newPosition = euclideanModulo(
      oldPosition + velocity * deltaTime,
      canvasDimensions);
}
</code></pre>
<p>Чтобы рисовать частицы, мы просто используем простой вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in vec4 position;
uniform mat4 matrix;

void main() {
  // делаем общую матричную математику
  gl_Position = matrix * position;
  gl_PointSize = 10.0;
}
</code></pre>
<p>Давайте превратим код для создания и линковки программы в
функцию, которую мы можем использовать для обоих шейдеров</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function createProgram(gl, shaderSources, transformFeedbackVaryings) {
  const program = gl.createProgram();
  [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) =&gt; {
    const shader = createShader(gl, type, shaderSources[ndx]);
    gl.attachShader(program, shader);
  });
  if (transformFeedbackVaryings) {
    gl.transformFeedbackVaryings(
        program,
        transformFeedbackVaryings,
        gl.SEPARATE_ATTRIBS,
    );
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramParameter(program));
  }
  return program;
}
</code></pre>
<p>и затем использовать его для компиляции шейдеров, один с transform feedback
varying.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const updatePositionProgram = createProgram(
    gl, [updatePositionVS, updatePositionFS], ['newPosition']);
const drawParticlesProgram = createProgram(
    gl, [drawParticlesVS, drawParticlesFS]);
</code></pre>
<p>Как обычно, нам нужно найти местоположения</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const updatePositionPrgLocs = {
  oldPosition: gl.getAttribLocation(updatePositionProgram, 'oldPosition'),
  velocity: gl.getAttribLocation(updatePositionProgram, 'velocity'),
  canvasDimensions: gl.getUniformLocation(updatePositionProgram, 'canvasDimensions'),
  deltaTime: gl.getUniformLocation(updatePositionProgram, 'deltaTime'),
};

const drawParticlesProgLocs = {
  position: gl.getAttribLocation(drawParticlesProgram, 'position'),
  matrix: gl.getUniformLocation(drawParticlesProgram, 'matrix'),
};
</code></pre>
<p>Теперь давайте создадим некоторые случайные позиции и скорости</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// создаем случайные позиции и скорости.
const rand = (min, max) =&gt; {
  if (max === undefined) {
    max = min;
    min = 0;
  }
  return Math.random() * (max - min) + min;
};
const numParticles = 200;
const createPoints = (num, ranges) =&gt;
   new Array(num).fill(0).map(_ =&gt; ranges.map(range =&gt; rand(...range))).flat();
const positions = new Float32Array(createPoints(numParticles, [[canvas.width], [canvas.height]]));
const velocities = new Float32Array(createPoints(numParticles, [[-300, 300], [-300, 300]]));
</code></pre>
<p>Затем мы поместим их в буферы.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeBuffer(gl, sizeOrData, usage) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);
  return buf;
}

const position1Buffer = makeBuffer(gl, positions, gl.DYNAMIC_DRAW);
const position2Buffer = makeBuffer(gl, positions, gl.DYNAMIC_DRAW);
const velocityBuffer = makeBuffer(gl, velocities, gl.STATIC_DRAW);
</code></pre>
<p>Обратите внимание, что мы передали <code class="notranslate" translate="no">gl.DYNAMIC_DRAW</code> в <code class="notranslate" translate="no">gl.bufferData</code> для 2 буферов позиций,
поскольку мы будем обновлять их часто. Это просто подсказка для WebGL для оптимизации.
Имеет ли это какой-либо эффект на производительность, зависит от WebGL.</p>
<p>Нам нужно 4 вершинных массива.</p>
<ul>
<li>1 для использования <code class="notranslate" translate="no">position1Buffer</code> и <code class="notranslate" translate="no">velocity</code> при обновлении позиций</li>
<li>1 для использования <code class="notranslate" translate="no">position2Buffer</code> и <code class="notranslate" translate="no">velocity</code> при обновлении позиций</li>
<li>1 для использования <code class="notranslate" translate="no">position1Buffer</code> при рисовании</li>
<li>1 для использования <code class="notranslate" translate="no">position2Buffer</code> при рисовании</li>
</ul>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeVertexArray(gl, bufLocPairs) {
  const va = gl.createVertexArray();
  gl.bindVertexArray(va);
  for (const [buffer, loc] of bufLocPairs) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(
        loc,      // местоположение атрибута
        2,        // количество элементов
        gl.FLOAT, // тип данных
        false,    // нормализовать
        0,        // шаг (0 = авто)
        0,        // смещение
    );
  }
  return va;
}

const updatePositionVA1 = makeVertexArray(gl, [
  [position1Buffer, updatePositionPrgLocs.oldPosition],
  [velocityBuffer, updatePositionPrgLocs.velocity],
]);
const updatePositionVA2 = makeVertexArray(gl, [
  [position2Buffer, updatePositionPrgLocs.oldPosition],
  [velocityBuffer, updatePositionPrgLocs.velocity],
]);

const drawVA1 = makeVertexArray(
    gl, [[position1Buffer, drawParticlesProgLocs.position]]);
const drawVA2 = makeVertexArray(
    gl, [[position2Buffer, drawParticlesProgLocs.position]]);
</code></pre>
<p>Затем мы создаем 2 объекта transform feedback.</p>
<ul>
<li>1 для записи в <code class="notranslate" translate="no">position1Buffer</code></li>
<li>1 для записи в <code class="notranslate" translate="no">position2Buffer</code></li>
</ul>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeTransformFeedback(gl, buffer) {
  const tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buffer);
  return tf;
}

const tf1 = makeTransformFeedback(gl, position1Buffer);
const tf2 = makeTransformFeedback(gl, position2Buffer);
</code></pre>
<p>При использовании transform feedback важно отвязать буферы
от других точек привязки. <code class="notranslate" translate="no">ARRAY_BUFFER</code> все еще имеет последний буфер
привязанным, в который мы поместили данные. <code class="notranslate" translate="no">TRANSFORM_FEEDBACK_BUFFER</code> устанавливается при
вызове <code class="notranslate" translate="no">gl.bindBufferBase</code>. Это немного запутанно. Вызов
<code class="notranslate" translate="no">gl.bindBufferBase</code> с <code class="notranslate" translate="no">TRANSFORM_FEEDBACK_BUFFER</code> фактически
привязывает буфер к 2 местам. Одно - к индексированной точке привязки внутри
объекта transform feedback. Другое - к своего рода глобальной
точке привязки, называемой <code class="notranslate" translate="no">TRANSFORM_FEEDBACK_BUFFER</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// отвязываем оставшиеся вещи
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);
</code></pre>
<p>Чтобы мы могли легко менять местами буферы обновления и рисования,
мы настроим эти 2 объекта</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let current = {
  updateVA: updatePositionVA1,  // читаем из position1
  tf: tf2,                      // записываем в position2
  drawVA: drawVA2,              // рисуем с position2
};
let next = {
  updateVA: updatePositionVA2,  // читаем из position2
  tf: tf1,                      // записываем в position1
  drawVA: drawVA1,              // рисуем с position1
};
</code></pre>
<p>Затем мы сделаем цикл рендеринга, сначала мы обновим позиции
используя transform feedback.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let then = 0;
function render(time) {
  // конвертируем в секунды
  time *= 0.001;
  // Вычитаем предыдущее время из текущего времени
  const deltaTime = time - then;
  // Запоминаем текущее время для следующего кадра.
  then = time;

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  gl.clear(gl.COLOR_BUFFER_BIT);

  // вычисляем новые позиции
  gl.useProgram(updatePositionProgram);
  gl.bindVertexArray(current.updateVA);
  gl.uniform2f(updatePositionPrgLocs.canvasDimensions, gl.canvas.width, gl.canvas.height);
  gl.uniform1f(updatePositionPrgLocs.deltaTime, deltaTime);

  // отключаем использование фрагментного шейдера
  gl.enable(gl.RASTERIZER_DISCARD);

  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, current.tf);
  gl.beginTransformFeedback(gl.POINTS);
  gl.drawArrays(gl.POINTS, 0, numParticles);
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

  // включаем использование фрагментных шейдеров снова
  gl.disable(gl.RASTERIZER_DISCARD);
</code></pre>
<p>и затем рисуем частицы</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // теперь рисуем частицы.
  gl.useProgram(drawParticlesProgram);
  gl.bindVertexArray(current.drawVA);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.uniformMatrix4fv(
      drawParticlesProgLocs.matrix,
      false,
      m4.orthographic(0, gl.canvas.width, 0, gl.canvas.height, -1, 1));
  gl.drawArrays(gl.POINTS, 0, numParticles);
</code></pre>
<p>и наконец меняем местами <code class="notranslate" translate="no">current</code> и <code class="notranslate" translate="no">next</code>, чтобы на следующем кадре мы
использовали последние позиции для генерации новых</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // меняем местами, из какого буфера мы будем читать
  // и в какой мы будем записывать
  {
    const temp = current;
    current = next;
    next = temp;
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>И с этим у нас есть простые частицы на основе GPU.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-particles-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-particles-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<h2 id="следующий-пример-поиск-ближайшего-отрезка-линии-к-точке">Следующий пример: Поиск ближайшего отрезка линии к точке</h2>
<p>Я не уверен, что это хороший пример, но это тот, который я написал. Я говорю, что он может
быть нехорошим, потому что я подозреваю, что есть лучшие алгоритмы для поиска
ближайшей линии к точке, чем перебор проверки каждой линии с точкой. Например, различные алгоритмы пространственного разделения могут позволить вам легко отбросить 95%
точек и поэтому быть быстрее. Тем не менее, этот пример, вероятно, показывает
некоторые техники GPGPU по крайней мере.</p>
<p>Проблема: У нас есть 500 точек и 1000 отрезков линий. Для каждой точки
найти, какой отрезок линии к ней ближе всего. Метод перебора</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">for each point
  minDistanceSoFar = MAX_VALUE
  for each line segment
    compute distance from point to line segment
</code></pre>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-gpgpu.html" >English</a>
    <option value="/webgl/lessons/de/webgl-gpgpu.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-gpgpu.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-gpgpu.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-gpgpu.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-gpgpu.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-gpgpu.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Пикинг (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">WebGL2 как фон HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Вопросы и ответы</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 GPGPU';
            var disqus_title = 'WebGL2 GPGPU';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-3d-textures.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как работают текстуры в WebGL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ru.jpg">

<meta property="og:title" content="WebGL2 Текстуры">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ru.jpg">
<meta property="og:description" content="Как работают текстуры в WebGL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-3d-textures.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Текстуры">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-3d-textures.html">
<meta name="twitter:description" content="Как работают текстуры в WebGL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-3d-textures.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-3d-textures.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-3d-textures.html",
      "inLanguage":"ru",
      "name":"WebGL2 Текстуры",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-3d-textures.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Текстуры</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-textures.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-textures.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-textures.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/de/webgl-3d-textures.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Текстуры</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья является продолжением серии статей о WebGL.
Первая <a href="webgl-fundamentals.html">началась с основ</a>,
а предыдущая была об <a href="webgl-animation.html">анимации</a>.</p>
<p>Как мы применяем текстуры в WebGL? Вы, вероятно, могли бы вывести, как это сделать, читая
<a href="webgl-image-processing.html">статьи об обработке изображений</a>,
но, вероятно, будет легче понять, если мы рассмотрим это более подробно.</p>
<p>Первое, что нам нужно сделать, это настроить наши шейдеры для использования текстур. Вот
изменения в вершинном шейдере. Нам нужно передать координаты текстуры. В этом
случае мы просто передаем их прямо в фрагментный шейдер.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
in vec4 a_position;
*in vec2 a_texcoord;

uniform mat4 u_matrix;

+// varying для передачи координат текстуры в фрагментный шейдер
+out vec2 v_texcoord;

void main() {
  // Умножаем позицию на матрицу.
  gl_Position = u_matrix * a_position;

+  // Передаем texcoord в фрагментный шейдер.
+  v_texcoord = a_texcoord;
}
</code></pre>
<p>В фрагментном шейдере мы объявляем uniform sampler2D, который позволяет нам ссылаться
на текстуру. Мы используем координаты текстуры, переданные из вершинного шейдера,
и мы вызываем <code class="notranslate" translate="no">texture</code>, чтобы найти цвет из этой текстуры.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
precision highp float;

// Передается из вершинного шейдера.
*in vec2 v_texcoord;

*// Текстура.
*uniform sampler2D u_texture;

out vec4 outColor;

void main() {
*   outColor = texture(u_texture, v_texcoord);
}
</code></pre>
<p>Нам нужно настроить координаты текстуры</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// ищем, куда должны идти данные вершин.
var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
*var texcoordAttributeLocation = gl.getAttribLocation(program, &quot;a_texcoord&quot;);

...

*// создаем буфер texcoord, делаем его текущим ARRAY_BUFFER
*// и копируем значения texcoord
*var texcoordBuffer = gl.createBuffer();
*gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
*setTexcoords(gl);
*
*// Включаем атрибут
*gl.enableVertexAttribArray(texcoordAttributeLocation);
*
*// Говорим атрибуту, как получать данные из texcoordBuffer (ARRAY_BUFFER)
*var size = 2;          // 2 компонента на итерацию
*var type = gl.FLOAT;   // данные - 32-битные значения с плавающей точкой
*var normalize = true;  // конвертируем из 0-255 в 0.0-1.0
*var stride = 0;        // 0 = двигаемся вперед на size * sizeof(type) каждую итерацию, чтобы получить следующий texcoord
*var offset = 0;        // начинаем с начала буфера
*gl.vertexAttribPointer(
*    texcoordAttributeLocation, size, type, normalize, stride, offset);
</code></pre>
<p>И вы можете видеть координаты, которые мы используем, которые отображают всю
текстуру на каждый квадрат нашей ‘F’.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*// Заполняем буфер координатами текстуры для F.
*function setTexcoords(gl) {
*  gl.bufferData(
*      gl.ARRAY_BUFFER,
*      new Float32Array([
*        // левая колонка спереди
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
*
*        // верхняя перекладина спереди
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
* ...
*       ]),
*       gl.STATIC_DRAW);
</code></pre>
<p>Нам также нужна текстура. Мы могли бы создать одну с нуля, но в этом случае давайте
загрузим изображение, поскольку это, вероятно, самый распространенный способ.</p>
<p>Вот изображение, которое мы собираемся использовать</p>
<img class="webgl_center" src="../../resources/f-texture.png" />
<p>Какое захватывающее изображение! На самом деле изображение с ‘F’ на нем имеет четкое направление,
поэтому легко сказать, повернуто оно или перевернуто и т.д., когда мы используем его как текстуру.</p>
<p>Дело в загрузке изображения в том, что это происходит асинхронно. Мы запрашиваем изображение
для загрузки, но браузеру требуется время, чтобы скачать его. Есть обычно
2 решения для этого. Мы могли бы заставить код ждать, пока текстура не скачается,
и только тогда начать рисовать. Другое решение - создать какую-то текстуру для использования,
пока изображение скачивается. Таким образом, мы можем начать рендеринг немедленно. Затем, как только
изображение было скачано, мы копируем изображение в текстуру. Мы будем использовать этот метод ниже.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*// Создаем текстуру.
*var texture = gl.createTexture();
*gl.bindTexture(gl.TEXTURE_2D, texture);
*
*// Заполняем текстуру 1x1 синим пикселем.
*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
*              new Uint8Array([0, 0, 255, 255]));
*
*// Асинхронно загружаем изображение
*var image = new Image();
*image.src = &quot;resources/f-texture.png&quot;;
*image.addEventListener('load', function() {
*  // Теперь, когда изображение загружено, копируем его в текстуру.
*  gl.bindTexture(gl.TEXTURE_2D, texture);
*  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
*  gl.generateMipmap(gl.TEXTURE_2D);
*});
</code></pre>
<p>И вот это</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Что, если бы мы хотели использовать только часть текстуры на передней части ‘F’? Текстуры ссылаются
с “координатами текстуры”, и координаты текстуры идут от 0.0 до 1.0 слева
направо по текстуре и от 0.0 до 1.0 от первого пикселя на первой строке до последнего пикселя на последней строке.
Обратите внимание, я не сказал верх или низ. Верх и низ не имеют смысла в пространстве текстуры,
потому что пока вы не нарисуете что-то и не сориентируете это, нет верха и низа. Важно то, что вы
предоставляете данные текстуры в WebGL. Начало этих данных начинается с координаты текстуры 0,0,
и конец этих данных находится в 1,1</p>
<img class="webgl_center noinvertdark" width="405" src="../resources/texture-coordinates-diagram.svg" />
<p>Я загрузил текстуру в photoshop и посмотрел различные координаты в пикселях.</p>
<img class="webgl_center" width="256" height="256" src="../../resources/f-texture-pixel-coords.png" />
<p>Чтобы конвертировать из координат пикселей в координаты текстуры, мы можем просто использовать</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">texcoordX = pixelCoordX / (width  - 1)
texcoordY = pixelCoordY / (height - 1)
</code></pre>
<p>Вот координаты текстуры для передней части.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// левая колонка спереди
 38 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255, 223 / 255,
113 / 255,  44 / 255,

// верхняя перекладина спереди
113 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 85 / 255,
218 / 255, 44 / 255,

// средняя перекладина спереди
113 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 151 / 255,
203 / 255, 112 / 255,
</code></pre>
<p>Я также использовал похожие координаты текстуры для задней части. И вот это.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-coords-mapped.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-coords-mapped.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Не очень захватывающий дисплей, но, надеюсь, он демонстрирует, как использовать координаты текстуры. Если вы создаете
геометрию в коде (кубы, сферы и т.д.), обычно довольно легко вычислить любые координаты текстуры, которые вы
хотите. С другой стороны, если вы получаете 3D модели из программ 3D моделирования, таких как Blender, Maya, 3D Studio Max, то
ваши художники (или вы) будут <a href="https://docs.blender.org/manual/en/3.4/modeling/meshes/uv/index.html">настраивать координаты текстуры в этих пакетах, используя UV редактор</a>.</p>
<p>Так что происходит, если мы используем координаты текстуры вне диапазона 0.0 до 1.0. По умолчанию WebGL повторяет
текстуру. 0.0 до 1.0 - это одна ‘копия’ текстуры. 1.0 до 2.0 - это другая копия. Даже -4.0 до -3.0 - это еще
одна копия. Давайте отобразим плоскость, используя эти координаты текстуры.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> -3, -1,
  2, -1,
 -3,  4,
 -3,  4,
  2, -1,
  2,  4,
</code></pre>
<p>и вот это</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-repeat-clamp.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-repeat-clamp.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Вы можете сказать WebGL не повторять текстуру в определенном направлении, используя <code class="notranslate" translate="no">CLAMP_TO_EDGE</code>. Например</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre>
<p>вы также можете сказать WebGL отражать текстуру, когда она повторяется, используя <code class="notranslate" translate="no">gl.MIRRORED_REPEAT</code>.
Нажмите кнопки в примере выше, чтобы увидеть разницу.</p>
<p>Вы, возможно, заметили вызов <code class="notranslate" translate="no">gl.generateMipmap</code> еще когда мы загружали текстуру. Для чего это?</p>
<p>Представьте, у нас была эта текстура 16x16 пикселей.</p>
<img class="webgl_center" src="../resources/mip-low-res-enlarged.png" style="border: 2px solid black;" />
<p>Теперь представьте, мы попытались нарисовать эту текстуру на полигоне размером 2x2 пикселя на экране. Какие цвета мы должны
сделать для этих 4 пикселей? Есть 256 пикселей на выбор. В Photoshop, если бы вы масштабировали изображение 16x16 пикселей
до 2x2, он бы усреднил 8x8 пикселей в каждом углу, чтобы сделать 4 пикселя в изображении 2x2. К сожалению,
чтение 64 пикселей и усреднение их всех вместе было бы слишком медленно для GPU. На самом деле представьте, если бы у вас
была текстура 2048x2084 пикселей, и вы попытались нарисовать ее 2x2 пикселя. Чтобы сделать то, что делает Photoshop для каждого из
4 пикселей в результате 2x2, ему пришлось бы усреднить 1024x1024 пикселя или 1 миллион пикселей, умноженный на 4. Это слишком
много, чтобы делать и все еще быть быстрым.</p>
<p>Так что GPU использует мипмап. Мипмап - это коллекция прогрессивно меньших изображений,
каждое из которых в 1/4 размера предыдущего. Мипмап для текстуры 16x16 выше выглядел бы примерно
так.</p>
<img class="webgl_center noinvertdark nobg" src="../resources/mipmap-low-res-enlarged.png" />
<p>Обычно каждый меньший уровень - это просто билинейная интерполяция предыдущего уровня, и это
то, что делает <code class="notranslate" translate="no">gl.generateMipmap</code>. Он смотрит на самый большой уровень и генерирует все меньшие уровни для вас.
Конечно, вы можете предоставить меньшие уровни сами, если хотите.</p>
<p>Теперь, если вы попытаетесь нарисовать эту текстуру 16x16 пикселей только 2x2 пикселя на экране, WebGL может выбрать
мип, который 2x2, который уже был усреднен из предыдущих мипов.</p>
<p>Вы можете выбрать, что делает WebGL, установив фильтрацию текстуры для каждой текстуры. Есть 6 режимов</p>
<ul>
<li><code class="notranslate" translate="no">NEAREST</code> = выбрать 1 пиксель из самого большого мипа</li>
<li><code class="notranslate" translate="no">LINEAR</code> = выбрать 4 пикселя из самого большого мипа и смешать их</li>
<li><code class="notranslate" translate="no">NEAREST_MIPMAP_NEAREST</code> = выбрать лучший мип, затем выбрать один пиксель из этого мипа</li>
<li><code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code> = выбрать лучший мип, затем смешать 4 пикселя из этого мипа</li>
<li><code class="notranslate" translate="no">NEAREST_MIPMAP_LINEAR</code> = выбрать лучшие 2 мипа, выбрать 1 пиксель из каждого, смешать их</li>
<li><code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> = выбрать лучшие 2 мипа, выбрать 4 пикселя из каждого, смешать их</li>
</ul>
<p>Вы можете увидеть важность мипов в этих 2 примерах. Первый показывает, что если вы используете <code class="notranslate" translate="no">NEAREST</code>
или <code class="notranslate" translate="no">LINEAR</code> и выбираете только из самого большого изображения, то вы получите много мерцания, потому что когда вещи
двигаются, для каждого пикселя, который он рисует, ему приходится выбирать один пиксель из самого большого изображения. Это меняется в зависимости
от размера и позиции, и поэтому иногда он выберет один пиксель, в другое время другой, и поэтому он
мерцает.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Пример выше преувеличен, чтобы показать проблему.
Обратите внимание, как сильно мерцают те, что слева и в середине, тогда как те, что справа, мерцают меньше.
Те, что справа, также имеют смешанные цвета, поскольку они используют мипы. Чем меньше вы рисуете текстуру, тем дальше друг от друга WebGL будет
выбирать пиксели. Вот почему, например, тот, что внизу посередине, даже несмотря на то, что он использует <code class="notranslate" translate="no">LINEAR</code> и смешивает
4 пикселя, мерцает разными цветами, потому что эти 4 пикселя из разных углов изображения 16x16 в зависимости от того, какие
4 выбраны, вы получите другой цвет. Тот, что внизу справа, хотя остается постоянного цвета,
потому что он использует второй по величине мип.</p>
<p>Этот второй пример показывает полигоны, которые уходят глубоко вдаль.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips-tri-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips-tri-linear.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>6 лучей, идущих в экран, используют 6 режимов фильтрации, перечисленных выше. Луч вверху слева использует <code class="notranslate" translate="no">NEAREST</code>,
и вы можете видеть, что он явно очень блочный. Тот, что вверху посередине, использует <code class="notranslate" translate="no">LINEAR</code>, и он не намного лучше.
Тот, что вверху справа, использует <code class="notranslate" translate="no">NEAREST_MIPMAP_NEAREST</code>. Нажмите на изображение, чтобы переключиться на текстуру, где каждый мип
разного цвета, и вы легко увидите, где он выбирает использовать конкретный мип. Тот, что внизу слева, использует
<code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code>, что означает, что он выбирает лучший мип, а затем смешивает 4 пикселя в этом мипе. Вы все еще можете видеть
четкую область, где он переключается с одного мипа на следующий мип. Тот, что внизу посередине, использует <code class="notranslate" translate="no">NEAREST_MIPMAP_LINEAR</code>,
что означает выбор лучших 2 мипов, выбор одного пикселя из каждого и смешивание
их. Если вы посмотрите внимательно, вы можете увидеть, как он все еще блочный, особенно в горизонтальном направлении.
Тот, что внизу справа, использует <code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code>, который выбирает лучшие 2 мипа, выбирает 4 пикселя из каждого,
и смешивает все 8 пикселей.</p>
<img class="webgl_center noinvertdark nobg" src="../resources/different-colored-mips.png" />
<div class="webgl_center">мипы разного цвета</div>
<p>Вы можете думать, зачем вам когда-либо выбирать что-то другое, кроме <code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code>, который, возможно,
лучший. Есть много причин. Одна в том, что <code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> самый медленный. Чтение 8 пикселей
медленнее, чем чтение 1 пикселя. На современном GPU оборудовании это, вероятно, не проблема, если вы используете только 1
текстуру за раз, но современные игры могут использовать 2-4 текстуры одновременно. 4 текстуры * 8 пикселей на текстуру =
необходимость читать 32 пикселя для каждого нарисованного пикселя. Это будет медленно. Другая причина в том, что если вы пытаетесь
достичь определенного эффекта. Например, если вы хотите, чтобы что-то имело этот пикселизированный <em>ретро</em> вид, возможно, вы
хотите использовать <code class="notranslate" translate="no">NEAREST</code>. Мипы также занимают память. На самом деле они занимают на 33% больше памяти. Это может быть много памяти,
особенно для очень большой текстуры, как вы могли бы использовать на титульном экране игры. Если вы никогда не собираетесь
рисовать что-то меньше, чем самый большой мип, зачем тратить память на меньшие мипы. Вместо этого просто используйте <code class="notranslate" translate="no">NEAREST</code>
или <code class="notranslate" translate="no">LINEAR</code>, поскольку они используют только первый мип.</p>
<p>Чтобы установить фильтрацию, вы вызываете <code class="notranslate" translate="no">gl.texParameter</code> так</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
</code></pre>
<p><code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code> - это настройка, используемая, когда размер, который вы рисуете, меньше, чем самый большой мип.
<code class="notranslate" translate="no">TEXTURE_MAG_FILTER</code> - это настройка, используемая, когда размер, который вы рисуете, больше, чем самый большой мип. Для
<code class="notranslate" translate="no">TEXTURE_MAG_FILTER</code> только <code class="notranslate" translate="no">NEAREST</code> и <code class="notranslate" translate="no">LINEAR</code> являются валидными настройками.</p>
<p>Что нужно знать, WebGL2 требует, чтобы текстуры были “texture complete”, иначе они не будут рендериться.
“texture complete” означает, что либо</p>
<ol>
<li>
<p>Вы установили фильтрацию так, чтобы она использовала только первый уровень мипа, что означает
установку <code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code> либо в <code class="notranslate" translate="no">LINEAR</code>, либо в <code class="notranslate" translate="no">NEAREST</code>.</p>
</li>
<li>
<p>Если вы используете мипы, то они должны быть правильных размеров, и вы должны предоставить ВСЕ ИЗ НИХ
вплоть до размера 1x1.</p>
</li>
</ol>
<p>Самый простой способ сделать это - вызвать <code class="notranslate" translate="no">gl.generateMipmap</code>. В противном случае, если вы предоставляете свои собственные мипы, вам нужно предоставить
все из них, или вы получите ошибку.</p>
<p><a name="texture-atlas"></a>Общий вопрос: “Как я могу применить другое изображение к каждой грани куба?”. Например, скажем, у нас
были эти 6 изображений.</p>
<div class="webgl_table_div_center">
  <style>
    table.webgl_table_center {
      border-spacing: 0.5em;
      border-collapse: separate;
    }
    table.webgl_table_center img {
      display:block;
    }
  </style>
  <table class="webgl_table_center">
    <tr><td><img src="../resources/noodles-01.jpg" /></td><td><img src="../resources/noodles-02.jpg" /></td></tr>
    <tr><td><img src="../resources/noodles-03.jpg" /></td><td><img src="../resources/noodles-04.jpg" /></td></tr>
    <tr><td><img src="../resources/noodles-05.jpg" /></td><td><img src="../resources/noodles-06.jpg" /></td></tr>
  </table>
</div>
<p>3 ответа приходят на ум</p>
<ol>
<li>
<p>сделать сложный шейдер, который ссылается на 6 текстур, и передать какую-то дополнительную информацию на вершину в
вершинный шейдер, которая передается в фрагментный шейдер, чтобы решить, какую текстуру использовать. НЕ ДЕЛАЙТЕ ЭТОГО!
Немного размышлений сделало бы ясным, что вам пришлось бы написать тонны разных шейдеров, если бы вы
хотели сделать то же самое для разных форм с большим количеством сторон и т.д.</p>
</li>
<li>
<p>нарисовать 6 плоскостей вместо куба. Это общее решение. Это не плохо, но это также работает только
для маленьких форм, как куб. Если бы у вас была сфера с 1000 квадратов, и вы хотели положить другую текстуру
на каждый квадрат, вам пришлось бы нарисовать 1000 плоскостей, и это было бы медленно.</p>
</li>
<li>
<p>Решение, осмелюсь сказать, <em>лучшее</em> - это положить все изображения в 1 текстуру и использовать координаты текстуры,
чтобы отобразить другую часть текстуры на каждую грань куба. Это техника, которую используют практически
все высокопроизводительные приложения (читай <em>игры</em>). Так, например, мы бы положили все изображения в одну текстуру, возможно,
так</p>
</li>
</ol>
<img class="webgl_center" src="../../resources/noodles.jpg" />
<p>и затем использовать другой набор координат текстуры для каждой грани куба.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">    // выбираем изображение вверху слева
    0   , 0  ,
    0   , 0.5,
    0.25, 0  ,
    0   , 0.5,
    0.25, 0.5,
    0.25, 0  ,
    // выбираем изображение вверху посередине
    0.25, 0  ,
    0.5 , 0  ,
    0.25, 0.5,
    0.25, 0.5,
    0.5 , 0  ,
    0.5 , 0.5,
    // выбираем изображение вверху справа
    0.5 , 0  ,
    0.5 , 0.5,
    0.75, 0  ,
    0.5 , 0.5,
    0.75, 0.5,
    0.75, 0  ,
    // выбираем изображение внизу слева
    0   , 0.5,
    0.25, 0.5,
    0   , 1  ,
    0   , 1  ,
    0.25, 0.5,
    0.25, 1  ,
    // выбираем изображение внизу посередине
    0.25, 0.5,
    0.25, 1  ,
    0.5 , 0.5,
    0.25, 1  ,
    0.5 , 1  ,
    0.5 , 0.5,
    // выбираем изображение внизу справа
    0.5 , 0.5,
    0.75, 0.5,
    0.5 , 1  ,
    0.5 , 1  ,
    0.75, 0.5,
    0.75, 1  ,
</code></pre>
<p>И мы получаем</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-atlas.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-atlas.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Этот стиль применения нескольких изображений, используя 1 текстуру, часто называется <a href="https://www.google.com/?ion=1&amp;espv=2#q=texture%20atlas"><em>texture atlas</em></a>.
Это лучше всего, потому что есть только 1 текстура для загрузки, шейдер остается простым, поскольку ему нужно ссылаться только на 1 текстуру, и это требует
только 1 вызов отрисовки для рисования формы вместо 1 вызова отрисовки на текстуру, как это могло бы быть, если бы мы разделили это на
плоскости.</p>
<p>Несколько других очень важных вещей, которые вы, возможно, захотите знать о текстурах.
Одна - <a href="webgl-texture-units.html">как работает состояние текстурного блока</a>.
Одна - <a href="webgl-2-textures.html">как использовать 2 или более текстур одновременно</a>. Другая</p>
<ul>
<li><a href="webgl-cors-permission.html">как использовать изображения с других доменов</a>.</li>
</ul>
<p>Далее <a href="webgl-less-code-more-fun.html">давайте начнем упрощать с меньшим количеством кода, больше веселья</a>.</p>
<div class="webgl_bottombar">
<h3>UVs vs. Координаты текстуры</h3>
<p>Координаты текстуры часто сокращаются до texture coords, texcoords или UVs
(произносится Ew-Vees). Я не имею представления, откуда пришел термин UVs, кроме того, что
позиции вершин часто используют <code class="notranslate" translate="no">x, y, z, w</code>, поэтому для координат текстуры они решили использовать
<code class="notranslate" translate="no">s, t, u, v</code>, чтобы попытаться сделать ясным, к какому из 2 типов вы обращаетесь.
Учитывая это, вы бы подумали, что они назывались бы Es-Tees, и на самом деле, если вы посмотрите
на настройки обертывания текстуры, они называются <code class="notranslate" translate="no">TEXTURE_WRAP_S</code> и
<code class="notranslate" translate="no">TEXTURE_WRAP_T</code>, но по какой-то причине, пока я работаю
в графике, люди называли их Ew-Vees.
</p>
<p>Так что теперь вы знаете, если кто-то говорит UVs, они говорят о координатах текстуры.</p>
</div>
<div class="webgl_bottombar">
<h3>Изображения не степени 2</h3>
<p>Если вы привыкли к WebGL1, WebGL1 имел ограничение, что текстуры с размерами,
которые не были степенью 2, другими словами **не** 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 и т.д.,
не могли использовать мипы и не могли повторяться. В WebGL2 эти ограничения исчезли.
УРА!
</p>
</div> 
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/de/webgl-3d-textures.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Текстуры';
            var disqus_title = 'WebGL2 Текстуры';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




Title: Может ли кто-нибудь объяснить, что делает этот GLSL фрагментный шейдер?
Description: Может ли кто-нибудь объяснить, что делает этот GLSL фрагментный шейдер?
TOC: Can anyone explain what this GLSL fragment shader is doing?

## Вопрос:

Я понимаю, что это вопрос, ориентированный на математику, но... если вы посмотрите на [эту веб-страницу](https://threejs.org/examples/?q=shader#webgl_shader). (и у вас есть хорошая видеокарта)

Если вы посмотрите на исходный код, вы заметите страшно выглядящий фрагментный шейдер.

Я не ищу подробного объяснения, но идею о том, что происходит, или источник информации о том, что именно происходит здесь.. Я не ищу руководство по GLSL, но информацию о математике. Я понимаю, что это может быть лучше подходит для сайта Math StackExchange, но подумал, что попробую здесь сначала...

    <script id="fragmentShader" type="x-shader/x-fragment">
    
       uniform vec2 resolution;
       uniform float time;
    
       void main() {
    
        vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
        float a = time*40.0;
        float d,e,f,g=1.0/40.0,h,i,r,q;
        e=400.0*(p.x*0.5+0.5);
        f=400.0*(p.y*0.5+0.5);
        i=200.0+sin(e*g+a/150.0)*20.0;
        d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
        r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));
        q=f/r;
        e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
        d=sin(e*g)*176.0+sin(e*g)*164.0+r;
        h=((f+d)+a/2.0)*g;
        i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
        h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
        h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
        i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
        i=mod(i/5.6,256.0)/64.0;
        if(i<0.0) i+=4.0;
        if(i>=2.0) i=4.0-i;
        d=r/350.0;
        d+=sin(d*d*8.0)*0.52;
        f=(sin(a*g)+1.0)/2.0;
        gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);
    
       }
    
      </script>

## Ответ:

[Monjori](http://www.pouet.net/prod.php?which=52761) из демо-сцены.

Простой ответ - он использует формулу для генерации паттерна. WebGL будет вызывать эту функцию один раз для каждого пикселя на экране. Единственные вещи, которые будут меняться, это time и gl_FragCoord, который является местоположением пикселя, который рисуется.

Давайте разберем это немного


      // это разрешение окна
      uniform vec2 resolution;

      // это счетчик в секундах.
      uniform float time;

      void main() {
          // gl_FragCoord - это позиция пикселя, который рисуется
          // поэтому этот код делает p значением, которое идет от -1 до +1 
          // x и y
          vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;

          // a = время ускоренное в 40 раз
          float a = time*40.0;

          // объявляем кучу переменных.
          float d,e,f,g=1.0/40.0,h,i,r,q;

          // e идет от 0 до 400 по экрану
          e=400.0*(p.x*0.5+0.5);

          // f идет от 0 до 400 вниз по экрану
          f=400.0*(p.y*0.5+0.5);

          // i идет от 200 + или - 20 на основе
          // sin от e * 1/40 + замедленное время / 150
          // или другими словами замедлить еще больше.
          // e * 1/40 означает e идет от 0 до 1
          i=200.0+sin(e*g+a/150.0)*20.0;

          // d это 200 + или - 18.0 + или - 7
          // первый +/- это cos от 0.0 до 0.5 вниз по экрану
          // второй +/- это cos от 0.0 до 1.0 по экрану
          d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;

          // Я останавливаюсь здесь. Вы, вероятно, можете разобрать остальное
          // смотрите ответ
          r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));
          q=f/r;
          e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
          d=sin(e*g)*176.0+sin(e*g)*164.0+r;
          h=((f+d)+a/2.0)*g;
          i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
          h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
          h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
          i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
          i=mod(i/5.6,256.0)/64.0;
          if(i<0.0) i+=4.0;
          if(i>=2.0) i=4.0-i;
          d=r/350.0;
          d+=sin(d*d*8.0)*0.52;
          f=(sin(a*g)+1.0)/2.0;
          gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);
    }

Одна из вещей, которую хорошо попробовать, чтобы увидеть, что происходит, это вставить ранние выходы в шейдер. Сначала вы можете увидеть шейдер здесь

http://glsl.heroku.com/e#1579.0

или

https://www.shadertoy.com/view/lsfyRS

Если мы перейдем к строке 11

          e=400.0*(p.x*0.5+0.5);

и вставим сразу после нее что-то вроде этого

          e=400.0*(p.x*0.5+0.5);
          gl_FragColor = vec4(e / 400.0, 0, 0, 1);
          return;

Пока мы конвертируем значение в что-то от 0 до 1, мы можем увидеть результат

например, спускаясь к строке 14

    d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;

Поскольку мы знаем, что это идет от 200 +/- 18 +/- 7, это 175 + 225, поэтому конвертируем это в 0 до 1 с

    d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
    float tmp = (d - 175.0) / 50.0;
    gl_FragColor = vec4(tmp, 0, 0, 1);
    return;

даст вам некоторое представление о том, что он делает.

Я уверен, что вы можете разобрать остальное.

<div class="so">
  <div>Вопрос и процитированные части являются 
    CC BY-SA 3.0 от
    <a data-href="http://colab.codes/">Alex</a>
    из
    <a data-href="https://stackoverflow.com/questions/9151238">здесь</a>
  </div>
</div> 
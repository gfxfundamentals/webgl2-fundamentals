Title: Основы WebGL2
Description: Ваш первый урок WebGL2, начинающийся с основ
TOC: Основы


Прежде всего, эти статьи посвящены WebGL2. Если вас интересует WebGL 1.0,
[пожалуйста, перейдите сюда](https://webglfundamentals.org). Обратите внимание, что WebGL2 [почти на 100% обратно
совместим с WebGL 1](webgl1-to-webgl2.html). Тем не менее, как только вы включите
WebGL2, вам стоит использовать его так, как он был задуман. Эти туториалы следуют
этому пути.

WebGL часто рассматривается как 3D API. Люди думают "Я использую WebGL и *магия* я получу крутую 3D графику".
В реальности WebGL - это просто движок растеризации. Он рисует [точки, линии и треугольники](webgl-points-lines-triangles.html) на основе
кода, который вы предоставляете. Заставить WebGL делать что-то еще - ваша задача предоставить код для использования точек, линий
и треугольников для выполнения вашей задачи.

WebGL работает на GPU вашего компьютера. Как таковой, вам нужно предоставить код, который работает на этом GPU.
Вы предоставляете этот код в виде пар функций. Эти 2 функции называются вершинным шейдером
и фрагментным шейдером, и каждая из них написана на очень строго типизированном языке, похожем на C/C++, называемом
[GLSL](webgl-shaders-and-glsl.html). (GL Shader Language). Вместе они называются *программой*.

Задача вершинного шейдера - вычислять позиции вершин. На основе позиций, которые выводит функция,
WebGL может затем растеризовать различные виды примитивов, включая [точки, линии или треугольники](webgl-points-lines-triangles.html).
При растеризации этих примитивов он вызывает вторую пользовательскую функцию, называемую фрагментным шейдером.
Задача фрагментного шейдера - вычислять цвет для каждого пикселя примитива, который в данный момент рисуется.

Почти весь WebGL API посвящен [настройке состояния](resources/webgl-state-diagram.html) для выполнения этих пар функций.
Для каждой вещи, которую вы хотите нарисовать, вы настраиваете кучу состояния, а затем выполняете пару функций, вызывая
`gl.drawArrays` или `gl.drawElements`, который выполняет ваши шейдеры на GPU.

Любые данные, к которым вы хотите, чтобы эти функции имели доступ, должны быть предоставлены GPU. Есть 4 способа,
как шейдер может получать данные.

1. Атрибуты, буферы и вершинные массивы

   Буферы - это массивы бинарных данных, которые вы загружаете в GPU. Обычно буферы содержат
   такие вещи, как позиции, нормали, координаты текстуры, цвета вершин и т.д., хотя
   вы можете положить в них все, что хотите.

   Атрибуты используются для указания того, как
   извлекать данные из ваших буферов и предоставлять их вашему вершинному шейдеру.
   Например, вы можете положить позиции в буфер как три 32-битных float'а
   на позицию. Вы бы сказали конкретному атрибуту, из какого буфера извлекать позиции, какой тип
   данных он должен извлекать (3 компонента 32-битных чисел с плавающей точкой), какое смещение
   в буфере начинаются позиции, и сколько байт нужно получить от одной позиции до следующей.

   Буферы не являются случайным доступом. Вместо этого вершинный шейдер выполняется указанное количество
   раз. Каждый раз, когда он выполняется, извлекается следующее значение из каждого указанного буфера
   и присваивается атрибуту.

   Состояние атрибутов, какие буферы использовать для каждого из них, и как извлекать данные
   из этих буферов собирается в объект вершинного массива (VAO).

2. Uniforms

   Uniforms - это эффективно глобальные переменные, которые вы устанавливаете перед выполнением вашей шейдерной программы.

3. Текстуры

   Текстуры - это массивы данных, к которым вы можете получить случайный доступ в вашей шейдерной программе. Самая
   распространенная вещь, которую кладут в текстуру - это данные изображения, но текстуры - это просто данные и могут
   так же легко содержать что-то другое, кроме цветов.

4. Varyings

   Varyings - это способ для вершинного шейдера передать данные фрагментному шейдеру. В зависимости
   от того, что рендерится, точки, линии или треугольники, значения, установленные на varying
   вершинным шейдером, будут интерполированы при выполнении фрагментного шейдера.

## WebGL Hello World

WebGL заботится только о 2 вещах. Координаты clip space и цвета.
Ваша задача как программиста, использующего WebGL, - предоставить WebGL эти 2 вещи.
Вы предоставляете ваши 2 "шейдера" для этого. Вершинный шейдер, который предоставляет
координаты clip space, и фрагментный шейдер, который предоставляет цвет.

Координаты clip space всегда идут от -1 до +1 независимо от размера вашего
canvas. Вот простой пример WebGL, который показывает WebGL в его простейшей форме.

Давайте начнем с вершинного шейдера

    #version 300 es

    // атрибут - это вход (in) в вершинный шейдер.
    // Он будет получать данные из буфера
    in vec4 a_position;

    // все шейдеры имеют главную функцию
    void main() {

      // gl_Position - это специальная переменная, за установку которой
      // отвечает вершинный шейдер
      gl_Position = a_position;
    }

При выполнении, если бы вся вещь была написана в JavaScript вместо GLSL,
вы могли бы представить, что она использовалась бы так

    // *** ПСЕВДО КОД!! ***

    var positionBuffer = [
      0, 0, 0, 0,
      0, 0.5, 0, 0,
      0.7, 0, 0, 0,
    ];
    var attributes = {};
    var gl_Position;

    drawArrays(..., offset, count) {
      var stride = 4;
      var size = 4;
      for (var i = 0; i < count; ++i) {
         // копируем следующие 4 значения из positionBuffer в атрибут a_position
         const start = offset + i * stride;
         attributes.a_position = positionBuffer.slice(start, start + size);
         runVertexShader();
         ...
         doSomethingWith_gl_Position();
    }

В реальности это не совсем так просто, потому что `positionBuffer` нужно было бы преобразовать в бинарные
данные (см. ниже), и поэтому фактическое вычисление для получения данных из буфера
было бы немного другим, но надеюсь, это дает вам представление о том, как вершинный
шейдер будет выполняться.

Далее нам нужен фрагментный шейдер

    #version 300 es

    // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам нужно
    // выбрать одну. highp - хороший выбор по умолчанию. Это означает "высокая точность"
    precision highp float;

    // нам нужно объявить выход для фрагментного шейдера
    out vec4 outColor;

    void main() {
      // Просто устанавливаем выход на константный красно-фиолетовый
      outColor = vec4(1, 0, 0.5, 1);
    }

Выше мы объявили `outColor` как выход нашего фрагментного шейдера. Мы устанавливаем `outColor` в `1, 0, 0.5, 1`,
что означает 1 для красного, 0 для зеленого, 0.5 для синего, 1 для альфа. Цвета в WebGL идут от 0 до 1.

Теперь, когда мы написали 2 шейдерные функции, давайте начнем с WebGL

Сначала нам нужен HTML canvas элемент

     <canvas id="c"></canvas>

Затем в JavaScript мы можем найти его

     var canvas = document.querySelector("#c");

Теперь мы можем создать WebGL2RenderingContext

     var gl = canvas.getContext("webgl2");
     if (!gl) {
        // нет webgl2 для вас!
        ...

Теперь нам нужно скомпилировать эти шейдеры, чтобы поместить их на GPU, поэтому сначала нам нужно получить их в строки.
Вы можете создавать ваши GLSL строки любым способом, которым вы обычно создаете строки в JavaScript. Например, конкатенацией,
используя AJAX для их загрузки, помещая их в не-javascript script теги, или в данном случае в
многострочные шаблонные строки.

    var vertexShaderSource = `#version 300 es

    // атрибут - это вход (in) в вершинный шейдер.
    // Он будет получать данные из буфера
    in vec4 a_position;

    // все шейдеры имеют главную функцию
    void main() {

      // gl_Position - это специальная переменная, за установку которой
      // отвечает вершинный шейдер
      gl_Position = a_position;
    }
    `;

    var fragmentShaderSource = `#version 300 es

    // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам нужно
    // выбрать одну. highp - хороший выбор по умолчанию. Это означает "высокая точность"
    precision highp float;

    // нам нужно объявить выход для фрагментного шейдера
    out vec4 outColor;

    void main() {
      // Просто устанавливаем выход на константный красно-фиолетовый
      outColor = vec4(1, 0, 0.5, 1);
    }
    `;

Фактически, большинство 3D движков генерируют GLSL шейдеры на лету, используя различные типы шаблонов, конкатенацию и т.д.
Для примеров на этом сайте, однако, ни один из них не достаточно сложен, чтобы нуждаться в генерации GLSL во время выполнения.

> ПРИМЕЧАНИЕ: `#version 300 es` **ДОЛЖНА БЫТЬ САМОЙ ПЕРВОЙ СТРОКОЙ ВАШЕГО ШЕЙДЕРА**. Никаких комментариев или 
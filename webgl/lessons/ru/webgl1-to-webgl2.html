<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl1-to-webgl2.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как перейти с WebGL1 на WebGL2">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_ru.jpg">

<meta property="og:title" content="WebGL2 из WebGL1">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_ru.jpg">
<meta property="og:description" content="Как перейти с WebGL1 на WebGL2">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 из WebGL1">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html">
<meta name="twitter:description" content="Как перейти с WebGL1 на WebGL2">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl1-to-webgl2_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html",
      "inLanguage":"ru",
      "name":"WebGL2 из WebGL1",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 из WebGL1</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl1-to-webgl2.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl1-to-webgl2.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl1-to-webgl2.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl1-to-webgl2.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl1-to-webgl2.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl1-to-webgl2.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl1-to-webgl2.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl1-to-webgl2.html" >English</a>
    <option value="/webgl/lessons/de/webgl1-to-webgl2.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl1-to-webgl2.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl1-to-webgl2.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl1-to-webgl2.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl1-to-webgl2.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl1-to-webgl2.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 из WebGL1</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL2 <strong>почти</strong> на 100% обратно совместим с WebGL1.
Если вы используете только функции WebGL1, то есть только
2 <strong>основных</strong> различия.</p>
<ol>
<li>
<p>Вы используете <code class="notranslate" translate="no">&quot;webgl2&quot;</code> вместо <code class="notranslate" translate="no">&quot;webgl&quot;</code> при вызове <code class="notranslate" translate="no">getContext</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var gl = someCanvas.getContext(&quot;webgl2&quot;);
</code></pre>
<p>Примечание: нет “experimental-webgl2”. Производители браузеров собрались
вместе и решили не продолжать префиксовать вещи, потому что веб-сайты
становятся зависимыми от префикса.</p>
</li>
<li>
<p>Многие расширения являются стандартной частью WebGL2 и поэтому недоступны
как расширения.</p>
<p>Например, объекты вершинных массивов <code class="notranslate" translate="no">OES_vertex_array_object</code> являются
стандартной функцией WebGL2. Так, например, в WebGL1 вы бы делали это</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var ext = gl.getExtension(&quot;OES_vertex_array_object&quot;);
if (!ext) {
  // сказать пользователю, что у него нет требуемого расширения или обойти это
} else {
  var someVAO = ext.createVertexArrayOES();
}
</code></pre>
<p>В WebGL2 вы бы делали это</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someVAO = gl.createVertexArray();
</code></pre>
<p>Потому что это просто существует.</p>
</li>
</ol>
<p>Тем не менее, чтобы воспользоваться большинством функций WebGL2, вам нужно будет внести
некоторые изменения.</p>
<h2 id="переход-на-glsl-300-es">Переход на GLSL 300 es</h2>
<p>Самое большое изменение - вы должны обновить ваши шейдеры до GLSL 3.00 ES. Для этого
первая строка ваших шейдеров должна быть</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
</code></pre>
<p><strong>ПРИМЕЧАНИЕ: ЭТО ДОЛЖНО БЫТЬ ПЕРВОЙ СТРОКОЙ! Никаких комментариев и пустых строк перед ней не допускается.</strong></p>
<p>Другими словами, это плохо</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// ПЛОХО!!!!                +---Здесь есть новая строка!
// ПЛОХО!!!!                V
var vertexShaderSource = `
#version 300 es
..
`;
</code></pre>
<p>Это тоже плохо</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;!-- ПЛОХО!!                   V&lt;- здесь есть новая строка
&lt;script id=&quot;vs&quot; type=&quot;notjs&quot;&gt;
#version 300 es
...
&lt;/script&gt;
</code></pre>
<p>Это хорошо</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShaderSource = `#version 300 es
...
`;
</code></pre>
<p>Это тоже хорошо</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;vs&quot; type=&quot;notjs&quot;&gt;#version 300 es
...
&lt;/script&gt;
</code></pre>
<p>Или вы могли бы сделать ваши функции компиляции шейдеров удалять
первые пустые строки.</p>
<h3 id="изменения-в-glsl-300-es-по-сравнению-с-glsl-100">Изменения в GLSL 300 es по сравнению с GLSL 100</h3>
<p>Есть несколько изменений, которые вам нужно будет внести в ваши шейдеры
помимо добавления строки версии выше.</p>
<h4 id="attribute---in"><code class="notranslate" translate="no">attribute</code> -&gt; <code class="notranslate" translate="no">in</code></h4>
<p>В GLSL 100 у вас могло быть</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
attribute vec2 a_texcoord;
attribute vec3 a_normal;
</code></pre>
<p>В GLSL 300 es это становится</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">in vec4 a_position;
in vec2 a_texcoord;
in vec3 a_normal;
</code></pre>
<h4 id="varying-в-in--out"><code class="notranslate" translate="no">varying</code> в <code class="notranslate" translate="no">in</code> / <code class="notranslate" translate="no">out</code></h4>
<p>В GLSL 100 вы могли объявлять varying в обоих вершинном
и фрагментном шейдерах так</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">varying vec2 v_texcoord;
varying vec3 v_normal;
</code></pre>
<p>В GLSL 300 es в вершинном шейдере varying становятся</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">out vec2 v_texcoord;
out vec3 v_normal;
</code></pre>
<p>А в фрагментном шейдере они становятся</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">in vec2 v_texcoord;
in vec3 v_normal;
</code></pre>
<h4 id="больше-нет-gl_fragcolor">Больше нет <code class="notranslate" translate="no">gl_FragColor</code></h4>
<p>В GLSL 100 ваш фрагментный шейдер устанавливал специальную
переменную <code class="notranslate" translate="no">gl_FragColor</code> для установки выхода шейдера.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl_FragColor = vec4(1, 0, 0, 1);  // красный
</code></pre>
<p>В GLSL 300 es вы объявляете свою собственную выходную переменную и
затем устанавливаете её.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">out vec4 myOutputColor;

void main() {
   myOutputColor = vec4(1, 0, 0, 1);  // красный
}
</code></pre>
<p>Примечание: Вы можете выбрать любое имя, которое хотите, но имена <strong>не могут</strong> начинаться с
<code class="notranslate" translate="no">gl_</code>, поэтому вы не можете просто сделать <code class="notranslate" translate="no">out vec4 gl_FragColor</code>.</p>
<h4 id="texture2d---texture-и-тд"><code class="notranslate" translate="no">texture2D</code> -&gt; <code class="notranslate" translate="no">texture</code> и т.д.</h4>
<p>В GLSL 100 вы получали цвет из текстуры так</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">uniform sampler2D u_some2DTexture;
uniform samplerCube u_someCubeTexture;

...

vec4 color1 = texture2D(u_some2DTexture, ...);
vec4 color2 = textureCube(u_someCubeTexture, ...);
</code></pre>
<p>В GLSL 300 es функции текстур автоматически знают
что делать на основе типа сэмплера. Так что теперь это просто
<code class="notranslate" translate="no">texture</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">uniform sampler2D u_some2DTexture;
uniform samplerCube u_someCubeTexture;

...

vec4 color1 = texture(u_some2DTexture, ...);
vec4 color2 = texture(u_someCubeTexture, ...);
</code></pre>
<h2 id="функции-которые-вы-можете-принимать-как-должное">Функции, которые вы можете принимать как должное</h2>
<p>В WebGL1 многие функции были опциональными расширениями. В WebGL2
все следующее являются стандартными функциями:</p>
<ul>
<li>Текстуры глубины (<a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">WEBGL_depth_texture</a>)</li>
<li>Текстуры с плавающей точкой (<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float/">OES_texture_float</a>/<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear/">OES_texture_float_linear</a>)</li>
<li>Текстуры с половинной плавающей точкой (<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_half_float/">OES_texture_half_float</a>/<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_half_float_linear/">OES_texture_half_float_linear</a>)</li>
<li>Объекты вершинных массивов (<a href="https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/">OES_vertex_array_object</a>)</li>
<li>Стандартные производные (<a href="https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives/">OES_standard_derivatives</a>)</li>
<li>Инстансированное рисование (<a href="https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays/">ANGLE_instanced_arrays</a>)</li>
<li>UNSIGNED_INT индексы (<a href="https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint/">OES_element_index_uint</a>)</li>
<li>Установка <code class="notranslate" translate="no">gl_FragDepth</code> (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth/">EXT_frag_depth</a>)</li>
<li>Уравнение смешивания MIN/MAX (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax/">EXT_blend_minmax</a>)</li>
<li>Прямой доступ к LOD текстуры (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod/">EXT_shader_texture_lod</a>)</li>
<li>Множественные буферы рисования (<a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers/">WEBGL_draw_buffers</a>)</li>
<li>Поддержка sRGB для текстур и объектов framebuffer (<a href="https://www.khronos.org/registry/webgl/extensions/EXT_sRGB/">EXT_sRGB</a>)</li>
<li>Любой уровень текстуры может быть прикреплен к объекту framebuffer (<a href="https://www.khronos.org/registry/webgl/extensions/OES_fbo_render_mipmap/">OES_fbo_render_mipmap</a>)</li>
<li>Доступ к текстурам в вершинных шейдерах</li>
</ul>
<h2 id="поддержка-текстур-не-кратных-степени-2">Поддержка текстур не кратных степени 2</h2>
<p>В WebGL1 текстуры, которые не были кратны степени 2, не могли иметь мипмапы.
В WebGL2 это ограничение снято. Текстуры не кратные степени 2 работают точно
так же, как текстуры кратные степени 2.</p>
<h2 id="прикрепления-framebuffer-с-плавающей-точкой">Прикрепления framebuffer с плавающей точкой</h2>
<p>В WebGL1 для проверки поддержки рендеринга в текстуру с плавающей точкой
вы бы сначала проверили и включили расширение <code class="notranslate" translate="no">OES_texture_float</code>, затем
создали текстуру с плавающей точкой, прикрепили её к framebuffer и вызвали
<code class="notranslate" translate="no">gl.checkFramebufferStatus</code>, чтобы увидеть, возвращает ли он <code class="notranslate" translate="no">gl.FRAMEBUFFER_COMPLETE</code>.</p>
<p>В WebGL2 вам нужно проверить и включить <code class="notranslate" translate="no">EXT_color_buffer_float</code>, иначе
<code class="notranslate" translate="no">gl.checkFramebufferStatus</code> никогда не вернет <code class="notranslate" translate="no">gl.FRAMEBUFFER_COMPLETE</code> для
текстуры с плавающей точкой.</p>
<p>Обратите внимание, что это также верно для прикреплений framebuffer <code class="notranslate" translate="no">HALF_FLOAT</code>.</p>
<blockquote>
<p>Если вам любопытно, это была <em>ошибка</em> в спецификации WebGL1. Что произошло, так это то, что WebGL1
был выпущен и <code class="notranslate" translate="no">OES_texture_float</code> был добавлен, и просто предполагалось, что правильный
способ использования его для рендеринга заключался в создании текстуры, прикреплении её к framebuffer
и проверке её статуса. Позже кто-то указал, что согласно спецификации этого было
недостаточно, потому что спецификация говорит, что цвета, записанные во фрагментном шейдере, всегда
ограничиваются от 0 до 1. <code class="notranslate" translate="no">EXT_color_buffer_float</code> убирает это ограничение зажима,
но поскольку WebGL уже был выпущен около года, это сломало бы многие веб-сайты, если бы
ограничение было применено. Для WebGL2 они смогли исправить это, и теперь вы должны включить
<code class="notranslate" translate="no">EXT_color_buffer_float</code>, чтобы использовать текстуры с плавающей точкой как прикрепления framebuffer.</p>
<p>ПРИМЕЧАНИЕ: Насколько мне известно, по состоянию на март 2017 года очень немногие мобильные устройства
поддерживают рендеринг в текстуры с плавающей точкой.</p>
</blockquote>
<h2 id="объекты-вершинных-массивов">Объекты вершинных массивов</h2>
<p>Из всех функций выше та функция, которую я лично считаю, что вы должны
всегда ВСЕГДА использовать - это объекты вершинных массивов. Все остальное действительно
зависит от того, что вы пытаетесь сделать, но объекты вершинных массивов в частности
кажутся базовой функцией, которую всегда следует использовать.</p>
<p>В WebGL1 без объектов вершинных массивов все данные об атрибутах
были глобальным состоянием WebGL. Вы можете представить это так</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var glState = {
  attributeState: {
    ELEMENT_ARRAY_BUFFER: null,
    attributes: [
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
      { enable: ?, size: ?, type: ?, normalize: ?, stride: ?, offset: ?, buffer: ?, },
    ],
  },
}
</code></pre>
<p>Вызов функций типа <code class="notranslate" translate="no">gl.vertexAttribPointer</code>, <code class="notranslate" translate="no">gl.enableVertexAttribArray</code> и
<code class="notranslate" translate="no">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ??)</code> влиял на это глобальное состояние.
Перед каждой вещью, которую вы хотели нарисовать, вам нужно было настроить все атрибуты, и если вы
рисовали индексированные данные, вам нужно было установить <code class="notranslate" translate="no">ELEMENT_ARRAY_BUFFER</code>.</p>
<p>С объектами вершинных массивов все это <code class="notranslate" translate="no">attributeState</code> выше становится <em>Вершинным массивом</em>.</p>
<p>Другими словами</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someVAO = gl.createVertexArray();
</code></pre>
<p>Создает новый экземпляр вещи выше, называемой <code class="notranslate" translate="no">attributeState</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindVertexArray(someVAO);
</code></pre>
<p>Это эквивалентно</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">glState.attributeState = someVAO;
</code></pre>
<p>Что это означает, так это то, что вы должны настроить все ваши атрибуты во время инициализации сейчас.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// во время инициализации
for each model / geometry / ...
  var vao = gl.createVertexArray()
  gl.bindVertexArray(vao);
  for each attribute
    gl.enableVertexAttribArray(...);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufferForAttribute);
    gl.vertexAttribPointer(...);
  if indexed geometry
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bindVertexArray(null);
</code></pre>
<p>Затем во время рендеринга для использования конкретной геометрии все, что вам нужно сделать,
это</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindVertexArray(vaoForGeometry);
</code></pre>
<p>В WebGL1 цикл инициализации выше появился бы во время рендеринга.
Это ОГРОМНОЕ ускорение!</p>
<p>Есть несколько предостережений:</p>
<ol>
<li>
<p>расположения атрибутов зависят от программы.</p>
<p>Если вы собираетесь использовать одну и ту же геометрию с несколькими
программами, рассмотрите ручное назначение расположений атрибутов.
В GLSL 300 es вы можете сделать это в шейдере.</p>
<p>Например:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">layout(location = 0) in vec4 a_position;
layout(location = 1) in vec2 a_texcoord;
layout(location = 2) in vec3 a_normal;
layout(location = 3) in vec4 a_color;
</code></pre>
<p>Устанавливает расположения 4 атрибутов.</p>
<p>Вы также можете все еще делать это способом WebGL1, вызывая
<code class="notranslate" translate="no">gl.bindAttribLocation</code> перед вызовом <code class="notranslate" translate="no">gl.linkProgram</code>.</p>
<p>Например:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindAttribLocation(someProgram, 0, &quot;a_position&quot;);
gl.bindAttribLocation(someProgram, 1, &quot;a_texcoord&quot;);
gl.bindAttribLocation(someProgram, 2, &quot;a_normal&quot;);
gl.bindAttribLocation(someProgram, 3, &quot;a_color&quot;);
</code></pre>
<p>Это означает, что вы можете заставить их быть совместимыми между несколькими шейдерными
программами. Если одной программе не нужны все атрибуты,
атрибуты, которые им нужны, все еще будут назначены на
те же расположения.</p>
<p>Если вы не сделаете этого, вам понадобятся разные VAO для
разных шейдерных программ при использовании одной и той же геометрии ИЛИ
вам нужно будет просто делать вещь WebGL1 и не использовать
VAO и всегда настраивать атрибуты во время рендеринга, что медленно.</p>
<p>ПРИМЕЧАНИЕ: из 2 методов выше я склоняюсь к использованию
<code class="notranslate" translate="no">gl.bindAttribLocation</code>, потому что легко иметь это в одном
месте в моем коде, тогда как метод использования <code class="notranslate" translate="no">layout(location = ?)</code> должен
быть во всех шейдерах, поэтому в интересах D.R.Y., <code class="notranslate" translate="no">gl.bindAttribLocation</code>
кажется лучше. Может быть, если бы я использовал генератор шейдеров, то разницы бы не было.</p>
</li>
<li>
<p>Всегда отвязывайте VAO, когда закончили</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindVertexArray(null);
</code></pre>
<p>Это просто из моего собственного опыта. Если вы посмотрите выше,
состояние <code class="notranslate" translate="no">ELEMENT_ARRAY_BUFFER</code> является частью вершинного массива.</p>
<p>Итак, я столкнулся с этой проблемой. Я создал некоторую геометрию, затем
я создал VAO для этой геометрии и настроил атрибуты
и <code class="notranslate" translate="no">ELEMENT_ARRAY_BUFFER</code>. Затем я создал еще немного
геометрии. Когда эта геометрия настраивала свои индексы, потому что
у меня все еще был привязан предыдущий VAO, индексы
повлияли на привязку <code class="notranslate" translate="no">ELEMENT_ARRAY_BUFFER</code> для предыдущего
VAO. Мне потребовалось несколько часов для отладки.</p>
<p>Итак, мое предложение - никогда не оставлять VAO привязанным, если вы закончили
с ним. Либо немедленно привяжите следующий VAO, который собираетесь
использовать, либо привяжите <code class="notranslate" translate="no">null</code>, если закончили.</p>
</li>
</ol>
<p>Как упоминалось в начале, многие расширения из WebGL1 являются стандартными функциями
WebGL2, поэтому если вы использовали расширения в WebGL1, вам нужно будет
изменить ваш код, чтобы не использовать их как расширения в WebGL2. См. ниже.</p>
<p>Два, которые требуют особого внимания:</p>
<ol>
<li>
<p><code class="notranslate" translate="no">OES_texture_float</code> и текстуры с плавающей точкой.</p>
<p>Текстуры с плавающей точкой являются стандартной функцией WebGL2, но:</p>
<ul>
<li>
<p>Возможность фильтрации текстур с плавающей точкой все еще является расширением: <code class="notranslate" translate="no">OES_texture_float_linear</code>.</p>
</li>
<li>
<p>Возможность рендеринга в текстуру с плавающей точкой является расширением: <code class="notranslate" translate="no">EXT_color_buffer_float</code>.</p>
</li>
<li>
<p>Создание текстуры с плавающей точкой отличается. Вы должны использовать один из новых внутренних форматов WebGL2
как <code class="notranslate" translate="no">RGBA32F</code>, <code class="notranslate" translate="no">R32F</code> и т.д. Это отличается от расширения WebGL1 <code class="notranslate" translate="no">OES_texture_float</code>,
в котором внутренний формат выводился из <code class="notranslate" translate="no">type</code>, переданного в <code class="notranslate" translate="no">texImage2D</code>.</p>
</li>
</ul>
</li>
<li>
<p><code class="notranslate" translate="no">WEBGL_depth_texture</code> и текстуры глубины.</p>
<p>Аналогично предыдущему различию, для создания текстуры глубины в WebGL2 вы должны использовать один из
внутренних форматов WebGL2: <code class="notranslate" translate="no">DEPTH_COMPONENT16</code>, <code class="notranslate" translate="no">DEPTH_COMPONENT24</code>,
<code class="notranslate" translate="no">DEPTH_COMPONENT32F</code>, <code class="notranslate" translate="no">DEPTH24_STENCIL8</code> или <code class="notranslate" translate="no">DEPTH32F_STENCIL8</code>, тогда как расширение WebGL1
<code class="notranslate" translate="no">WEBGL_depth_texture</code> использовало <code class="notranslate" translate="no">DEPTH_COMPONENT</code> и <code class="notranslate" translate="no">DEPTH_STENCIL_COMPONENT</code>.</p>
</li>
</ol>
<p>Это мой личный короткий список вещей, о которых нужно знать при переходе
с WebGL1 на WebGL2. <a href="webgl2-whats-new.html">Есть еще больше вещей, которые вы можете делать в WebGL2</a>.</p>
<div class="webgl_bottombar">
<h3>Заставляем расширения WebGL1 выглядеть как WebGL2</h3>
<p>Функции, которые были в расширениях в WebGL1, теперь находятся в основном
контексте в WebGL2. Например, в WebGL1</p>
<pre class="prettyprint">
var ext = gl.getExtension("OES_vertex_array_object");
if (!ext) {
  // сказать пользователю, что у него нет требуемого расширения или обойти это
} else {
  var someVAO = ext.createVertexArrayOES();
}
</pre>
<p>
против в webgl2
</p>
<pre class="prettyprint">
var someVAO = gl.createVertexArray();
</pre>
<p>Как вы можете видеть, если вы хотите, чтобы ваш код работал как в WebGL1, так и в WebGL2, то
это может представлять некоторые проблемы.</p>
<p>Одним из обходных путей было бы копирование расширений WebGL1 в контекст WebGL во время инициализации.
Таким образом, остальная часть вашего кода может остаться той же. Пример:</p>
<pre class="prettyprint">
const gl &#x3D; someCanvas.getContext(&quot;webgl&quot;);
const haveVAOs &#x3D; getAndApplyExtension(gl, &quot;OES_vertex_array_object&quot;);

function getAndApplyExtension(gl, name) {
  const ext &#x3D; gl.getExtension(name);
  if (!ext) {
    return null;
  }
  const fnSuffix &#x3D; name.split(&quot;_&quot;)[0];
  const enumSuffix &#x3D; &#x27;_&#x27; + fnSuffix;
  for (const key in ext) {
    const value &#x3D; ext[key];
    const isFunc &#x3D; typeof (value) &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
    const suffix &#x3D; isFunc ? fnSuffix : enumSuffix;
    let name &#x3D; key;
    // примеры, где это не так, это WEBGL_compressed_texture_s3tc
    // и WEBGL_compressed_texture_pvrtc
    if (key.endsWith(suffix)) {
      name &#x3D; key.substring(0, key.length - suffix.length);
    }
    if (gl[name] !&#x3D;&#x3D; undefined) {
      if (!isFunc &amp;&amp; gl[name] !&#x3D;&#x3D; value) {
        console.warn(&quot;conflict:&quot;, name, gl[name], value, key);
      }
    } else {
      if (isFunc) {
        gl[name] &#x3D; function(origFn) {
          return function() {
            return origFn.apply(ext, arguments);
          };
        }(value);
      } else {
        gl[name] &#x3D; value;
      }
    }
  }
  return ext;
}
</pre>
<p>Теперь ваш код может в основном просто работать одинаково на обоих. Пример:</p>
<pre class="prettyprint">
if (haveVAOs) {
  var someVAO &#x3D; gl.createVertexArray();
  ...
} else {
  ... делать что-то для отсутствия VAO.
}
</pre>
<p>Альтернативой было бы делать что-то вроде этого</p>
<pre class="prettyprint">
if (haveVAOs) {
  if (isWebGL2)
     someVAO &#x3D; gl.createVertexArray();
  } else {
     someVAO &#x3D; vaoExt.createVertexArrayOES();
  }
  ...
} else {
  ... делать что-то для отсутствия VAO.
}
</pre>
<p>Примечание: В случае объектов вершинных массивов в частности я предлагаю вам <a href="https://github.com/greggman/oes-vertex-array-object-polyfill">использовать полифилл</a>
чтобы они были везде. VAO доступны на большинстве систем. На тех немногих системах
где они недоступны, полифилл обработает это за вас, и ваш код
может остаться простым.</p>
</div> 
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl1-to-webgl2.html" >English</a>
    <option value="/webgl/lessons/de/webgl1-to-webgl2.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl1-to-webgl2.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl1-to-webgl2.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl1-to-webgl2.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl1-to-webgl2.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl1-to-webgl2.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 из WebGL1';
            var disqus_title = 'WebGL2 из WebGL1';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




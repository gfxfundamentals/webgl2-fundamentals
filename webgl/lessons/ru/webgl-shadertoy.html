<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-shadertoy.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Шейдеры Shadertoy">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ru.jpg">

<meta property="og:title" content="WebGL2 Shadertoy">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ru.jpg">
<meta property="og:description" content="Шейдеры Shadertoy">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadertoy.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Shadertoy">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadertoy.html">
<meta name="twitter:description" content="Шейдеры Shadertoy">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadertoy.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadertoy.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadertoy.html",
      "inLanguage":"ru",
      "name":"WebGL2 Shadertoy",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadertoy.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Shadertoy</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shadertoy.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shadertoy.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shadertoy.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Shadertoy</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья предполагает, что вы прочитали многие другие статьи,
начиная с <a href="webgl-fundamentals.html">основ</a>.
Если вы их не читали, пожалуйста, начните сначала там.</p>
<p>В <a href="webgl-drawing-without-data.html">статье о рисовании без данных</a>
мы показали несколько примеров рисования вещей без данных, используя
вершинный шейдер. Эта статья будет о рисовании вещей без
данных, используя фрагментные шейдеры.</p>
<p>Мы начнем с простого шейдера сплошного цвета
без математики, используя код <a href="webgl-fundamentals.html">из самой первой статьи</a>.</p>
<p>Простой вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
  // атрибут - это вход (in) в вершинный шейдер.
  // Он будет получать данные из буфера
  in vec4 a_position;

  // все шейдеры имеют главную функцию
  void main() {

    // gl_Position - это специальная переменная, за установку которой
    // отвечает вершинный шейдер
    gl_Position = a_position;
  }
`;
</code></pre>
<p>и простой фрагментный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  // нам нужно объявить выход для фрагментного шейдера
  out vec4 outColor;

  void main() {
    outColor = vec4(1, 0, 0.5, 1); // возвращаем красно-фиолетовый
  }
`;
</code></pre>
<p>Затем нам нужно скомпилировать и связать шейдеры и найти местоположение атрибута position.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  // Получаем WebGL контекст
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector(&quot;#canvas&quot;);
  const gl = canvas.getContext(&quot;webgl2&quot;);
  if (!gl) {
    return;
  }

  // настройка GLSL программы
  const program = webglUtils.createProgramFromSources(gl, [vs, fs]);

  // ищем, куда должны идти вершинные данные.
  const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p>и затем создать вершинный массив,
заполнить буфер 2 треугольниками, которые создают прямоугольник в clip space, который
идет от -1 до +1 по x и y, чтобы покрыть canvas, и установить атрибуты.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // Создаем объект вершинного массива (состояние атрибутов)
  const vao = gl.createVertexArray();

  // и делаем его тем, с которым мы сейчас работаем
  gl.bindVertexArray(vao);

  // Создаем буфер для размещения трех 2d точек clip space
  const positionBuffer = gl.createBuffer();

  // Привязываем его к ARRAY_BUFFER (думайте об этом как ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // заполняем его 2 треугольниками, которые покрывают clip space
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  // первый треугольник
     1, -1,
    -1,  1,
    -1,  1,  // второй треугольник
     1, -1,
     1,  1,
  ]), gl.STATIC_DRAW);

  // Включаем атрибут
  gl.enableVertexAttribArray(positionAttributeLocation);

  // Говорим атрибуту, как получать данные из positionBuffer (ARRAY_BUFFER)
  gl.vertexAttribPointer(
      positionAttributeLocation,
      2,          // 2 компонента на итерацию
      gl.FLOAT,   // данные - 32-битные float'ы
      false,      // не нормализуем данные
      0,          // 0 = двигаемся вперед на size * sizeof(type) каждую итерацию, чтобы получить следующую позицию
      0,          // начинаем с начала буфера
  );
</code></pre>
<p>И затем мы рисуем</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // Говорим WebGL, как конвертировать из clip space в пиксели
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // Говорим использовать нашу программу (пару шейдеров)
  gl.useProgram(program);

  // Привязываем набор атрибутов/буферов, который мы хотим.
  gl.bindVertexArray(vao);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // смещение
      6,     // количество вершин для обработки
  );
</code></pre>
<p>И конечно, мы получаем сплошной цвет, который покрывает canvas.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-solid.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-solid.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>В <a href="webgl-how-it-works.html">статье о том, как работает WebGL</a> мы добавили больше
цвета, предоставляя цвет для каждой вершины. В <a href="webgl-3d-textures.html">статье о текстурах</a>
мы добавили больше цвета, предоставляя текстуры и координаты текстуры.
Так как же мы получаем что-то большее, чем сплошной цвет, без дополнительных данных?
WebGL предоставляет переменную, называемую <code class="notranslate" translate="no">gl_FragCoord</code>, которая равна <strong>пиксельной</strong>
координате пикселя, который в данный момент рисуется.</p>
<p>Итак, давайте изменим наш фрагментный шейдер, чтобы использовать это для вычисления цвета</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  // нам нужно объявить выход для фрагментного шейдера
  out vec4 outColor;

  void main() {
    outColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
  }
`;
</code></pre>
<p>Как мы упомянули выше, <code class="notranslate" translate="no">gl_FragCoord</code> - это <strong>пиксельная</strong> координата, поэтому она будет
считаться поперек и вверх canvas. Разделив на 50, мы получим значение, которое идет
от 0 до 1, когда <code class="notranslate" translate="no">gl_FragCoord</code> идет от 0 до 50. Используя <code class="notranslate" translate="no">fract</code>, мы
сохраним только <em>дробную</em> часть, так что, например, когда <code class="notranslate" translate="no">gl_FragCoord</code> равен 75.
75 / 50 = 1.5, fract(1.5) = 0.5, поэтому мы получим значение, которое идет от 0 до 1
каждые 50 пикселей.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-gl-fragcoord.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-gl-fragcoord.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Как вы можете видеть выше, каждые 50 пикселей поперек красный идет от 0 до 1,
и каждые 50 пикселей вверх зеленый идет от 0 до 1.</p>
<p>С нашей настройкой теперь мы могли бы сделать более сложную математику для более причудливого изображения.
но у нас есть одна проблема в том, что мы не знаем, насколько велик canvas,
поэтому нам пришлось бы жестко кодировать для конкретного размера. Мы можем решить эту проблему,
передав размер canvas, а затем разделив <code class="notranslate" translate="no">gl_FragCoord</code> на
размер, чтобы дать нам значение, которое идет от 0 до 1 поперек и вверх canvas
независимо от размера.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;

  // нам нужно объявить выход для фрагментного шейдера
  out vec4 outColor;

  void main() {
    outColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>и найти и установить uniform</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// ищем, куда должны идти вершинные данные.
const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);

// ищем местоположения uniforms
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre>
<p>и установить uniform</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
</code></pre>
<p>что позволяет нам сделать наш разброс красного и зеленого всегда подходящим для canvas независимо
от разрешения</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-resolution.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-resolution.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Давайте также передадим позицию мыши в пиксельных координатах.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;

  // нам нужно объявить выход для фрагментного шейдера
  out vec4 outColor;

  void main() {
    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>И затем нам нужно найти местоположение uniform,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// ищем местоположения uniforms
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
</code></pre>
<p>отслеживать мышь,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;

function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // низ равен 0 в WebGL
  render();
}

canvas.addEventListener('mousemove', setMousePosition);
</code></pre>
<p>и установить uniform.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
gl.uniform2f(mouseLocation, mouseX, mouseY);
</code></pre>
<p>Нам также нужно изменить код, чтобы мы рендерили, когда позиция мыши изменяется</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // низ равен 0 в WebGL
  render();
}

function render() {
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // смещение
      6,     // количество вершин для обработки
  );
}
render();
</code></pre>
<p>и пока мы этим занимаемся, давайте также обработаем касание</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">canvas.addEventListener('mousemove', setMousePosition);
canvas.addEventListener('touchstart', (e) =&gt; {
  e.preventDefault();
}, {passive: false});
canvas.addEventListener('touchmove', (e) =&gt; {
  e.preventDefault();
  setMousePosition(e.touches[0]);
}, {passive: false});
</code></pre>
<p>и теперь вы можете видеть, что если вы двигаете мышь над примером, это влияет на наше изображение.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-mouse.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-mouse.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Финальная основная часть - мы хотим иметь возможность анимировать что-то, поэтому мы передаем еще одну
вещь, значение времени, которое мы можем использовать для добавления к нашим вычислениям.</p>
<p>Например, если бы мы сделали это</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_time;

  // нам нужно объявить выход для фрагментного шейдера
  out vec4 outColor;

  void main() {
    outColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), fract(u_time), 1);
  }
`;
</code></pre>
<p>И теперь синий канал будет пульсировать в такт времени. Нам просто нужно
найти uniform и установить его в цикле <a href="webgl-animation.html">requestAnimationFrame</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// ищем местоположения uniforms
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);

...

function render(time) {
  time *= 0.001;  // конвертируем в секунды

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
  gl.uniform2f(mouseLocation, mouseX, mouseY);
  gl.uniform1f(timeLocation, time);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // смещение
      6,     // количество вершин для обработки
  );

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>Также нам больше не нужно рендерить при движении мыши, поскольку мы рендерим непрерывно.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;
canvas.addEventListener('mousemove', (e) =&gt; {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // низ равен 0 в WebGL
});
</code></pre>
<p>И мы получаем простую, но скучную анимацию.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-time.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-time.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Итак, теперь со всем этим мы можем взять шейдер с <a href="https://shadertoy.com">Shadertoy.com</a>. В шейдерах Shadertoy вы предоставляете функцию, называемую <code class="notranslate" translate="no">mainImage</code>, в этой форме</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void mainImage(out vec4 fragColor, in vec2 fragCoord)
{	
}
</code></pre>
<p>Где ваша задача - установить <code class="notranslate" translate="no">fragColor</code> так же, как вы обычно устанавливали бы <code class="notranslate" translate="no">gl_FragColor</code>, и
<code class="notranslate" translate="no">fragCoord</code> - это то же самое, что и <code class="notranslate" translate="no">gl_FragCoord</code>. Добавление этой дополнительной функции позволяет Shadertoy
наложить немного больше структуры, а также выполнить некоторую дополнительную работу до или после вызова
<code class="notranslate" translate="no">mainImage</code>. Для нас, чтобы использовать это, нам просто нужно вызвать это так</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

out vec4 outColor;

//---вставьте код shadertoy здесь--

void main() {
  mainImage(outColor, gl_FragCoord.xy);
}
</code></pre>
<p>За исключением того, что Shadertoy использует имена uniforms <code class="notranslate" translate="no">iResolution</code>, <code class="notranslate" translate="no">iMouse</code> и <code class="notranslate" translate="no">iTime</code>, поэтому давайте переименуем их.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

uniform vec2 iResolution;
uniform vec2 iMouse;
uniform float iTime;

//---вставьте код shadertoy здесь--

out vec4 outColor;

void main() {
  mainImage(outColor, gl_FragCoord.xy);
}
</code></pre>
<p>и найти их по новым именам</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// ищем местоположения uniforms
const resolutionLocation = gl.getUniformLocation(program, &quot;iResolution&quot;);
const mouseLocation = gl.getUniformLocation(program, &quot;iMouse&quot;);
const timeLocation = gl.getUniformLocation(program, &quot;iTime&quot;);
</code></pre>
<p>Взяв <a href="https://www.shadertoy.com/view/3l23Rh">этот шейдер shadertoy</a> и вставив его
в наш шейдер выше, где написано <code class="notranslate" translate="no">//---вставьте код shadertoy здесь--</code>, мы получаем…</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Это необычайно красивое изображение для отсутствия данных!</p>
<p>Я сделал пример выше рендериться только когда мышь находится над canvas или когда касается.
Это потому, что математика, необходимая
для рисования изображения выше, сложна и медленна, и позволить ей работать непрерывно
сделало бы очень трудным взаимодействие с этой страницей. Если у вас
очень быстрый GPU, изображение выше может работать плавно. На моем ноутбуке
хотя оно работает медленно и рывками.</p>
<p>Это поднимает чрезвычайно важный момент. <strong>Шейдеры на
shadertoy не являются лучшей практикой</strong>. Shadertoy - это головоломка и
вызов <em>“Если у меня нет данных и только функция, которая
принимает очень мало входных данных, могу ли я сделать интересное или красивое
изображение”</em>. Это не способ сделать производительный WebGL.</p>
<p>Возьмите, например, <a href="https://www.shadertoy.com/view/4sS3zG">этот удивительный шейдер shadertoy</a>, который выглядит так</p>
<div class="webgl_center"><img src="../resources/shadertoy-dolphin.png" style="width: 639px;"></div>
<p>Он красивый, но работает со скоростью около 19 кадров в секунду в крошечном
окне 640x360 на моем мощном ноутбуке. Расширьте окно до полного экрана, и оно работает около
2 или 3 кадров в секунду. Тестирование на моем более мощном настольном компьютере оно все еще достигает только 45 кадров в
секунду при 640x360 и может быть 10 в полноэкранном режиме.</p>
<p>Сравните это с этой игрой, которая также довольно красива и все же работает со скоростью 30-60 кадров в секунду
даже на менее мощных GPU</p>
<iframe class="webgl_center" style="width:560px; height: 360px;" src="https://www.youtube-nocookie.com/embed/7v9gZK9HqqI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Это потому, что игра использует лучшие практики, рисуя вещи текстурированными
треугольниками вместо сложной математики.</p>
<p>Итак, пожалуйста, примите это близко к сердцу. Примеры на Shadertoy
просто удивительны отчасти потому, что теперь вы знаете, что они сделаны
под экстремальным ограничением почти отсутствия данных и являются сложными
функциями, которые рисуют красивые картины. Как таковые, они являются предметом
удивления.</p>
<p>Они также отличный способ изучить много математики.
Но они также никоим образом не являются способом получить производительное
WebGL приложение. Поэтому, пожалуйста, имейте это в виду.</p>
<p>В противном случае, если вы хотите запустить больше шейдеров Shadertoy, вам
потребуется предоставить еще несколько uniforms. Вот список
uniforms, которые предоставляет Shadertoy</p>
<div class="webgl_center"><table  class="tabular-data tabular-data1">
<thead><tr><td>тип</td><td>имя</td><td>где</td><td>описание</td></tr></thead>
<tbody>
<tr><td><b>vec3</b></td><td><b>iResolution</b></td><td>image / buffer</td><td>Разрешение viewport (z - соотношение сторон пикселя, обычно 1.0)</td></tr>
<tr><td><b>float</b></td><td><b>iTime</b></td><td>image / sound / buffer</td><td>Текущее время в секундах</td></tr>
<tr><td><b>float</b></td><td><b>iTimeDelta</b></td><td>image / buffer</td><td>Время, необходимое для рендеринга кадра, в секундах</td></tr>
<tr><td><b>int</b></td><td><b>iFrame</b></td><td>image / buffer</td><td>Текущий кадр</td></tr>
<tr><td><b>float</b></td><td><b>iFrameRate</b></td><td>image / buffer</td><td>Количество кадров, рендеренных в секунду</td></tr>
<tr><td><b>float</b></td><td><b>iChannelTime[4]</b></td><td>image / buffer</td><td>Время для канала (если видео или звук), в секундах</td></tr>
<tr><td><b>vec3</b></td><td><b>iChannelResolution[4]</b></td><td>image / buffer / sound</td><td>Разрешение входной текстуры для каждого канала</td></tr>
<tr><td><b>vec4</b></td><td><b>iMouse</b></td><td>image / buffer</td><td>xy = текущие пиксельные координаты (если LMB нажата). zw = координаты клика</td></tr>
<tr><td><b>sampler2D</b></td><td><b>iChannel{i}</b></td><td>image / buffer / sound</td><td>Сэмплер для входных текстур i</td></tr>
<tr><td><b>vec4</b></td><td><b>iDate</b></td><td>image / buffer / sound</td><td>Год, месяц, день, время в секундах в .xyzw</td></tr>
<tr><td><b>float</b></td><td><b>iSampleRate</b></td><td>image / buffer / sound</td><td>Частота дискретизации звука (обычно 44100)</td></tr>
</tbody></table></div>
<p>Обратите внимание, что <code class="notranslate" translate="no">iMouse</code> и <code class="notranslate" translate="no">iResolution</code> на самом деле должны быть
<code class="notranslate" translate="no">vec4</code> и <code class="notranslate" translate="no">vec3</code> соответственно, поэтому вам может потребоваться настроить
их, чтобы они соответствовали.</p>
<p><code class="notranslate" translate="no">iChannel</code> - это текстуры, поэтому если шейдер нуждается в них, вам нужно будет
предоставить <a href="webgl-3d-textures.html">текстуры</a>.</p>
<p>Shadertoy также позволяет вам использовать несколько шейдеров для рендеринга в
текстуры вне экрана, поэтому если шейдер нуждается в них, вам нужно будет настроить
<a href="webgl-render-to-texture.html">текстуры для рендеринга</a>.</p>
<p>Колонка “где” указывает, какие uniforms
доступны в каких шейдерах. “image” - это шейдер,
который рендерит в canvas. “buffer” - это шейдер,
который рендерит в текстуру вне экрана. “sound” - это
шейдер, где <a href="https://stackoverflow.com/questions/34859701/how-do-shadertoys-audio-shaders-work">ожидается, что ваш шейдер будет генерировать
звуковые данные в текстуру</a>.</p>
<p>Я надеюсь, это помогло объяснить Shadertoy. Это отличный сайт с удивительными работами,
но хорошо знать, что на самом деле происходит. Если вы хотите узнать больше о
техниках, используемых в этих видах шейдеров, 2 хороших ресурса -
<a href="%22https://www.iquilezles.org/www/index.htm">блог человека, который создал сайт shadertoy</a> и <a href="https://thebookofshaders.com/">The Book of Shaders</a> (что немного вводит в заблуждение, поскольку на самом деле покрывает только виды шейдеров, используемых на shadertoy, а не виды, используемые в производительных приложениях и играх. Тем не менее, это отличный ресурс!</p>
<div class="webgl_bottombar" id="pixel-coords">
<h3>Пиксельные координаты</h3>
<p>Пиксельные координаты в WebGL
ссылаются на их края. Так, например, если бы у нас был canvas размером 3x2 пикселя, то
значение для <code class="notranslate" translate="no">gl_FragCoord</code> в пикселе 2
слева и 1 снизу
было бы 2.5, 1.5
</p>
<div class="webgl_center"><img src="../resources/webgl-pixels.svg" style="width: 500px;"></div>
</div> 
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shadertoy.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shadertoy.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Пикинг (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">WebGL2 как фон HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Вопросы и ответы</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Shadertoy';
            var disqus_title = 'WebGL2 Shadertoy';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>




Title: WebGL2 - Скининг
Description: Как выполнить скининг меша в WebGL
TOC: Скининг


Скининг в графике - это название, данное перемещению набора вершин на основе
взвешенного влияния множественных матриц. Это довольно абстрактно.

Это называется *скинингом*, потому что он обычно используется для создания 3D персонажей
с "скелетом", сделанным из "костей", где "кость" - это другое название для матрицы,
и затем **для каждой вершины** устанавливается влияние каждой кости на эту вершину.

Так, например, кость руки будет иметь почти 100% влияние на вершины
около руки персонажа, тогда как кость стопы будет иметь нулевое влияние
на те же вершины. Вершины вокруг запястья будут иметь некоторое влияние от кости руки и также некоторое от кости руки.

Основная часть заключается в том, что вам нужны кости (что является просто причудливым способом сказать
иерархию матриц) и веса. Веса - это значения для каждой вершины, которые идут
от 0 до 1, чтобы сказать, насколько конкретная кость-матрица влияет на позицию
этой вершины. Веса чем-то похожи на цвета вершин с точки зрения данных.
Один набор весов на вершину. Другими словами, веса помещаются в
буфер и предоставляются через атрибуты.

Обычно вы ограничиваете количество весов на вершину отчасти потому, что
иначе это было бы слишком много данных. Персонаж может иметь откуда угодно
от 15 костей (Virtua Fighter 1) до 150-300 костей (некоторые современные игры).
Если бы у вас было 300 костей, вам понадобилось бы 300 весов НА вершину НА кость. Если бы ваш
персонаж имел 10000 вершин, это потребовало бы 3 миллиона весов.

Итак, вместо этого большинство систем скиннинга в реальном времени ограничивают это ~4 весами на вершину.
Обычно это достигается в экспортере/конвертере, который берет данные из
3D пакетов, таких как blender/maya/3dsmax, и для каждой вершины находит 4
кости с наивысшими весами, а затем нормализует эти веса

Чтобы дать псевдо-пример, не-скинированная вершина обычно вычисляется так

    gl_Position = projection * view * model * position;

Скинированная вершина эффективно вычисляется так

    gl_Position = projection * view *
                  (bone1Matrix * position * weight1 +
                   bone2Matrix * position * weight2 +
                   bone3Matrix * position * weight3 +
                   bone4Matrix * position * weight4);

Как вы можете видеть, это как если бы мы вычисляли 4 разные позиции для каждой вершины, а затем смешивали их обратно в одну, применяя веса.

Предполагая, что вы сохранили матрицы костей в uniform массиве, и вы
передали веса и к какой кости применяется каждый вес как
атрибуты, вы могли бы сделать что-то вроде

    #version 300 es
    in vec4 a_position;
    in vec4 a_weights;         // 4 веса на вершину
    in uvec4 a_boneNdx;        // 4 индекса костей на вершину
    uniform mat4 bones[MAX_BONES];  // 1 матрица на кость

    gl_Position = projection * view *
                  (a_bones[a_boneNdx[0]] * a_position * a_weight[0] +
                   a_bones[a_boneNdx[1]] * a_position * a_weight[1] +
                   a_bones[a_boneNdx[2]] * a_position * a_weight[2] +
                   a_boneS[a_boneNdx[3]] * a_position * a_weight[3]);


Есть еще одна проблема. Допустим, у вас есть модель человека с
началом координат (0,0,0) на полу прямо между их ногами.

<div class="webgl_center"><img src="resources/bone-head.svg" style="width: 500px;"></div>

Теперь представьте, что вы поместили матрицу/кость/сустав у их головы, и вы хотите использовать
эту кость для скиннинга. Чтобы держать это простым, представьте, что вы просто установили
веса так, что вершины головы имеют вес 1.0 для кости головы, и никакие другие суставы не влияют на эти вершины.

<div class="webgl_center"><img src="resources/bone-head-setup.svg" style="width: 500px;"></div>

Есть проблема.
Вершины головы находятся на 2 единицы выше начала координат. Кость головы также на 2
единицы выше начала координат. Если бы вы фактически умножили эти вершины головы на
матрицу кости головы, вы получили бы вершины на 4 единицы выше начала координат. Оригинальные
2 единицы вершин + 2 единицы матрицы кости головы.

<div class="webgl_center"><img src="resources/bone-head-problem.svg" style="width: 500px;"></div>

Решение заключается в сохранении "привязочной позы", которая является дополнительной матрицей на сустав
того, где каждая матрица была до того, как вы использовали ее для влияния на вершины. В этом
случае привязочная поза матрицы головы была бы на 2 единицы выше начала координат.
Итак, теперь вы можете использовать обратную матрицу, чтобы вычесть дополнительные 2
единицы.

Другими словами, матрицы костей, переданные в шейдер, каждая была
умножена на их обратную привязочную позу, чтобы сделать их влияние только
настолько, насколько они изменились от своих оригинальных позиций относительно начала координат
меша.

Давайте создадим небольшой пример. Мы будем анимировать в 2d сетку, подобную этой

<div class="webgl_center"><img src="resources/skinned-mesh.svg" style="width: 400px;"></div>

* Где `b0`, `b1` и `b2` - это матрицы костей.
* `b1` является дочерним элементом `b0`, а `b2` является дочерним элементом `b1`
* Вершины `0,1` получат вес 1.0 от кости b0
* Вершины `2,3` получат вес 0.5 от костей b0 и b1
* Вершины `4,5` получат вес 1.0 от кости b1
* Вершины `6,7` получат вес 0.5 от костей b1 и b2
* Вершины `8,9` получат вес 1.0 от кости b2

Мы будем использовать утилиты, описанные в [меньше кода больше веселья](webgl-less-code-more-fun.html).

Сначала нам нужны вершины и для каждой вершины индекс
каждой кости, которая влияет на нее, и число от 0 до 1
того, насколько сильно влияет эта кость.

```
const arrays = {
  position: {
    numComponents: 2,
    data: [
    0,  1,  // 0
    0, -1,  // 1
    2,  1,  // 2
    2, -1,  // 3
    4,  1,  // 4
    4, -1,  // 5
    6,  1,  // 6
    6, -1,  // 7
    8,  1,  // 8
    8, -1,  // 9
    ],
  },
  boneNdx: {
    numComponents: 4,
    data: new Uint8Array([
      0, 0, 0, 0,  // 0
      0, 0, 0, 0,  // 1
      0, 1, 0, 0,  // 2
      0, 1, 0, 0,  // 3
      1, 0, 0, 0,  // 4
      1, 0, 0, 0,  // 5
      1, 2, 0, 0,  // 6
      1, 2, 0, 0,  // 7
      2, 0, 0, 0,  // 8
      2, 0, 0, 0,  // 9
    ]),
  },
  weight: {
    numComponents: 4,
    data: [
    1, 0, 0, 0,  // 0
    1, 0, 0, 0,  // 1
    .5,.5, 0, 0,  // 2
    .5,.5, 0, 0,  // 3
    1, 0, 0, 0,  // 4
    1, 0, 0, 0,  // 5
    .5,.5, 0, 0,  // 6
    .5,.5, 0, 0,  // 7
    1, 0, 0, 0,  // 8
    1, 0, 0, 0,  // 9
    ],
  },

  indices: {
    numComponents: 2,
    data: [
      0, 1,
      0, 2,
      1, 3,
      2, 3, //
      2, 4,
      3, 5,
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  },
};
// вызывает gl.createBuffer, gl.bindBuffer, gl.bufferData
const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
const skinVAO = twgl.createVAOFromBufferInfo(gl, programInfo, bufferInfo);
```

Мы можем определить наши uniform значения, включая матрицу для каждой кости

```
// 4 матрицы, одна для каждой кости
const numBones = 4;
const boneArray = new Float32Array(numBones * 16);

var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
  bones: boneArray,
  color: [1, 0, 0, 1],
}; 
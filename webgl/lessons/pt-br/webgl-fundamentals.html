<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/pt-br/webgl-fundamentals.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Sua primeira lição da WebGL2: começando com os fundamentos">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_pt-br.jpg">

<meta property="og:title" content="Fundamentos da WebGL2">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_pt-br.jpg">
<meta property="og:description" content="Sua primeira lição da WebGL2: começando com os fundamentos">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="Fundamentos da WebGL2">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html">
<meta name="twitter:description" content="Sua primeira lição da WebGL2: começando com os fundamentos">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_pt-br.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_pt-br.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html",
      "inLanguage":"pt-br",
      "name":"Fundamentos da WebGL2",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html#primaryimage"
      }
    }
  ]
}
</script>


<title>Fundamentos da WebGL2</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-fundamentals.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-fundamentals.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-fundamentals.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fundamentals.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" selected>Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


    <a href="#toc">Índice</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/pt-br/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Fundamentos da WebGL2</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Primeiramente, esses artigos são sobre a WebGL2. Se você está interessado na WebGL 1.0
<a href="https://webglfundamentals.org">por favor, vá aqui</a>. Observe que a WebGL2 é <a href="webgl1-to-webgl2.html">quase 100% compatível
com a WebGL1</a>. Dito isto, uma vez que você habilita a
WebGL2, você também pode usá-la como ela deveria ser usada. Esses tutoriais seguem esse raciocínio.</p>
<p><a href="#%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E3%83%86%E3%82%AF%E3%82%B9%E3%83%88">test</a></p>
<p>Normalmente, a WebGL é vista como uma API 3D. As pessoas pensam: “eu irei usar a WebGL e como uma mágica,
eu vou obter efeitos 3D super legais”. Na realidade não é nada disso, a WebGL é apenas um mecanismo de rasterização. Ela desenha
pontos, linhas e triângulos com base no código que você fornece. Colocar a WebGL para fazer qualquer outra coisa depende de você
fornecer o código de modo que o uso dos pontos, linhas e triângulos sejam capazes de realizar sua tarefa.</p>
<h2 id="日本語のテクスト">日本語のテクスト</h2>
<p>A WebGL é executada diretamente na GPU do seu computador. Como tal, você precisa indicar o código a ser executado na GPU.
Você pode indicar o código na forma de pares de funções. Essas 2 funções são chamadas de vexter shader
e fragment shader e cada uma delas está escrita em linguagem no estilo C/C++ estritamente tipada chamada
<a href="webgl-shaders-and-glsl.html">GLSL</a>. (GL Shader Language). Juntas, elas são chamadas de <em>programa</em>.</p>
<p>O trabalho da vertex shader é calcular as posições dos vértices. Com base nas posições que a função retornar,
o WebGL pode então rasterizar vários tipos de primitivas, incluindo pontos, linhas ou triângulos.
Ao rasterizar essas primitivas, ele chama uma segunda função fornecida pelo usuário chama fragment shader (sombreador de fragmento).
O trabalho do fragment shader é calcula uma cor para cada pixel da primitiva sendo atualmente desenhada.</p>
<p>Quase toda a API da WebGL se resume em configurar o estado para esses pares de funções a serem executadas.
Para cada coisa que você deseja desenhar, configure um grupo de estados e execute um par de funções, chamando
<code class="notranslate" translate="no">gl.drawArrays</code> ou <code class="notranslate" translate="no">gl.drawElements</code> que executa seus shaders (sombreadores) na GPU.</p>
<p>Todos os dados que você deseja que essas funções tenham acesso devem ser fornecidas à GPU.
Há quatro maneiras de como um shader é capaz de obter dados.</p>
<ol>
<li>
<p>Atributos, Buffers, e Vertex Arrays</p>
<p>Buffers são arrays de dados binários que você carrega na GPU. Normalmente, os buffers contêm
coisas como posições, normals, coordenadas de textura, cores de vértices, etc.
embora você esteja livre para colocar tudo o que quiser neles.</p>
<p>Os atributos são usados para especificar como   tirar dados dos seus buffers e fornecê-los para o seu vertex shader.
Por exemplo, você pode colocar posições em um buffer como 3 floats de 32bits
por posição. Você poderia dizer a um determinado atributo qual buffer irá extrair as posições, que tipo de
ele deve retirar (3 componentes de números de pontos flutuantes de 32 bits), qual offset
no buffer as posições se iniciam, e quantos bytes são necessários para obter de um a posição para o próximo.</p>
<p>Buffers não possuem acesso aleatórrio. Em vez disso, um vertex shaders é executado um número específico
de vezes. Cada vez que é executado, o próximo valor de cada buffer especificado é puxado
, e o seu valor é atribuído a um atributo.</p>
<p>O estado dos atributos, quais buffers usar para cada um e como extrair dados
desses buffers, é coletado em um vertex array object (VAO).</p>
</li>
<li>
<p>Uniforms</p>
<p>Uniforms são, efetivamente, variáveis globais que você configurou antes de executar o seu shader.</p>
</li>
<li>
<p>Texturas</p>
<p>As texturas são matrizes de dados que você pode acessar aleatoriamente no seu programa de sombreamento. A coisa mais
para se colocar em uma textura são dados de imagem, mas as apenas dados e podem facilmente
conter algo diferente das cores.</p>
</li>
<li>
<p>Varyings</p>
<p>As Varyings são uma maneira de um vertex shader passar dados para um fragment shader. Dependendo
do que está sendo renderizado, pontos, linhas, ou triângulos, os valores definidos em uma variável
por um vertex shader serão interpolados enquanto o fragment shader é executado.</p>
</li>
</ol>
<h2 id="webgl-hello-world">WebGL Hello World</h2>
<p>A WebGL se preocupa apenas com 2 coisas. Coordenadas do Clispace e cores.
Seu trabalho como programador usando a WebGL é fornecer WebGL com essas 2 coisas.
Você fornece seus 2 “shaders” para fazer isso. Um vexter shader que fornece fornece as
coordenadas do Clispace e um fragment shader que fornece a cor.</p>
<p>As coordenadas do Clispace sempre vão de -1 a +1, independentemente do tamanho do seu canvas.
Aqui está um simples exemplo da WebGL que a mostra em sua forma mais simples.</p>
<p>Vamos começar com um vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// um atributo é um input (in) para um vertex shader.
// ele receberá dados de um buffer
in vec4 a_position;

// todos os shaders possuem uma função main
void main() {

  // gl_Position é uma variável especial de um vertex shader
  // é responsável pela configuração
  gl_Position = a_position;
}
</code></pre>
<p>Quando executada, se toda a coisa fosse escrita em JavaScript em vez de GLSL
você poderia imaginar que isso seria utilizado como o exemplo abaixo</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// *** PSUEDO CÓDIGO!! ***

var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;

drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i &lt; count; ++i) {
     // copia os 4 próximos valores do positionBuffer para o atributo a_position
     const start = offset + i * stride;
     attributes.a_position = positionBuffer.slice(start, start + size);
     runVertexShader();
     ...
     doSomethingWith_gl_Position();
}
</code></pre>
<p>Na realidade, não é tão simples porque o <code class="notranslate" translate="no">positionBuffer</code> precisa ser convertido em dados
binários (veja abaixo) e, portanto, o cálculo real para obter os dados do buffer
seria um pouco diferente, mas espero que isso lhe dê uma ideia de como um vertex shader
será executado.</p>
<p>Em seguida, nós precisamos de um fragment shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

// fragment shaders não tem uma precisão padrão, então nós precisamos
// escolher uma. highp é um bom valor padrão. Do Inglês &quot;high precision&quot;, significa &quot;precisão média&quot;
precision highp float;

// precisamos declarar um output para o fragment shader
out vec4 outColor;

void main() {
  // Simplesmente defina o output para um constante com uma cor avermelhada-roxa
  outColor = vec4(1, 0, 0.5, 1);
}
</code></pre>
<p>Acima, nós declaramos <code class="notranslate" translate="no">outColor</code> como um output do nosso fragment shader. Estamos definindo <code class="notranslate" translate="no">outColor</code> com os valores <code class="notranslate" translate="no">1, 0, 0.5, 1</code>
sendo 1 para vermelho, 0 para verde, 0.5 para azul, 1 para alpha. As cores na WebGL vão de 0 a 1.</p>
<p>Agora que nós escrevemos as duas funções shaders, vamos iniciar com a WebGL</p>
<p>Primeiro precisaremos de um elemento canvas do HTML</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>Então, em JavaScript, podemos obtê-lo da seguinte forma</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var canvas = document.querySelector(&quot;#c&quot;);
</code></pre>
<p>Agora podemos criar um WebGL2RenderingContext</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var gl = canvas.getContext(&quot;webgl2&quot;);
 if (!gl) {
    // sem webgl2 pra você!
    ...
</code></pre>
<p>Agora precisamos compilar esses shaders para colocá-los na GPU, então primeiro precisaremos inseri-los em strings.
Você criar suas strings GLSL da maneira que você normalmente cria strings em JavaScript. Por exemplo, concatenando,
usando AJAX para obtê-las, colocando-as em tags de script non-javascript, ou neste caso,
em literais de templates multilinha.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShaderSource = `#version 300 es

// um atributo é um input (in) para um vertex shader.
// ele receberá dados de um buffer
in vec4 a_position;

// todos os shaders possuem uma função main
void main() {

// gl_Position é uma variável especial de um vertex shader
// é responsável pela configuração
gl_Position = a_position;
}
`;

var fragmentShaderSource = `#version 300 es

// fragment shaders não tem uma precisão padrão, então nós precisamos
// escolher uma. highp é um bom valor padrão. Do Inglês &quot;high precision&quot;, significa &quot;precisão média&quot;
precision highp float;

// precisamos declarar um output para o fragment shader
out vec4 outColor;

void main() {
  // Simplesmente defina o output para um constante com uma cor avermelhada-roxa
  outColor = vec4(1, 0, 0.5, 1);
}
`;
</code></pre>
<p>Na verdade, a maioria dos motores 3D geram shaders GLSL com case em vários tipos de templates, concatenação, etc.
Para as amostras neste site, nenhuma delas é suficientemente complexa para precisar
gerar GLSL em tempo de execução.</p>
<blockquote>
<p>NOTE: <code class="notranslate" translate="no">#version 300 es</code> <strong>DEVE SER A PRIMEIRA LINHA DO SEUS SHADER</strong>. Nenhum comentário ou
linhas em branco são permitidas antes dele! <code class="notranslate" translate="no">#version 300 es</code> diz para a WebGL2 que você deseja
usar a linguagem de shader da WebGL2, chamada GLSL ES 3.00. Se você não colocar isso como a primeira linha, a linguagem padrão
do shader será definida para a da WebGL 1.0, a GLSL ES 1.00 que possui muitas diferenças e bem menos recursos.</p>
</blockquote>
<p>Em seguida, precisamos de uma função que irá criar uma shader, faça o upload da fonte GLSL e compile o shader.
Note que eu não escrevi nenhum comentários visto que através do nome das funções é fácil
compreender o que está acontecendo.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}
</code></pre>
<p>Agora podemos chamar essa função para criar os 2 shaders</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
</code></pre>
<p>Nós, então, precisamos <em>linkar</em> aqueles 2 shaders em um <em>program</em></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}
</code></pre>
<p>E chame isso</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var program = createProgram(gl, vertexShader, fragmentShader);
</code></pre>
<p>Agora que criamos um programa GLSL na GPU, precisamos fornecer dados para ele.
A maioria da API da WebGL se trata de configurar o estado para fornecer dados aos nossos programas GLSL.
Nesse caso, nossa única entrada para o nosso programa GLSL é <code class="notranslate" translate="no">a_position</code>, que por sua vez, é um atributo.
A primeira coisa que devemos fazer é procurar a localização do atributo para o programa
que nós acabamos de criar</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p>Procurar posições de atributos (e locais uniformes) é algo que você deve
fazer durante a inicialização, e não no seu loop de renderização.</p>
<p>Atributos obtêm seus dados através de buffers, então, nós precisamos criar um buffer</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionBuffer = gl.createBuffer();
</code></pre>
<p>A WebGL nos permite manipular muitos recursos da WebGL em pontos de consolidação global.
Você pode pensar em pontos de ligação como variáveis internas globais dentro da WebGL.
Primeiro, você vincula um recurso a um ponto de ligação. E então, todas as outras funções
ao recurso através do ponto de ligação. Então, vamos vincular o buffer de posição.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre>
<p>Agora podemos colocar dados nesse buffer, referenciando-o através do ponto de ligação</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// três pontos 2d
var positions = [
  0, 0,
  0, 0.5,
  0.7, 0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre>
<p>Há muita coisa acontecendo aqui. A primeira coisa que temos é <code class="notranslate" translate="no">positions</code>, que é um
array em JavaScript. A WebGL, por outro lado, precisa de dados fortemente tipados, e então
a parte <code class="notranslate" translate="no">new Float32Array(position)</code> cria uma nova matriz de números de pontos flutuantes de 32 bits
e copia os valores de <code class="notranslate" translate="no">positions</code>. Então, <code class="notranslate" translate="no">gl.bufferData</code> copia esses dados para o <code class="notranslate" translate="no">positionBuffer</code> na GPU. O
buffer de posição está sendo usado porque nós o vinculamos ao ponto de ligação <code class="notranslate" translate="no">ARRAY_BUFFER</code> acima.</p>
<p>O último argumento, <code class="notranslate" translate="no">gl.STATIC_DRAW</code> é uma dica para a WebGL sobre como usaremos os dados.
A WebGL pode tentar usar essa sugestão para otimizar certas coisas. <code class="notranslate" translate="no">gl.STATIC_DRAW</code> diz para a WebGL
que não é provável que mudemos muito esses dados.</p>
<p>Agora que colocamos dados em um buffer, precisamos mostrar ao atributo como obter os dados dele.
Primeiro, precisamos criar uma coleção do estado do atributo denominada Vertex Array Object.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vao = gl.createVertexArray();
</code></pre>
<p>E precisamos fazer com que ele seja o vertex array atual para que todas as nossas
configurações de atributos se apliquem a esse conjunto de estado de atributos</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindVertexArray(vao);
</code></pre>
<p>Finalmente, nós configuramos os atributos no vertex array. Em primeiro lugar, precisamos ativar o atributo.
Isso fala para a WebGL que queremos tirar dados de um buffer. Se não ativarmos o atributo, então, o atributo
terá um valor constante.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre>
<p>Então, nós precisamos especificar como obter os dados</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var size = 2;          // 2 componentes por iteração
var type = gl.FLOAT;   // os dados são floats de 32bits
var normalize = false; // não normalize os dados
var stride = 0;        // 0 = mover para frente size * sizeof(type) cada iteração para obter a próxima posição
var offset = 0;        // comece no início do buffer
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset)
</code></pre>
<p>Uma parte oculta da <code class="notranslate" translate="no">gl.vertexAttribPointer</code> é que ela vincula o atual <code class="notranslate" translate="no">ARRAY_BUFFER</code>
ao atributo. Em outras palavras, agora esse atributo é obrigado a vincular o <code class="notranslate" translate="no">positionBuffer</code>.
Isso significa que estamos livres para ligar outra coisa ao ponto de ligação <code class="notranslate" translate="no">ARRAY_BUFFER</code>;
O atributo continuará usando o <code class="notranslate" translate="no">positionBuffer</code>.</p>
<p>Observe que, do ponto de vista do nosso GLSL vertex shader, o atributo <code class="notranslate" translate="no">a_position</code> é um <code class="notranslate" translate="no">vec4</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">in vec4 a_position;
</code></pre>
<p><code class="notranslate" translate="no">vec4</code> é um 4 float value. Em JavaScript, você poderia pensar em algo como
<code class="notranslate" translate="no">a_position = {x: 0, y: 0, z: 0, w: 0}</code>. Acima, nós definimos <code class="notranslate" translate="no">size = 2</code>. Atributos
padrão para <code class="notranslate" translate="no">0, 0, 0, 1</code> então esse atributo receberá seus primeiros 2 valores (x e y)
do nosso buffer. O z e o w, será o padrão 0 e 1, respectivamente.</p>
<p>Antes de desenharmos, devemos redimensionar nosso canvas (ou nossa tela) para corresponder com o nosso tamanho de exibição. As telas, como as imagens, possuem 2 tamanhos.
O número real de pixels em si e separadamente o tamanho que eles são exibidos.
O CSS determina o tamanho que o canvas é exibido. <strong>Você sempre deve definir o tamanho que deseja
uma tela com o CSS</strong>, pois é muito mais flexível do que qualquer outro método.</p>
<p>Para fazer com que o número de pixels na tela coincida com o tamanho exibido
<a href="webgl-resizing-the-canvas.html">eu faço o uso de um helper, mais detalhes aqui</a>.</p>
<p>Em quase todas essas amostras, o tamanho da tela é de 400x300 pixels se a anistra for executada
em sua própria janela, mas ela se estende para preencher o espaço disponível se estiver dentro de um iframe
como ele está nesta página.
Ao permitir que o CSS determine o tamanho e, em seguida, ajuste seus tamanho para  corresponder ao da tela,
nós facilmente manipulamos ambos os casos.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>Precisamos dizer ao WebGL como converter valores do clip space,
nós vamos configurar o <code class="notranslate" translate="no">gl_Position</code> de volta para pixels, muitas vezes chamado de screen space.
Para isso, chamamos <code class="notranslate" translate="no">gl.viewport</code> e passamos o tamanho atual da tela (canvas).</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre>
<p>Isso diz para a WebGL que o clip space -1 +1 mapeia para o 0 &lt;-&gt; <code class="notranslate" translate="no">gl.canvas.width</code> para x e 0 &lt;-&gt; <code class="notranslate" translate="no">gl.canvas.height</code>
para y.</p>
<p>Agora, nós limpamos nosso canvas. <code class="notranslate" translate="no">0, 0, 0, 0</code> são vermelho, verde, azul, alpha, respectivamente, então, nesse caso, estamos definindo o canvas como transparente.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Limpar o canvas
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre>
<p>Em seguida, precisamos dizer ao WebGL qual shader é executado.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Fala para usar nosso program (par de shaders)
gl.useProgram(program);
</code></pre>
<p>Então precisamos informar qual é o conjunto de buffers usar e como obter os dados desses buffers
e então fornecer os dados aos atributos</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Vincule o atributo/buffer que desejamos.
gl.bindVertexArray(vao);
</code></pre>
<p>Depois de tudo o que fizeemos, finalmente, podemos pedir a WebGL que execute o nosso programa GLSL.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 3;
gl.drawArrays(primitiveType, offset, count);
</code></pre>
<p>Como a contagem é 3, isso executará o nosso vertex shader 3 vezes. A primeira vez <code class="notranslate" translate="no">a_position.x</code> e <code class="notranslate" translate="no">a_position.y</code>
em nosso atributo vertex shader será configurado para os dois primeiros valores do positionBuffer.
A segunda vez <code class="notranslate" translate="no">a_position.xy</code> será configurado para os dois segundos valores. Na última vez, ele será
configurado para os últimos 2 valores.</p>
<p>Como definimos <code class="notranslate" translate="no">primitiveType</code> para <code class="notranslate" translate="no">gl.TRIANGLES</code>, cada vez que nosso vertex shader é executado 3 vezes,
a WebGL desenhará um triângulo com base nos 3 valores que definimos em <code class="notranslate" translate="no">gl_Position</code>. Não importa o tamanho da
nossa tela, esses valores estão nas coordenadas do nosso clip space que vão de -1 a 1 em cada direção.</p>
<p>Como o nosso vertex shader está simplesmente copiando os valores do nosso positionbuffer para a <code class="notranslate" translate="no">gl_Position</code>, o
o triângulo será desenhado nas coordenadas do clip space</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  0, 0,
  0, 0.5,
  0.7, 0,
</code></pre>
<p>Convertendo do clip space para o espaço da tela se o tamanho da tela
passasse ser 400x300, nós teríamos algo assim</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> clip space      screen space
   0, 0       -&gt;   200, 150
   0, 0.5     -&gt;   200, 225
 0.7, 0       -&gt;   340, 150
</code></pre>
<p>A WebGL agora renderizará esse triângulo. Para cada pixel que está prestes a desenhar, a WebGL chamará o nosso fragment shader.
Nosso fragment shader apenas define a <code class="notranslate" translate="no">outColor</code> para <code class="notranslate" translate="no">1, 0, 0.5, 1</code>. Como o Canvas é um canvas de 8bits
por canal, significa que, a WebGL vai escrever os seguintes valores <code class="notranslate" translate="no">[255, 0, 127, 255]</code> na tela.</p>
<p>Aqui está um exemplo já pronto</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-fundamentals.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-fundamentals.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>No caso acima, você pode ver que o nosso vertex shader não está fazendo nada
além de passar nossos dados de posição diretamente. Como os dados da posição já
estão no clipspace, não há trabalho a fazer. <em>Se você quer objetos 3D, só depende de você
fornecer shaders que convertam de 3D para clipspace porque a WebGL é, apenas,
uma API de rasterização</em>.</p>
<p>Você pode estar se perguntando por que o triângulo começa no meio e vai para o canto superior direito.
O clip space em <code class="notranslate" translate="no">x</code> vai de -1 a +1. Isso significa que o 0 está no centro e os valores positivos
irão para à direita dele.</p>
<p>Quanto ao porquê está no topo, o clip space -1 está na parte inferior e +1 está no topo.
Isso significa que, o 0 está no centro e os números positivos estarão acima do centro.</p>
<p>Para coisas 2D, você provavelmente iria preferir trabalhar em pixels do que com o clipspace
então vamos mudar o shader para que possamos fornecer a posição em pixels e
convertê-lo em um clipspace para nós. Aqui está o novo vertex shader</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">-  in vec4 a_position;
+  in vec2 a_position;

+  uniform vec2 u_resolution;

  void main() {
+    // converte a posição dos pixels de 0.0 para 1.0
+    vec2 zeroToOne = a_position / u_resolution;
+
+    // converte de 0-&gt;1 para 0-&gt;2
+    vec2 zeroToTwo = zeroToOne * 2.0;
+
+    // converte de 0-&gt;2 para -1-&gt;+1 (clipspace)
+    vec2 clipSpace = zeroToTwo - 1.0;
+
*    gl_Position = vec4(clipSpace, 0, 1);
  }
</code></pre>
<p>Algumas coisas que devemos notar sobre as mudanças. Nós mudamos a <code class="notranslate" translate="no">a_position</code> para um <code class="notranslate" translate="no">vec2</code> já que nós
estamos apenas usando <code class="notranslate" translate="no">x</code> e <code class="notranslate" translate="no">y</code>. Um <code class="notranslate" translate="no">vec2</code> é semelhante a um <code class="notranslate" translate="no">vec4</code>, porém, possui apenas <code class="notranslate" translate="no">x</code> e <code class="notranslate" translate="no">y</code>.</p>
<p>Em seguida, adicionamos um <code class="notranslate" translate="no">uniform</code> chamado <code class="notranslate" translate="no">u_resolution</code>. Para definir que precisamos procurar por sua localização.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre>
<p>O reste deve estar claro a partir dos comentários. Ao configurar <code class="notranslate" translate="no">u_resolution</code> para a resolução
do nosso canvas, o shader vai agora tomar as posições que colocamos no <code class="notranslate" translate="no">positionBuffer</code> fornecido
nas coordenadas dos pixels e convertê-los em clip space.</p>
<p>Agora podemos alterar os valores da nossa posição do clip space para pixels. Desta vez,
vamos desenhar um retângulo feito de 2 triângulos, 3 pontos, cada.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positions = [
*  10, 20,
*  80, 20,
*  10, 30,
*  10, 30,
*  80, 20,
*  80, 30,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre>
<p>E depois de definirmos qual programa usar, podemos definir o valor do uniform que criamos.
<code class="notranslate" translate="no">gl.useProgram</code> é como <code class="notranslate" translate="no">gl.bindBuffer</code> acima, em que ele define o programa atual.
Depois de tudo, as funções <code class="notranslate" translate="no">gl.uniformXXX</code> definem os uniforms no programa atual.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(program);

// Passa a resolução do canvas, assim nós podemos converter
// de pixels para clipspace no shader
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
</code></pre>
<p>E, claro, para desenhar dois triângulos, precisamos que a WebGL chame nosso vertex shader 6 vezes,
para isso, precisamos mudar o <code class="notranslate" translate="no">count</code> para <code class="notranslate" translate="no">6</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// desenha
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre>
<p>E aqui está</p>
<p>Nota: Este exemplo e todos os exemplos a seguir usam <a href="/webgl/resources/webgl-utils.js"><code class="notranslate" translate="no">webgl-utils.js</code></a>
que contém funções para compilar e vincular os shaders. Não há nenhuma razão para desordenar os
exemplos com o <a href="webgl-boilerplate.html">boilerplate</a>.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>Novamente, você pode notar que o retângulo está perto do fundo dessa área. A WebGL considera que o canto
inferior esquerdo é 0,0. Para que ele seja o tradicional canto superior esquerdo, usado nas APIS de gráficos
2D, nós podemos simplesmente virar a coordenada y do clipspace.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre>
<p>E agora o nosso retângulo está aonde esperavamos.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-top-left.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-top-left.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>Vamos fazer o código que define um retângulo em uma função para
podermos chamá-lo para retângulos de diferentes tamanhos. Enquanto estamos nisso,
nós tornaremos a cor ajustável.</p>
<p>Primeiro fazemos o fragment shader pegar uma color uniform input.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

precision highp float;

+  uniform vec4 u_color;

out vec4 outColor;

void main() {
-  outColor = vec4(1, 0, 0.5, 1);
*  outColor = u_color;
}
</code></pre>
<p>E aqui está o novo código que desenha 50 retângulos com cores e locais aleatórios.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
  ...

  // desenha 50 retângulos com cores e locais aleatórios
  for (var ii = 0; ii &lt; 50; ++ii) {
    // Define um retângulo aleatório
    setRectangle(
        gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

    // Define uma cor aleatória.
    gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);

    // Desenha o retângulo.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
}

// Retorna um inteiro aleatório entre o intervalo de 0 e - 1.
function randomInt(range) {
  return Math.floor(Math.random() * range);
}

// Preenche o buffer com os valores que definem um retângulo.

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;

  // NOTA: gl.bufferData(gl.ARRAY_BUFFER, ...) afetará
  // qualquer buffer que esteja vinculado ao `ARRAY_BUFFER`,
  // mas até agora temos apenas um buffer. Se tivessémos mais de um
  // buffer, gostaríamos de vincular este buffer a `ARRAY_BUFFER` primeiro.

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}
</code></pre>
<p>E aqui está os retângulos.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangles.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>Espero que você veja que a WebGL é realmente uma API bastante simples.
Tudo bem, simples pode ser a palavra errada. Mas o que ela faz é simples. Ela apenas
executa 2 funções fornecidas pelo usuário, um vertex shader e um fragment shader e
desenha triângulos, linhas ou pontos.
Embora possa ser mais complicado fazer uma abordagem 3D, essa complicação é
definida por você, o programador, sob a forma de shaders mais complexos.
A própria API da WebGL é apenas um rasterizador e, conceitualmente, bastante simples.</p>
<p>Cobrimos um pequeno exemplo que mostrou como fornecer dados em um atributo e 2 uniforms.
É comum ter múltiplos atributos e muitos uniforms. Perto do topo deste artigo
também mencionamos <em>varyings</em> e <em>texturas</em>. Isso aparecerá em lições subsequentes.</p>
<p>Antes de avançarmos, quero mencionar que para <em>a maioria das</em> aplicações em atualização
os dados em um buffer, como fizemos em <code class="notranslate" translate="no">setRectangle</code>, não são comuns. Usei esso
exemplo porque pensei que era mais fácil de explicar porque mostra coordenadas de pixels
como entrada e demonstra como fazer uma pequena quantidade de cálculos na GLSL. Não é errado, há
muitos os casos em que isso é o certo a se fazer, mas você deve <a href="webgl-2d-translation.html">continuar lendo para descobrir
a maneira mais comum de posicionar, orientar e dimensionar coisas na WebGL</a>.</p>
<p>Se você é 100% leigo na WebGL e não tem ideia do que é GLSL ou shaders ou o que a GPU faz, então,
em seguida, verifique [os conceitos básicos de como a WebGL realmente funciona] (webgl-how-it-works.html).(webgl-how-it-works.html).</p>
<p>Você também deve, pelo menos, ler brevemente sobre <a href="webgl-boilerplate.html">o código boilerplate usado aqui</a>
que é usado na maioria dos exemplos. Você também deve, pelo menos ver
<a href="webgl-drawing-multiple-things.html">como desenhar múltiplas coisas</a> para ter uma ideia de como
as aplicações em WebGL são estruturadas porque, infelizmente, apenas desenha algo e, portanto, não mostra essa estrutura.</p>
<p>Caso contrário, a partir daqui você pode ir em duas direções. Se você está interessado em processar imagens
Vou lhes mostrar <a href="webgl-image-processing.html">como fazer algum processamento de imagem 2D</a>.
Se você está interessado em aprender sobre translação, rotação e escala, então,
<a href="webgl-2d-translation.html">comece aqui</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fundamentals.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" selected>Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentos</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-getting-webgl2.html">Como utilizar a WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-fundamentals.html">Fundamentos da WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 State Diagram</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl2-whats-new.html">O que há de novo na WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl1-to-webgl2.html">Migrando do WebGL1 para a WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl1-to-webgl2-fundamentals.html">Diferenças entre a WebGLFundamentals.org e a WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Processamento de Imagem</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-image-processing.html">Processamento de Imagem WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-image-processing-continued.html">Processamento de Imagem Continuada WebGL2</a></li>
        </ul>
  <li>Translação 2D, rotação, escala, matriz matemática</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-2d-translation.html">Translação 2D WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-2d-rotation.html">Rotação 2D WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-2d-scale.html">Escala 2D WebGL2</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-matrix-naming.html">WebGL2 3D - Nomenclatura das Matrizes</a></li>
        </ul>
  <li>Iluminação</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Estrutura e Organização</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometria</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Texturas</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-cors-permission.html">WebGL2 - Cross Origin Images</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Renderizando Uma Textura</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Técnicas</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-text-html.html">WebGL2 Texto - HTML</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-text-canvas2d.html">WebGL2 Texto - Canvas 2D</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Diversos</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-setup-and-installation.html">WebGL2 Configuração e Instalação</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-animation.html">WebGL2 - Animação</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-and-alpha.html">WebGL2 e o Alpha</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-2d-vs-3d-library.html">WebGL2 - Bibliotecas 2D vs 3D</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-matrix-vs-math.html">WebGL2 Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-tips.html#html-background">Use WebGL2 as Background in HTML</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/pt-br/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/pt-br/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Documentação da API</a></li>
  <li><a href="https://twgljs.org">TWGL, Uma Pequena Biblioteca Auxiliar da WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Problemas/Bug? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Pergunte no github</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Fundamentos da WebGL2';
            var disqus_title = 'Fundamentos da WebGL2';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



